<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>react——无状态组件和高阶组件 | Wisdommm</title>
  <meta name="description" content="Welcome to my blog" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Wisdommm">

  
  
  

  
</head>


<body class="post-template">

  <header class="site-head"  style="background-image: url(//blog.ghost.org/content/images/2013/Nov/cover.png)" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="//blog.ghost.org/content/images/2013/Nov/bloglogo_1-1.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Wisdommm</h1>
            <h2 class="blog-description">Welcome to my blog</h2>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2016-12-04T08:25:05.000Z" itemprop="datePublished">
          2016-12-04
      </time>
    
</span>
    <h1 class="post-title">react——无状态组件和高阶组件</h1>
    <section class="post-content">
      <h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>先来说说无状态组件吧，顾名思义，无状态组件就是指的没有状态的组件，众所周知在react中，状态指的就是state，而没有state，会有什么好处和坏处呢？</p>
<p>react中所有的数据，都是通过state和props来保存的，state主要是组件内部的数据交流，可以进行各种读写操作，而props主要是组件间的数据交流，一般针对props仅仅执行只读，不会做额外的操作。所以话说回来，无状态组件，没有state，那么内部的逻辑必将大大减少，编写react组件的方便性也将大大提高。</p>
<p>下面是一个简单的无状态组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Hello(props&#123;</div><div class="line">  return &lt;div&gt;Hello&#123;props.name&#125;&lt;/div&gt;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(&lt;Hello name=&quot;world&quot; /&gt;, mountNode)</div><div class="line"></div><div class="line">// 最后一句也可以这么写</div><div class="line">ReactDOM.render(Hello(&#123;&quot;name&quot;:&quot;world&quot;&#125;), mountNode)</div></pre></td></tr></table></figure>
<p>通过这个简单的示例可以看到，原本需要写的<code>react</code>类定义（<code>React.createClass</code>或者<code>class Component extends React.Component</code>）来创建自己组件的定义，但是由于这仅仅是一个无状态组件（无状态函数），<code>react</code>在渲染的时候也省掉了奖<code>react</code>组件类实例化的过程。</p>
<p>所以对于一些纯静态展示的功能模块，可以考虑作为无状态组件，而无状态组件用来实现服务端渲染也是比较方便的，只要避免去获取dom节点就可以了。</p>
<h3 id="无状态组件的生命周期方法"><a href="#无状态组件的生命周期方法" class="headerlink" title="无状态组件的生命周期方法"></a>无状态组件的生命周期方法</h3><p>我们可以看到，无状态组件就剩了一个<code>render</code>方法，因此也就没有实现组件的生命周期方法，例如<code>componentDidMount</code>, <code>componentWillUnmount</code>等。那应该怎么办呢？这个时候就用到了高阶组件。</p>
<p>###高阶组件###</p>
<p>高阶组件是什么？通过函数，向现有的组件类添加逻辑，就叫做高阶组件。</p>
<p>之前上面已经说了，无状态组件是没有<code>state</code>的，所以里面基本也就没有什么逻辑，可是如果我现在需要添加逻辑了，且又想继续使用这个无状态组件，怎么办呢？那就可以使用高阶组件。</p>
<p>先来看看这个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function noId() &#123;</div><div class="line">  return function(Comp) &#123;</div><div class="line">    return class NoID extends Component &#123;</div><div class="line">      render() &#123;</div><div class="line">        const &#123;id, ...others&#125; = this.props;</div><div class="line">        return (</div><div class="line">          &lt;Comp &#123;...others&#125;/&gt;</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const WithoutID = noId()(Comp);</div></pre></td></tr></table></figure>
<p>这个例子向我们展示了高阶组件的工作方式，通过函数和闭包等方法，改变已有组件的行为，示例里面改变了id属性。</p>
<p>之所以称之为高阶组件，是因为在react中，这种嵌套的逻辑关系会反映到组件树上，层层嵌套就像高阶函数的function in function一样，如下图所示：</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.png" alt=""><br><br>从上图可以看出组件树虽然嵌套了许多层，但是实际渲染的无状态组件中的dom结构并没有发生改变，所以我们可以放心地使用高阶组件，哪怕重复使用，也不必担心影响输出的dom结构。而借助函数的表现能力，高阶组件的用途几乎是无穷尽的。</p>
<p>###适配器###</p>
<p>有时候你需要替换一些已有的组件，而新组件接受的参数和原组件并不完全一样.</p>
<p>你可以考虑修改所有原组件的代码来保证传入正确的参数——so bad。</p>
<p>你也可以通过使用高阶组件，把新组件做一层封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class ListAdapter extends Component &#123;</div><div class="line">    mapProps(props) &#123;</div><div class="line">        return &#123;/* new props */&#125;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;NewList &#123;...mapProps(this.props)&#125; /&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有十个组件需要适配呢？当然，每个组件写十遍也不是不行，不过，高阶组件或许会给你一个更好的答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function mapProps(mapFn) &#123;</div><div class="line">    return function(Comp) &#123;</div><div class="line">        return class extends Component &#123;</div><div class="line">            render() &#123;</div><div class="line">                return &lt;Comp &#123;...mapFn(this.props)&#125;/&gt;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">const ListAdapter = mapProps(mapPropsForNewList)(NewList);</div></pre></td></tr></table></figure>
<p>借助高阶组件，关注点被分离得足够彻底，你不需要考虑组件的渲染，你只需要考虑属性的map就够了。</p>
<p>###处理副作用###</p>
<p>在组件中，往往有很多的状态和副作用要处理，最常见的情况就是异步了。</p>
<p>假设我们需要异步加载一个用户列表，通常的代码会是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class UserList extends Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super();</div><div class="line">    this.state = &#123;</div><div class="line">      list: []</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    loadUsers()</div><div class="line">      .then(data=&gt; </div><div class="line">        this.setState(&#123;list: data.userList&#125;)</div><div class="line">      )</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;List list=&#123;this.state.list&#125; /&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  /* other bussiness logics */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实际情况中，以上代码往往还会和其他一些业务函数混杂在一起，如果再来一个或多个其他的列表呢，不仅代码会重复，大量有状态和副作用的组件也使得组件难以测试。或许你会考虑使用一些数据管理工具，比如flux或redux，是的，当然可以，可是这就像大炮打蚊子，杀鸡用牛刀。所以回到这个问题上来，我们只是想做一个异步的列表，仅此而已。</p>
<p>使用高阶函数试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function connectPromise(&#123;promiseLoader, mapResultToProps&#125;) &#123;</div><div class="line">  return Comp=&gt; &#123;</div><div class="line">    return class AsyncComponent extends Component &#123;</div><div class="line">      constructor(props) &#123;</div><div class="line">        super();</div><div class="line">        this.state = &#123;</div><div class="line">          result: undefined</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      componentDidMount() &#123;</div><div class="line">        promiseLoader()</div><div class="line">          .then(result=&gt; this.setState(&#123;result&#125;))</div><div class="line">      &#125;</div><div class="line">      render() &#123;</div><div class="line">        return (</div><div class="line">          &lt;Comp &#123;...mapResultToProps(props)&#125; &#123;...this.props&#125;/&gt;</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">const UserList = connectPromise(&#123;</div><div class="line">    promiseLoader: loadUsers,</div><div class="line">    mapResultToProps: result=&gt; (&#123;list: result.userList&#125;)</div><div class="line">&#125;)(List); //List can be a pure component</div></pre></td></tr></table></figure>
<p>可以看到，这样不仅大量减少了重复的代码，还把散落在各处的异步逻辑封装进了可以单独管理和测试的函数中，在实际业务场景中，只需要按照“纯组件＋配置”就可以实现相同的功能，而无论是纯组件还是配置，都是对单元测试友好的，至少比异步组件友好多了吧。</p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>Wisdommm</h4>
    <p>A designer, developer and entrepreneur. Spends his time travelling the world with a bag of kites. Likes journalism and publishing platforms.</p>
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://wisdommm.github.io/2016/12/04/react无状态组件和高阶组件/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://wisdommm.github.io/2016/12/04/react无状态组件和高阶组件/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://wisdommm.github.io/2016/12/04/react无状态组件和高阶组件/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2016/12/18/D2总结（1）/">
        ← D2总结（Fusion Design）
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2016/11/08/react生命周期源码解读/">
        从源码看react生命周期 →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h1>

    
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Wisdommm</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>
