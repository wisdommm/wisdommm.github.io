<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wisdommm</title>
  <meta name="author" content="Wisdommm">
  
  <meta name="description" content="programmer,front to end">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Wisdommm"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Wisdommm" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Wisdommm</a></h1>
  <h2><a href="/">Welcome to my blog</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-05T09:24:12.000Z"><a href="/2016/09/05/vue.js 组件入门（一）/">2016-09-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/05/vue.js 组件入门（一）/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="vue-js-组件快速入门（一）"><a href="#vue-js-组件快速入门（一）" class="headerlink" title="vue.js 组件快速入门（一）"></a>vue.js 组件快速入门（一）</h2><p>原文（<a href="http://www.cnblogs.com/keepfool/p/5625583.html）" target="_blank" rel="external">http://www.cnblogs.com/keepfool/p/5625583.html）</a></p>
<p>在前端开发中，以前我们会把常用的公共的方法（函数）提取出来，整合为一个库，最有名的当属jQ了吧，然后到了react出现，这些类库主要都是针对view层进行的操作与封装，我们又可以把view层面上的一些东西抽出来进行封装和整理，比如一个table，一个button，一个div等，也可以像曾经提取函数一样抽出来，写成公用的，在需要使用的地方直接引入就可以了，当然，也可以根据你实际运用的需要进行适当的自定义配置，而这些被抽出来共用的table，button，div这些，就叫做组件。</p>
<p>上面是我自己瞎扯的，原文作者讲得比较繁琐，所以我就用自己的语言来概述了一下，虽然这篇文章是我转载的，不过我也参考了其它的文章／博客，知识点的流程和原文相似度80%，但是语言基本上都是我自己重新组织的，所以加了很多自己的想法和思考，下面我们开始进入正题。</p>
<h1 id="vue组件，创建与注册的基本步骤。"><a href="#vue组件，创建与注册的基本步骤。" class="headerlink" title="vue组件，创建与注册的基本步骤。"></a>vue组件，创建与注册的基本步骤。</h1><p>vue组件的使用，有三个步骤，分别是创建组件，注册组件和使用组件，如下图所示。<br><img src="http://oatasl78l.bkt.clouddn.com/vue1.png" alt=""></p>
<p>我们可以用一段代码来演示这三个步骤：</p>
<p>fsfsddsnewwkqldkwel;dfkewlklqw;kelwqe<br>&lt;!DOCTYPE html&gt;</p>
<p><html><br>    <body><br>        <div id="app"><br>            <!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件--><br>            <my-component></my-component><br>        </div><br>    </body><br>    <script src="js/vue.js"></script><br>    <script></p>
<pre><code>    // 1.创建一个组件构造器
    var myComponent = Vue.extend({
        template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos;
    })

    // 2.注册组件，并指定组件的标签，组件的HTML标签为&lt;my-component&gt;
    Vue.component(&apos;my-component&apos;, myComponent)

    new Vue({
        el: &apos;#app&apos;
    });

&lt;/script&gt;
</code></pre><p></html><br>fsfsddsnew</p>
<p>运行结果很简单，就是一句“This is my first component!”，可以看到，使用组件和使用普通的HTML元素没什么区别，你可以就把组件当做一个HTML元素来使用。</p>
<p>要理解组件的创建和注册，我们可以用一下几个步骤来详细解释：</p>
<ol>
<li>Vue.extend()是Vue构造器的扩展，调用Vue.extend()创建的是一个组件构造器，而不是一个具体的组件实例。</li>
<li>Vue.extend()构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的HTML。 </li>
<li>使用Vue.component()注册组件时，需要提供2个参数，第1个参数时组件的标签，第2个参数是组件构造器。 </li>
<li>Vue.component()方法内部会调用组件构造器，创建一个组件实例。 </li>
<li>组件应该挂载到某个Vue实例下，否则它不会生效。</li>
</ol>
<p>我们一句一句来分析，先是创建一个组件，代码是</p>
<p>fsfsddsnewvar myComponent = Vue.extend({<br>    template: ‘<div>This is my first component!</div>‘<br>})fsfsddsnew</p>
<p>创建组件很简单，直接调用vue构造器的扩展方法就行了，里面会传入一个对象，对象里面有个template属性，它指代的是这个组件的view的内容，是不是像react里面的render函数啊，它也是return的view内容，<strong>它们有哪些不同呢？</strong>毕竟学习知识要针对各种不同的但是有类似的知识点来进行归纳，整理和综合，才能进行融会贯通的运用。毕竟古人云：学而时习之，不亦悦乎！<br><br>好了，这是创建，下面是注册了，注册也很简单，一句代码就搞定了：Vue.component(‘my-component’, myComponent);，使用Vue.component方法，传入两个参数，第一个参数是你想注册的组件名，第二个参数是你创建的组件名，是不是有点混淆？先是你通过Vue.extend创建了一个组件，名字叫myComponent，然后为了在HTML中能够当做标签来使用，你需要给你创建的这个组件注册一个组件名，名字叫做my-component，所以你在HTML就可以直接把你注册的组件名当做HTML标签来使用，像这样<my-component></my-component>就可以了。<br><br>现在组件创建好了，也注册好了，可是还不能直接使用，因为还需要new一个Vue实例，才能使用，像这样</p>
<p>fsfsddsnewnew Vue({<br>    el: ‘#app’<br>});fsfsddsnew</p>
<p>一个Vue实例接收一个对象，里面的el属性是你组件的挂载节点，于是我又情不自禁地联想到了react，ReactDOM.render( dom , root)，就像这样，react也是将一个view界面的虚拟dom挂载到一个root节点上，而这里的Vue同样，需要将刚才的组件也挂载到某个节点下，这两者之间的异同后面再说吧，先说一点主要的，vue里的节点指的是vue组件的作用域，这点是和react差异比较大的一点，你将vue组件挂载在了某个节点下，意思是这个组件只有在这个节点范围内才可以使用，至于是使用多次，使用一次，还是一次都不使用，都没问题。而我们这个实例上，就是挂载在了id为app的节点上，所以在这个节点的范围内都可以使用<my-component></my-component>的形式，来调用vue组件myComponent。同理，如果你想在多个节点的作用域内使用某个vue组件的话，那你就得多new几次，把组件的挂载到多个节点下面就好了，而如果在没有实例化的组件中非法调用某个vue组件，它将不起任何作用。<br>详细情况可以看以下代码：</p>
<p>fsfsddsnew<br>&lt;!DOCTYPE html&gt;</p>
<p><html><br>    <body><br>        <div id="app1"><br>            <my-component></my-component><br>        </div><br>        <div id="app2"><br>            <my-component></my-component><br>        </div><br>        <div id="app3"><br>            <!--该组件不会被渲染--><br>            <my-component></my-component><br>        </div><br>    </body><br>    <script><br>        var myComponent = Vue.extend({<br>            template: ‘<div>This is a component!</div>‘<br>        })</p>
<pre><code>    Vue.component(&apos;my-component&apos;, myComponent)

    var app1 = new Vue({
        el: &apos;#app1&apos;
    });

    var app2 = new Vue({
        el: &apos;#app2&apos;
    })
&lt;/script&gt;
</code></pre><p></html><br>fsfsddsnew</p>
<p>上面代码中，我们创建了一个名叫myComponent的vue组件，然后注册了一个名叫my-component的组件来当做HTML标签使用，最后我们实例化时，只在id=”app1”和id=”app2”中挂载了这个vue组件，而在实际使用的时候，我们在id=”app3”中也使用了这个<my-component></my-component>组件，所以最后，只有id=”app1”和id=”app2”的div中组件成功地被替换成了“This is a component!”，而id=”app3”中的<my-component></my-component>标签将不会被渲染。具体效果如下图所示：<br><img src="http://oatasl78l.bkt.clouddn.com/vue2.png" alt=""></p>
<p>好了，一个基本的vue组件的一整套流程基本就完全是这样了，any problems else？我知道，现在还有很多的问题没有解决，比如创建组件，注册组件和实例化挂载到某个节点下，整体步骤比较繁琐；注册组件的时候可以局部注册吗；组件可以嵌套吗？如果可以，如何嵌套；vue组件怎么怎么做成可扩展的？又怎样变为自定义配置呢？</p>
<p>我下一篇博客再细细道来。</p>
</script></html></p>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-03T08:25:56.000Z"><a href="/2016/09/03/node express实现/">2016-09-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/03/node express实现/"></a></h1>
  

    </header>
    <div class="entry">
      
        <hr>
<h2 id="express实现"><a href="#express实现" class="headerlink" title="express实现"></a>express实现</h2><p>express是node里面一个十分常用的库，用它来搭建服务器，事半功倍，且小巧灵活，有足够多的特性，用来进行各种网页开发。</p>
<p>我们先来看下express的使用的，毕竟知己知彼，百战不殆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//引入express，确保你的项目依赖了express库，否则的话先npm install一下</div><div class="line">var express = require(&apos;express&apos;);</div><div class="line">//执行express函数，</div><div class="line">var app = express();</div><div class="line">// 使用get方法，当请求的路由是hello时，返回hello</div><div class="line">app.get(&apos;/hello&apos;, function (req, res) &#123;</div><div class="line">  res.send(&apos;hello&apos;);</div><div class="line">&#125;);</div><div class="line">// 当请求的路由是world时，返回world</div><div class="line">app.get(&apos;/world&apos;, function (req, res) &#123;</div><div class="line">  res.send(&apos;world&apos;);</div><div class="line">&#125;);</div><div class="line">// 当请求的路由是其它时，返回“没有找到匹配的路径”</div><div class="line">app.get(&apos;*&apos;, function (req, res) &#123;</div><div class="line">	res.setHeader(&apos;content-type&apos;,&apos;text/plain;charset=utf8&apos;);</div><div class="line">	res.end(&apos;没有找到匹配的路径&apos;);</div><div class="line">&#125;);</div><div class="line">// 最后监听端口</div><div class="line">var server = app.listen(3000, function () &#123;</div><div class="line">  console.log(&apos;正在监听3000端口&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面或许就是express最常见，也是最基本的使用吧，启动了一个服务器并且监听3000端口，对/hello的路由返回“hello”，对/world的路由返回“world”，对其他的路由返回“没有找到匹配的路径”。</p>
<p>示例看完了，下面我们来看看具体的实现吧，在这之前，我想说一下http这个模块，毕竟express就是对http进行了一下封装，既然想看看express的内部，当然就离不开http了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">  response.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</div><div class="line">console.log(&apos;正在监听3000端口。&apos;);</div></pre></td></tr></table></figure>
<p>就上面这几行，就已经成功地实现了一个简单的服务器了，我们可以分拆一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.createServer(function(...)&#123;...&#125;).listen(3000);</div></pre></td></tr></table></figure></p>
<p>现在，我们再回过头来看看express。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 首先，声明express函数</div><div class="line">var express = function () &#123;&#125;;</div><div class="line">// 它的内部应该有一个app函数，用来作为实例。</div><div class="line">var express = function () &#123;</div><div class="line">	var app = function(...)&#123;...&#125;</div><div class="line">&#125;;</div><div class="line">// 这个实例还应该有很多的方法，比如get，listen等。（本来我是想用es5的方式写的，后来发现好久没用那种方法，写function写得太累了。。。）</div><div class="line">var express = ()=&gt; &#123;</div><div class="line">	var app = (req,res)=&gt;&#123;...&#125;;</div><div class="line">	app.listen = (...)=&gt;&#123;...&#125;;</div><div class="line">	app.get = (...)=&gt;&#123;...&#125;;</div><div class="line">&#125;;</div><div class="line">// 最后，为了能够完成链式调用，所以我们返回这个实例app，然后exports一下，就完成了。</div><div class="line">var express = ()=&gt; &#123;</div><div class="line">	var app = (...)=&gt;&#123;...&#125;;</div><div class="line">	app.listen = (...)=&gt;&#123;...&#125;;</div><div class="line">	app.get = (...)=&gt;&#123;...&#125;;</div><div class="line">	return app;</div><div class="line">&#125;;</div><div class="line">module.exports = exports = express;</div></pre></td></tr></table></figure>
<p>这就是express基本的框架，如果后续有什么扩展的，也可以直接在里面增加一个函数就好了，<figure class="highlight plain"><figcaption><span>= (...)=>&#123;...&#125; ```，接下来，我们来慢慢分析里面的构造。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">先看一个最简单的吧，listen方法。</div></pre></td></tr></table></figure></p>
<p>app.listen = function (port) {<br>    require(‘http’).createServer(app).listen(port);<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">是不是发现了什么？再上去看一眼http，是不是很相似啊。。。没错，就是这样的。</div></pre></td></tr></table></figure></p>
<p>http.createServer(function(…){…}).listen(3000);<br>```</p>
<p>而中间的app函数，对应的就是http.createServer的参数了。<br>感觉这个listen函数应该不需要多讲。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-21T09:03:14.000Z"><a href="/2016/08/21/vue todo/">2016-08-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/21/vue todo/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="vue-todo示例"><a href="#vue-todo示例" class="headerlink" title="vue todo示例"></a>vue todo示例</h1><p>最近抽空看了下vue，一个轻量级的前端框架（类库），它采用的mvvm模式，且数据双向绑定，刚好官方网站上有一个todo实例，我感觉和redux的todo实例很类似，所以准备将这两个框架的todo实例分别解读一下，来比较一下个中异同。</p>
<p>这个代码就两部分，先是html：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;li v-for=&quot;todo in todos&quot;&gt;</div><div class="line">      &lt;span&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</div><div class="line">      &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>接下来是js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    newTodo: &apos;&apos;,</div><div class="line">    todos: [</div><div class="line">      &#123; text: &apos;Add some todos&apos; &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    addTodo: function () &#123;</div><div class="line">      var text = this.newTodo.trim()</div><div class="line">      if (text) &#123;</div><div class="line">        this.todos.push(&#123; text: text &#125;)</div><div class="line">        this.newTodo = &apos;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    removeTodo: function (index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我第一次看到这段代码的时候觉得有点诧异，就这么点代码就实现了一个todo list，比react少了好多，如果是redux的todo list，别说代码，文件夹数量就可以让你一双手数不过来，而这vue两个文件夹一共才这么点代码，下面来仔细看看这个代码吧。<br>先看下html代码吧，除了原生的html代码外，这里有几个vue特有的属性，显而易见，所有以<strong>v</strong>开头的属性，都是vue特有的属性，比如这里的v-model=”newTodo”，v-on:keyup.enter=”addTodo”，v-for=”todo in todos”，v-on:click=”removeTodo($index)”，一共就这四个吧，而就是字符串模版了，从js文件的某个对象中获取数据来填充到页面上。<br>js代码也很少，估计一共才十多行，抛去中间的内容不看，就成了new Vue({})了，很显然这就是new了一个Vue实例，算是初始化，然后我们再来对内容一行一行地解读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">el: &apos;#app&apos;</div></pre></td></tr></table></figure>
<p>先看一下app在html文件里指代的是什么，一看便知，app在这里指代的是最外层div的id，而这里的＃应该类似于jQuery选择器中的符号吧（所以我猜测这里也可以用“.app”来选择class为app的元素来作为Vue的容器），前面的el应该指的是element吧。<br>再看下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">    newTodo: &apos;&apos;,</div><div class="line">    todos: [</div><div class="line">      &#123; text: &apos;Add some todos&apos; &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个data很明显说明了这里面装的是数据，我们可以看到这里一共有两条数据，一条是newTodo的数据，类型是字符串，另一条是todos数据，类型是数组对象，然后我们现在再返回html中，查看那里用到了这两条数据的，可以看到<strong>v-model=”newTodo”</strong>，所以我们暂时可以知道具有v-model属性的这个input输入框和newTodo这条数据绑定了起来，至于是单向绑定还是双向绑定还是仅仅是初始化的时候绑定一次，我们现在还不知道，接着看下面的todos，<strong>v-for=”todo in todos”</strong>，可以明白的知道，这是个for遍历，类似于for(i in object)一样，而这里的意思就类似于在todos这个数组中遍历一下，然后在li标签内对遍历到的数据进行操作，下面就用到了字符串模版，将需要的数据提取出来就好了。<br>继续往下面看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">methods: &#123;</div><div class="line">    addTodo: function () &#123;</div><div class="line">      var text = this.newTodo.trim()</div><div class="line">      if (text) &#123;</div><div class="line">        this.todos.push(&#123; text: text &#125;)</div><div class="line">        this.newTodo = &apos;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    removeTodo: function (index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分是methods，按照字面意思来看，叫做方法，也就是js中的函数（function），可以看到里面一共包含了两个function，一个是addTodo，另一个是removeTodo，回顾html文件，可以知道调用这两个函数方法的地方分别是<strong>v-on:keyup.enter</strong>和<strong>v-on:click</strong>，前一个就是类似于原生的onKeyup方法，而第二个就是onClick了，不过keyup后面跟了enter，说明这个keyup方法是和enter健绑定的，现在我们可以进入这两个函数内部看看，看它具体的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">addTodo: function () &#123;</div><div class="line">      var text = this.newTodo.trim()</div><div class="line">      if (text) &#123;</div><div class="line">        this.todos.push(&#123; text: text &#125;)</div><div class="line">        this.newTodo = &apos;&apos;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数中主要是在针对this.newTodo进行操作，我们不难发现，newTodo这条数据是和v-model这个属性绑在一起的，然后这个属性又是和input输入框绑定在一起的，所以可以表明这里的this.newTodo指的就是input输入框里的值，然后再将其去除首尾空格，push进todos列表，最后再清空输入框。<br>而我们再来看下另一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">removeTodo: function (index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数更简单，就一句话，执行一个数组操作，删除数组的某一项，而这个函数的调用在这里：v-on:click=”removeTodo($index)”，可以看到在调用的时候传入了一个参数$index，这指的是对应的li标签的index，然后当点击的时候，就可以通过index来删除这个li标签了。</p>
<p>说了这么多，我知道，理工科的东西讲再多的道理都是十分抽象的，所以最后我还是上几张图吧，为了能够更好的理解。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%201.png" alt=""><br>图1<br>这是初始化的时候，一切都为空。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%202.png" alt=""><br>图2<br>然后我在输入框里输入数据，按下enter键。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%203.png" alt=""><br>图3<br>可以看到，下面列表中多了一条数据，是我刚才输入的数据。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%204.png" alt=""><br>图4<br>然后我又输入了几条数据，一共三条。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%205.png" alt=""><br>图5<br>最后我删除其中一条，就删除第二条吧，点击右边的那个小叉就可以了，可以看到这条就被删了，其他的数据不变。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-19T13:42:59.000Z"><a href="/2016/08/19/hexo-search/">2016-08-19</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/19/hexo-search/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="hexo博客增加搜索功能"><a href="#hexo博客增加搜索功能" class="headerlink" title="hexo博客增加搜索功能"></a>hexo博客增加搜索功能</h1><p>最近在用在某个项目上增加一个搜索框，后端用node＋mongodb实现，本来以为挺简单的，就用node爬一下页面title和href，然后放进mongodb中，再通过前端发请求传数据过来查找，然后node再在mongodb中查找，将数据返回前端。</p>
<p>这是理想情况下的做法，可是现实往往充满了曲折,下面我来简单介绍下这个项目，然后说一下问题吧。</p>
<ol>
<li>这是个内网项目，所以爬虫爬不进去，好在有一个目录页，将所有页面的title和href整理了起来，不过读取这个文件也不是简单的事，因为这个是类似于json格式的文件，但是却没有任何的符号，全是汉字，而我们存储的时候是需要分层次的，这样利于查找，采用node的FS模块可以很容易地读取到文件的内容，但是仅仅是读取，直接存储的话会导致没有层次感，所以我就把这个文件复制了一份出来，通过人工维护的方式将其变为json格式，然后就很好操作了，不过需要人工维护与更新，不算是最好的办法，但是那个文件之前也是人工维护的（虽然我不知道是谁维护，否则可以叫他一起维护下）。</li>
<li>这是个hexo博客系统，纯静态展示的，所有页面均是通过通过hexo的框架，执行hexo g命令的时候，会自动将md文件解析成html（css），然后再通过执行hexo server命令，开一个hexo的服务器，把所有的页面通过服务端渲染到浏览器；因此，我增加的这个搜索框的功能，除了需要自己写服务器和数据库外，还必须把这个项目单独部署，因为hexo的源码上并没有针对服务器的扩展方法（这一点是@南烛帮我一起看的，毕竟我之前对hexo的了解只是会用而已，并没有在它的源码上进行深入研究），因此，这就成为了两个项目，然后把这两个项目部署在同一台服务器上，再通过配置nginx服务，将搜索框从前端发来的请求映射到node服务器监听的那个端口，这样就形成了前后端数据的交互，这里出现了一个比较奇怪的问题，我在我自己电脑上发送请求时，请求能够成功发出去，可就是接收不到返回的内容，然后我从另一台电脑通过花瓶代理请求到我本地来测试接口，却发现是正常的，最后发现是两个项目之间的请求跨域了。</li>
<li>解决跨域，可以选择将项目部署在服务器，然后再测试，不过这就比较麻烦了，修改bug比较蛋疼，或者使用代理，将请求代理到另一个域来，这样修改bug也比较简单，现在开始发请求了，发现查找结果是没有数据，没关系，我刚刚只是随便输入的一个词，现在我输入一个数据库里存在的词重新发送请求，不过问题就出来了，还是没有数据，怎么可能啊，数据库里确实有这个数据啊，怎么会查不到，于是我换了几个数据库里存在的词，再反复查找，结果大多都是不存在，唯一存在的一个是一个英文单词，然后我就查看请求，发现地址没错，参数呢？参数怎么自动给我转码了，我就好奇了，然后我再去后台将这个获取到的请求参数，对比了一下接收到各种参数的情况，发现汉字会自动转码，数字和英文单词会保持不变，但是当查询的字符串中间出现空格的时候，会自动变为加号来填充空格，所以，只有无空格的数字或英语字母才可以直接查找到结果，否则的话都需要人工再进行一次转码，将其转过来，唉，毕竟第一次写服务器，这些都需要靠自己独自摸索。</li>
<li>接下来是mongodb的事情。之前使用百度搜索还是谷歌搜索，我都没发现什么大的问题（可能是我搜索的问题太傻了），这次查询mongodb和mongoose的相关资料，发现百度搜索出来的都是以一些博客，百度知道的回答为主，且各个博客之间相互抄袭也是够无聊的，仅仅只是做到了制造而不是创造。然后我就去谷歌采用英文搜索，stackoverflow，官方网站等都是排在很前面的（不知道百度为什么把人家官网排在很后面），算了，不吐槽了。mongodb这种非关系型轻量级数据库，使用起来是很方便的，增删查改的api都是比较简单的，根据所示范的例子动手稍微写一下就会用了，不过对于第一次使用的我来说，还是遇到了一些问题：存储的时候，mongodb会自动给你加上下划线id，我估计是为了区分存储空间，可是这就会存在一个问题，当我存储了一条数据过后，再储存一条相同的数据进去，是可以存储进去的，因为它们的下划线id不同，这显然不对啊，我否则我一查找，却找到很多条数据，仔细一看却发现这么多条数据都是一样的，不是很搞笑吗，所以我选择了给每条数据加上一个index作为唯一标志符，然后再在每次启动的时候，去读取文件存储进数据库里，存进去之前会先去数据库里通过这个index唯一标志符查找一遍，如果查询结果为空，我才会把这条数据存进去，否则就不存。其实吧，每次存储的时候会人为的自动查找，相当于遍历了一遍数据库，如果是在正常的稍微大一点的项目来说，这是十分十分十分影响性能的，由于我这里是个很小的项目，所以才可以进行这种方式查询；其次是mongo查找的时候，默认的方式是精确匹配，不支持模糊查询，这怎么办呢，难道需要我在查询的时候再遍历一遍数据库，使用indexOf来查询？我感到很可笑，因为你这么傻的方法在实际中是肯定行不通的，再说了，就算可以，那么大小写的模糊查询怎么办？难道要我判断下有没有英文字母然后分别用用大写和小写都来遍历一下？这个时候就可以使用正则了，将查询的字符串改变为正则表达式，这样的话在数据库里它会自动的去匹配所有适合的结果。</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-28T06:33:08.000Z"><a href="/2016/07/28/react demo/">2016-07-28</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/28/react demo/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="redux-example"><a href="#redux-example" class="headerlink" title="redux example"></a>redux example</h2><p>最近在做店铺装修，很很很麻烦的一个项目，刚好里面用到了redux，我发现店铺装修简化一下的话，简直是redux的十分好的一个示例啊，比官网上简单的示例要难，又比难的简单，而且条理结构什么的又很清楚，挺不错的啊。</p>
<p>我先上图吧。<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex1.png" alt=""><br>图1<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex2.png" alt=""><br>图2<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex3.png" alt=""><br>图3<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex4.png" alt=""><br>图4<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex5.png" alt=""><br>图5<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex6.png" alt=""><br>图6<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex7.png" alt=""><br>图7<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex8.png" alt=""><br>图8<br><br>好吧，这图截的也是够大的，将就看看吧。。。由图1可以看到，页面一共分为四部分：左，中上，中下，右，也就是氛围四个组件：Left，Top，Center，Right。接下来我说一下交互，如图2所示；我在左边的输入框中输入东西，然后点击增加，可以看到，刚刚新增的数据立马在右边下面部分显示了出来，展示的是刚才新增的数据和一个删除按钮，如图3所示；若你点击展示的数据，那么在右边，也就是编辑组件中会出现一个输入框和编辑按钮，你可以在这里对刚刚点击的数据进行修改然后保存，如图4，图5所示；保存过后就可以看到中间的显示模块对数据进行了更新，如图6所示；接下来是中间上方的保存模块，你点击保存按钮，这个模块同样也能取到当前的数据，这里就用一个弹窗代替好了，如图7所示；最后就是删除按钮，点击后删掉当前这一行的数据，如图8所示。<br><br>好累，说了这么多，口都干了。其实吧，一两句话就可以说完的：在这四个组件中，每个组件都可以取到state，并且可以对state进行操作。说完了，是不是很简单啊。。。<br><br>我们先来看看index.js吧，也就是入口文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var App = React.createClass(&#123;</div><div class="line">    render: function()&#123;</div><div class="line">        return (</div><div class="line">            &lt;div className=&quot;row&quot;&gt;</div><div class="line">                &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt;</div><div class="line">                    &lt;LeftComponent /&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; borderRight: &apos;1px solid #999&apos;, minHeight: &apos;600px&apos;, textAlign: &apos;center&apos; &#125;&#125;&gt;</div><div class="line">                    &lt;TopComponent/&gt;</div><div class="line">                    &lt;CenterComponent/&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt;</div><div class="line">                    &lt;RightComponent /&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;            </div><div class="line">            );</div></pre></td></tr></table></figure>
<p>很简单吧，就是分别放了四个Component组件而已，我们也不用管这些组件是父子关系还是兄弟关系，因为redux不用考虑这些。然后我们去看看action吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// action </div><div class="line">module.exports = &#123;</div><div class="line">	addModelAction: function(name)&#123;</div><div class="line">	    return &#123;</div><div class="line">	        type: &apos;ADD_MODEL&apos;,</div><div class="line">	        name: name</div><div class="line">	    &#125;</div><div class="line">	&#125;,</div><div class="line">	editModelAction: function(index, name) &#123;</div><div class="line">		return &#123;</div><div class="line">			type: &apos;EDIT_MODEL&apos;,</div><div class="line">			index: index,</div><div class="line">			name: name</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	deleteModelAction: function(index) &#123;</div><div class="line">		return &#123;</div><div class="line">			type: &apos;DELETE_MODEL&apos;,</div><div class="line">			index: index</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	activeModelAction: function(index) &#123;</div><div class="line">		return &#123;</div><div class="line">			type: &apos;ACTIVE_MODEL&apos;,</div><div class="line">			index: index</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在action.js这个文件里，我们写了四个action函数，每个函数都返回一个对象作为action，是不是很简单，每个action函数中返回的对象里type都是定义好了的，然后根据传入的参数来配置其他返回参数；然后再来看看reducer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// reducers</div><div class="line">var modelReducer = function(state, action)&#123;</div><div class="line">    switch(action.type)&#123;</div><div class="line">        case &apos;ADD_MODEL&apos;:</div><div class="line">            state.items.push(&#123;</div><div class="line">                name: action.name</div><div class="line">            &#125;);</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        case &apos;DELETE_MODEL&apos;:</div><div class="line">        	state.items.splice(action.index, 1);</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        case &apos;EDIT_MODEL&apos;:</div><div class="line">        	state.items[action.index].name = action.name;</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        case &apos;ACTIVE_MODEL&apos;:</div><div class="line">            state.activeIndex =  action.index; </div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = modelReducer;</div></pre></td></tr></table></figure>
<p>这个也不难，我们都知道reducer需要传入两个参数：state和action，通过action里的type来对state进行相应的操作，最后return state。<br><br>好了，reducer和action都看了，redux三要素现在来看看store。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">import modelReducer from &apos;./reducer&apos;</div><div class="line">var store = createStore(modelReducer, &#123;items: [], activeIndex: -1 &#125;);</div><div class="line">module.exports = store;</div></pre></td></tr></table></figure>
<p>对的，一共就这几行，store=createStore(modelReducer, {items: [], activeIndex: -1 })，第一个参数是reducer，必需的，另一个是state初始化的值，非必需，若不传则默认为undefined。<br><br>其实到这里，这个示例就已经到了尾声了；剩下的就是这四个组件的内部布局，还有就是给按钮绑定事件，当点击的时候用dispatch分发一个对应的action函数给reducer，这些我在之前也已经写过了，所以这里就不再赘述了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-24T06:54:34.000Z"><a href="/2016/07/24/react生命周期/">2016-07-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/24/react生命周期/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="react生命周期解读"><a href="#react生命周期解读" class="headerlink" title="react生命周期解读"></a>react生命周期解读</h1><p>前几天在工作中出现了一个比较怪异的bug，不过还好由于react的单向数据流，从最外层父组件一层一层地往里面找，在每一层都检查一下state和props的值是否正确，总会找到问题，只不过那个组件被前人嵌套了四五层，所以在定位问题的时候比较蛋疼，所以还是最好养成良好的习惯，组件嵌套层级不要太多，而且在开发的时候每一层就别忘了检测props和state，否则后来人会很累的。。。<br><br>经过了long long time，才在某一层组件中找到了问题，具体问题是父组件传入的props改变后子组件通过props来渲染的页面没有发生改变，有疑问吗？父组件传入的props改变，子组件的props不是会自动接收变化并且render吗？嗯，是的，为什么这里没有呢。。。原来有人在开发的时候在<code>getInitialState</code>函数中加了这么一句：<code>this.state.xxx = this.props.xxx</code>，通过这样，他就把props和state关联了起来，心中顿时有无数草泥马狂奔。。。怎么改呢？难道要我把和state关联了的props都取消关联？这个工作量不小。。。还好，react里有个监测props变化的函数：<code>componentWillReceiveProps</code>，然后我再在里面把更新后的props和state关联起来，让state等于新的props就好了，大功告成，这个怪异的问题就解决了。<br><br>有人会觉得奇怪吗？为什么在<code>getInitialState</code>函数中使用了<code>this.state.xxx = this.props.xxx</code>，而在当props更新后传进来时，state依然等于原来的props，这就说到了本片文章的主要，就是react的生命周期。<br></p>
<h2 id="react组件的详细说明和生命周期"><a href="#react组件的详细说明和生命周期" class="headerlink" title="react组件的详细说明和生命周期"></a>react组件的详细说明和生命周期</h2><p>先来说一下react场见的函数吧。<br><br>1，<code>render</code>。<br><br>重要的事情说三遍：render()方法是必须的！render()方法是必须的！！render()方法是必须的！！！<br><br>当使用render方法的时候，它最终return一个单子级组件，这个意思就是说返回<strong>一个</strong>dom 组件，比如一个 div 节点，也可以是其他自定义的组件，有个要点就是一定只能 return 一个 dom 组件，当你有多个单独的dom节点或者单独的自定义组件要 return 的时候，必须要在外面包裹一层 div 才行。当然，你也可以返回 null 或者 false 来表明不需要渲染任何东西。在 return 前会干什么呢？return 的作用是渲染页面的，而渲染页面需要数据react 里的数据主要就是 props 和 state，所以在 render 方法中，它先会自动监测 props 和 state，render 方法有几个需要注意的点：1，render 函数中不能修改 state，所以 setState 方法是不能用的；2，render 并不是渲染真是的 dom ，而是 Virtual DOM，所以在这个方法中，你并不能对 dom 进行操作，this.getDOMNode()也去不到任何节点，只能得到 null。3，不和浏览器交互，例如通过使用 setTimeout。<br><br>2，<code>getInitialState</code><br><br>这是初始化state的方法，仅仅在组件挂载之前调用一次！<br><br>3，<code>getDefaultProps</code><br><br>在组件创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 this.props，（可以使用 in 来检测属性）。该方法在实例创建之前调用，因此不能依赖于 this.props。<br><br>4，<code>componentWillMount</code><br><br>这个方法会在初始化渲染完毕之前立即调用，仅执行一次。可以使用 setState 方法。<br><br>5，<code>componentDidMount</code><br><br>这个方法会在初始化渲染完毕之后立即调用，仅执行一次。这个时候已经渲染完毕了，所以 Virtual DOM 已经成为了真实的 DOM，你可以使用 this.getDOMNode()方法，发送 ajax 请求，或者 setTimeout 等方法。<br><br>6，<code>componentWillReceiveProps</code><br><br>该方法仅仅在组件接收到新的 props 的时候调用。所以初始化的时候不会调用这个方法，传入的参数将是即将接收到的新的 props，一般会通过新老 props 比较，然后再决定需不需要更新页面。<br><br>7，<code>shouldComponentUpdate</code><br><br>当组件接收到了新的 props 或者 state 的时候，即将要渲染页面之前调用这个方法。按常规来说，组件 state 或 props 更新后，往往都是需要重新渲染一下页面的，当然，这不是百分之百，所以这个时候就需要在渲染之前，在判断一下，是否真的需要渲染，在这个方法中可以获得 nextProps 和 nextState，然后我们可以比较，看是不是真的需要渲染，如果需要渲染，就return true，不需要渲染就 return false，这个方法默认是会返回 true 的。这个方法存在的意义就是不该渲染的时候不渲染，节约时间优化性能，当然，组件少了也没什么实际意义，可是当组件数量成百上千的时候，或许就会很明显地感觉到优化的性能了。<br><br>8，<code>componentWillUpdate</code><br><br>这个方法主要是在接收到新的 props 或者 state 之前立刻调用，使用该方法做一些更新之前的准备工作，此时不能更改 state。<br><br>9，<code>componentDidUpdate</code><br><br>个人觉得和componentDidMount类似，只是一个在初始化渲染后调用，一个在更新渲染后调用。<br><br>10，<code>componentWillUnmount</code><br><br>在组件从 DOM 中移除的时候立刻被调用，在该方法中执行任何清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。<br><br>唉，好累，终于把这一大堆函数科普完了，我稍微归纳一下吧，方法大致有以下几类：初始化的时候执行的，初始化渲染前执行的，初始化渲染后执行的，接收更新时执行的，接收更新后渲染之前执行的，接收更新后渲染之后执行的，即将移除前执行的。这么多方法，都是和执行时间有关，并且一个方法后往往会执行另一系列的方法，这就是它的生命周期。<br><br>所以回到上面的问题，当父组件的 props 更新后，子组件的 props 也会更新没错，但是这时并不会重新去执行一次 getInitialState 方法，因为这个方法仅仅在初始化的时候调用一次，所以最后 render 时还是用的之前的 state 来进行渲染，所以我做的就是加上 componentWillReceiveProps 来进行人为更新 state。<br></p>
<h2 id="这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。"><a href="#这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。" class="headerlink" title="这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。"></a>这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。</h2><p><img src="http://oatasl78l.bkt.clouddn.com/react%20cycle1.png" alt=""><br><br><img src="http://oatasl78l.bkt.clouddn.com/react%20cycle2.jpg" alt=""><br><br>上面两张图分别是各个不同的变化会产生的不同的一系列的方法调用，，以及每个方法是否能够对 state 进行更新都做了说明，可以看到，初始化的时候，props 变化的时候，state 变化的时候，都会触发不同方法来进行处理，有的函数是可以不写的，因为它默认会执行，经过上次改bug的事情后，我觉得吧，层级多了的时候还是最好在每个层级里面对 props 和 state 进行控制监测一下，以免发生不必要的错误。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-23T08:48:01.000Z"><a href="/2016/07/23/redux example(1)/">2016-07-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/23/redux example(1)/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="redux-example-1"><a href="#redux-example-1" class="headerlink" title="redux example(1)"></a>redux example(1)</h1><p>最近在学习redux，看了不少相关的资料，发现这个<a href="http://cn.redux.js.org/docs/introduction/Examples.html" target="_blank" rel="external">官方教程</a>的一些例子还是很不错的，由浅入深各个档次都有，所以我稍微看了下，准备有时间的话将示例都自己弄懂，然后分别写篇详细的解读出来，由于是临时起意，所以今天先写第一篇吧。</p>
<h2 id="counter-vanilla"><a href="#counter-vanilla" class="headerlink" title="counter-vanilla"></a>counter-vanilla</h2><p>这是redux中的第一个示例，也就是说是最简单的一个例子，不多说了，先看看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;Redux basic example&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;https://npmcdn.com/redux@latest/dist/redux.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;p&gt;</div><div class="line">        Clicked: &lt;span id=&quot;value&quot;&gt;0&lt;/span&gt; times</div><div class="line">        &lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt;</div><div class="line">        &lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt;</div><div class="line">        &lt;button id=&quot;incrementIfOdd&quot;&gt;Increment if odd&lt;/button&gt;</div><div class="line">        &lt;button id=&quot;incrementAsync&quot;&gt;Increment async&lt;/button&gt;</div><div class="line">      &lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">      function counter(state, action) &#123;</div><div class="line">        if (typeof state === &apos;undefined&apos;) &#123;</div><div class="line">          return 0</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (action.type) &#123;</div><div class="line">          case &apos;INCREMENT&apos;:</div><div class="line">            return state + 1</div><div class="line">          case &apos;DECREMENT&apos;:</div><div class="line">            return state - 1</div><div class="line">          default:</div><div class="line">            return state</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var store = Redux.createStore(counter)</div><div class="line">      var valueEl = document.getElementById(&apos;value&apos;)</div><div class="line">      function render() &#123;</div><div class="line">        valueEl.innerHTML = store.getState().toString()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render()</div><div class="line">      store.subscribe(render)</div><div class="line"></div><div class="line">      document.getElementById(&apos;increment&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">      document.getElementById(&apos;decrement&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">      document.getElementById(&apos;incrementIfOdd&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          if (store.getState() % 2 !== 0) &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">      document.getElementById(&apos;incrementAsync&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          setTimeout(function () &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;, 1000)</div><div class="line">        &#125;)</div><div class="line">    &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>如上面代码所示，一共也就几十行，而且就这一个文件，毕竟是最基础最简单的一个示例，所以也没有什么文件结构和包依赖，以及到node服务器等，，唯一的一个依赖也通过了script标签引入。<br>不废话了，下面开始讲解一下代码吧。<br><br>dom结构就很简单吧，主要就是一个span标签包裹一个数字，然后就是几个button按钮，点击按钮的时候会让span标签里的数字增一、减一、奇数加一变为偶数、异步加一（也就是加个定时器延迟）。<br><br>下面来看script标签里的代码，也就是实现逻辑和功能的主要代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function counter(state, action) &#123;</div><div class="line">	if (typeof state === &apos;undefined&apos;) &#123;</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	switch (action.type) &#123;</div><div class="line">		case &apos;INCREMENT&apos;:</div><div class="line">			return state + 1</div><div class="line">		case &apos;DECREMENT&apos;:</div><div class="line">        	return state - 1</div><div class="line">       	default:</div><div class="line">        	return state</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码主要实现的是reducer，它主要接收两个参数，一个是state，另一个是action，state指代的是react中的state（状态），也就是这里span标签中的数字，action是一个对象，通过action，reducer就知道该做什么，比如这段代码就是通过判断action.type，来对state进行操作。<br><br>这里有一个值得注意的点，那就是给state设置一个return的默认值，一般来说就写成<strong>function counter(state = initialState, action)</strong>，es6的写法，意思在忘了传state的时候给state传入一个默认值。<br><br>var store = Redux.createStore(counter)<br><br>上面这句代码，主要实现的是用createStore方法，创建store，而传入的参数counter我上面已经说过了，是一个reducer，所以store的创建实际上是这样的：var store = createStore(reducer)。<br><br><strong>整个应用，只能有一个store！</strong>可是，reducer却可以有多个，这样问题就来了，由于创建store的时候需要传入reducer，而store只能有一个，但是reducer却可以有多个，那怎么办？<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">]react-redux</a>中又一个管理reducer的方法，叫做<strong>combineReducers</strong>，它能把所有的reducer集中整合为一个reducers，其使用方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reducers = combineReducers(&#123;</div><div class="line">  reducers1,</div><div class="line">  reducers2...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>关于react-redux的具体细节后面再说。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var valueEl = document.getElementById(&apos;value&apos;)</div><div class="line">function render() &#123;</div><div class="line">	valueEl.innerHTML = store.getState().toString()</div><div class="line">&#125;</div><div class="line">render()</div><div class="line">store.subscribe(render)</div></pre></td></tr></table></figure>
<p>这段代码就主要就是执行render函数了，store.getState() 函数，它将会返回state。如果是常规react的render函数的话，是将一个dom节点挂载到root element下面去，而在这个示例中，只要将状态挂载到对应的节点上去就可以了。最后一行代码是注册状态监听器，在这里指当store里面的state发生改变时，触发render回调函数<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&apos;increment&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line">document.getElementById(&apos;decrement&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line">document.getElementById(&apos;incrementIfOdd&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          if (store.getState() % 2 !== 0) &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">document.getElementById(&apos;incrementAsync&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          setTimeout(function () &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;, 1000)</div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<p>这段代码主要是给下面的各个按钮绑定事件，这里需要做的是分发action，通过<strong>store.dispatch(action)</strong>这个方法，把action传递给reducer，而reducer中已经定义好了具体的函数，会根据接收到的action来判断对state进行什么操作。<br><br>好了，第一个示例到此就基本结束了，下面我再好好地整理一下redux的具体流程：<br><br>1，通过createStore方法创建store，传入reducer参数，<strong>且一个应用只能有一个store。</strong>store常用的方法有：getState方法，用来获取state；dispatch方法用来分发action，subscribe方法用来注册监听器执行回调函数。<br><br>2，创建好store后，通过dispatch方法来分发action给reducer，action是一个对象。<br><br>3，reducer接收到了state（state可传可不传，但是要在reducer中写上没有传state时的情况判断），action后，会根据action里的type属性来对state进行对应的操作。<br><br><strong>我描绘一下redux的流程图，大致这样的：const store = createStore(reducer) –&gt; store.dispatch(action) –&gt; reducer(state, action) –&gt; 根据state渲染页面</strong><br><br><br><br><br><br></p>
<p>auther: Wisdommm</p><br><p>date: 2016-07-23</p>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Поиск">
    <input type="hidden" name="q" value="site:wisdommm.github.io">
  </form>
</div>

  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Wisdommm
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>