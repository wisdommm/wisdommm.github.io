<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wisdommm</title>
  <meta name="author" content="Wisdommm">
  
  <meta name="description" content="programmer,front to end">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Wisdommm"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Wisdommm" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Wisdommm</a></h1>
  <h2><a href="/">Welcome to my blog</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-10-10T12:54:51.000Z"><a href="/2016/10/10/promise/">2016-10-10</a></time>
      
      
  
    <h1 class="title"><a href="/2016/10/10/promise/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="promise-详解"><a href="#promise-详解" class="headerlink" title="promise 详解"></a>promise 详解</h2><p>虽然之前写了javascript异步编程，不过我发现周围的部分小伙伴，当然也包括我，对promise的认识还是只停留在基础是使用，类似于ajax这种的使用，或者会用<code>promise.then()</code>，对于原生的Promise对象只了解一点甚至不了解，我也是模模糊糊地了解，所以准备写一篇关于<code>promise</code>的博客，顺便也借此机会一举击破promise，不想再搞得模模糊糊的了，彻底得解决掉这个东西。</p>
<p>在去年，准确的说是在2015年6月（我专门查了的，肯定没有错），ECMAScript6的正式版发布了。ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ES6 的目标，是使得 JavaScript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。</p>
<p>ES6的改变还是算不小的，其中就包含了提供Promise对象。</p>
<p>Promise是什么？首先，它是一个对象，它的作用是用来进行异步操作，代表着某个异步进行的事件的结果。</p>
<p>Promise对象有以下两个特点：</p>
<p>（1），对象的状态不受外界的影线。Promise对象代表一个异步的操作，它包含了三种状态，分别是：Pending（进行中），Resolve（已完成），Reject（已失败）。而异步操作的结果，决定了它将会输出哪一种状态，任何其它操作都无法改变这个状态。这也是Promise名字的由来，也就是承诺的意思，代表一定会去做。</p>
<p>（2），一旦状态改变，就不会再变。虽然Promise不受外界影响状态，不过状态是会在内部进行改变的，它有两种改变状态的可能，一种是从进行中变为已完成（Pending to Resolve），另一种是从进行中变为已失败（Pending to Reject）。除此之外，状态不会再发生其它的变化。</p>
<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><p>“talk is cheap,show me the code”.</p>
<p>这是程序员界比较常见的一句话，上面很多概念啊这些死知识讲解完了，下面才开始进入正题，开始代码演示。</p>
<p>由于Promise已经是JS原生对象了，所以直接打开浏览器的控制台，输入Promise，就可以看到一个function Promise，如果报错的话，说明你的浏览器该升级了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上面的基本代码所示，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject方法，如果异步操作成功了，则调用resolve方法，将Promise对象的状态从Pending改为Resolve，如果异步操作失败，则调用reject方法，将Promise对象的状态从Pending改为Reject。这是promise最基本的使用方法。</p>
<p>promise的神奇之处在于给了我们return和throw，每个promise都会提供一个then函数和一个catch函数，实际上是then(null,…)函数。基本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">promiseOne.then(function(value)&#123;</div><div class="line">  alert(value); // 这个value是promiseOne中resolve传递出来的值。</div><div class="line">  // do something</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个then函数里面，我们可以做三件事，1，return 另一个promise；2，return 一个同步的值；3，throw 一个同步异常，‘ throw new Error(‘’) ’。</p>
<p>下面是一些Promise的基本API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1,Promise.resolve()</div><div class="line">2,Promise.reject()</div><div class="line">3,Promise.prototype.then()</div><div class="line">4,Promise.prototype.catch()</div><div class="line">5,Promise.all([functionOne,functionTwo,...]) // 所有的完成</div><div class="line">6,Promise.race([functionOne,functionTwo,...]) // 竞速，完成一个即可</div></pre></td></tr></table></figure>
<p><code>Promise.resolve</code>和<code>Promise.reject</code>是Promise的静态方法，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(&quot;value&quot;).then(function(v) &#123;</div><div class="line">  console.log(v,1); </div><div class="line">&#125;, function(v) &#123;</div><div class="line">  // 不会被调用</div><div class="line">console.log(v,2);</div><div class="line">&#125;);</div><div class="line">// 这时控制台会输出 value,1</div><div class="line"></div><div class="line">Promise.resolve(&quot;value&quot;).then(function(v) &#123;</div><div class="line">  console.log(v,1); </div><div class="line">&#125;, function(v) &#123;</div><div class="line">  console.log(v,2);</div><div class="line">&#125;);</div><div class="line">// 这时控制台会输出 value,2</div></pre></td></tr></table></figure>
<p>也就是说，Promise.resolve里传入的参数或者promise对象，会被then方法接收，Promise.reject里传入的参数或者promise对象，会被catch方法接收，这一点在上面的<code>new Promise((resolve,reject)=&gt;{if(…){resolve(v)}else{reject(v)}})</code>已经讲过了，意思是一样的，不同之处在于使用的方式不同，下面的方法是直接调用的promise里的静态方法，而没有用到promise这个构造函数。</p>
<p>除了返回基本数据外，一个promise里面也可以返回另一个promise对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var original = Promise.resolve(true);</div><div class="line">var cast = Promise.resolve(original);</div><div class="line">cast.then(function(v) &#123;</div><div class="line">  console.log(v); </div><div class="line">&#125;);</div><div class="line">// 控制台会输出 true</div></pre></td></tr></table></figure>
<p>我们也可以在promise中抛出异常，这里有同步代码异常和异步代码异常两种。</p>
<p>这是同步代码异常，直接调用promise的reject方法，传入一个error就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Promise.reject(new Error(&quot;什么鬼&quot;));</div></pre></td></tr></table></figure>
<p>下面是异步代码异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new Promise(function (resolve, reject) &#123;</div><div class="line">    throw new Error(&apos;悲剧了，又出 bug 了&apos;);</div><div class="line">  &#125;).catch(function(err)&#123;</div><div class="line">    console.log(err);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>如果有多个callback函数连续回调，可以分别写成promise的状态，然后在每一个promise对象中return下一个promise，for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise((resolve,reject)=&gt;&#123;</div><div class="line">  resolve(1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p2 = new Promise((resolve,reject)=&gt;&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p3 = new Promise((resolve,reject)=&gt;&#123;</div><div class="line">  resolve(p2);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p3.then(function(v) &#123;</div><div class="line">  console.log(v); // true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 上面是promise链式调用的一种情况，下面是另一种情况，其核心原因都是差不多的。</div><div class="line"></div><div class="line">var p1 = (resolve,reject)=&gt;&#123;</div><div class="line">  resolve(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p2 = (resolve,reject)=&gt;&#123;</div><div class="line">  resolve(2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p3 = (resolve,reject)=&gt;&#123;</div><div class="line">  resolve(3);</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Promise(p3).then(function(v) &#123;</div><div class="line">  console.log(v); </div><div class="line">  return new Promise(p2).then((v)=&gt;&#123;</div><div class="line">    console.log(v)</div><div class="line">    return new Promise(p1).then((v)=&gt;&#123;</div><div class="line">      console.log(v)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-20T11:49:07.000Z"><a href="/2016/09/20/javascript异步编程（续）/">2016-09-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/20/javascript异步编程（续）/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="javascript异步编程（续）"><a href="#javascript异步编程（续）" class="headerlink" title="javascript异步编程（续）"></a>javascript异步编程（续）</h2><p>之前那篇文章讲解了javascript异步式编程的几个方法，比如有回调函数，promise，发布／订阅模式，generator函数等，每一种方式，在其广泛使用的时期，都是很完善的一种方式，不过由于时代的进步，技术的发展，缺点总会暴露出来，更好更完善的方法也会被创造出来。</p>
<p>这篇文章，我就想来说说<code>async</code>函数。</p>
<p>ES7意见征集稿中提供了<code>async</code>函数，这是什么？其实可以用一句话来概括，<code>async</code>函数就是Generator函数的语法糖。</p>
<p>我们从Generator函数开始，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 这是采用fs模块来异步读取文件</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">var readFile = function (fileName) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">    fs.readFile(fileName, function(error, data) &#123;</div><div class="line">      if (error) reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 这是使用generator函数的方法，依次读取两个文件</div><div class="line">var gen = function* ()&#123;</div><div class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 下面是async函数的写法</div><div class="line">var asyncReadFile = async function ()&#123;</div><div class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实一比较，差异很明显，<code>async</code>函数就是将generator函数的星号替换成了<code>async</code>，将<code>yield</code>替换成了<code>await</code>。</p>
<p>仅此而已！仅此而已？</p>
<p>虽然加入了比较好看的语法糖，不过一个新的方法如果只是比老的方法命名好听，有什么意义呢？下面我来说一下<code>async</code>函数和generator函数的主要区别吧。</p>
<ol>
<li><p>更好的语义。既然都看出来了，那最明显的当然是标志符换了，也就是更加语义化了，<code>await</code>和<code>async</code>比星号跟yield更加让人好理解。</p>
</li>
<li><p>更好的适用性。generator函数的执行必须依靠执行器，或者人为的多次调用next方法才能继续执行下去，而<code>async</code>是自带执行器的，这是什么意思呢？意思就是你再也不用管什么next了，也不用管怎么异步执行了，你完完全全就可以把<code>async</code>函数就当做普通的函数来看来，当你想执行的时候，只需要一句<code>var result = async();</code>就可以了，她会自动调用<code>async</code>函数并且自动执行，输出最后结果，你现在可以将什么next方法啊，co模块这些全部放一边了。</p>
</li>
<li><p>返回值是promise。<code>async</code>函数的返回值是promise对象，这比generator函数的返回一个Iterator对象方便多了，你可以使用promise里的then方法来进行下一步的操作。而<code>async</code>函数完全可以看作是多个异步的操作，包装成了一个promise对象，而await就是then方法的语法糖。</p>
</li>
</ol>
<p>下面是一些<code>async</code>函数的具体使用示例。</p>
<p>1，下面代码中，函数f中return的数据，会被promise的then方法的回调函数获取到，所以then方法回调函数里的参数v就是指代的f函数的return的数据，所以控制台才会打印出hello world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  return &apos;hello world&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f().then(v =&gt; console.log(v))</div><div class="line">// 打开控制台，你就会看见有一句hello world（前提是你的浏览器支持async）</div></pre></td></tr></table></figure>
<p>2，<code>async</code>函数内部抛出错误，会导致返回的promise对象变为reject状态，抛出的错误对象，会被catch方法的回调函数捕捉到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  throw new Error(&apos;出错了&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f().then(</div><div class="line">  v =&gt; console.log(v),</div><div class="line">  e =&gt; console.log(e)</div><div class="line">)</div><div class="line">// Error: 出错了</div></pre></td></tr></table></figure>
<p>3，<code>async</code>函数返回的promise对象，必须要等到内部await命令的promise对象执行完，才会发生状态的改变，换句话说，也就是<code>async</code>函数内部的await命令执行完了，才会执行then方法的回调函数。如下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">async function getTitle(url) &#123;</div><div class="line">  let response = await fetch(url);</div><div class="line">  let html = await response.text();</div><div class="line">  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];</div><div class="line">&#125;</div><div class="line">getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log)</div><div class="line">// &quot;ECMAScript 2017 Language Specification&quot;</div></pre></td></tr></table></figure>
<p>4，在正常情况下，await后面应该是一个promise对象，如果不是，那么会被转变为一个立即resolve的promise对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  return await 123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f().then(v =&gt; console.log(v))</div><div class="line">// 123，这里await后面的123虽然不是promise对象，不过它会转变为promise对象并立即被resolve，所以在后面的then方法的回调函数里，依然可以正常的运行。</div></pre></td></tr></table></figure>
<p>5，<code>async</code>函数返回的promise对象，如果变为了reject状态，则reject的参数会被catch方法的回调函数接收到，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  await Promise.reject(&apos;出错了&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; console.log(v))</div><div class="line">.catch(e =&gt; console.log(e))</div><div class="line">// 出错了。上面的await前面没有return语句，但是reject状态的参数依然传入了catch方法的回调函数里，所以说这里有没有return都是不影响的，不过为了统一与规范，还是建议加上。</div></pre></td></tr></table></figure>
<p>6，只有程序发现了一个promise函数的状态变为了reject，那么后面的代码将不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  await Promise.reject(&apos;出错了&apos;);</div><div class="line">  await Promise.resolve(&apos;hello world&apos;); // 这句将不会执行</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 所以为了避免这种情况发生，可以将第一个await放在try...catch...语句中，这样代码的执行就不会被中断。</div><div class="line"></div><div class="line">async function f() &#123;</div><div class="line">  try &#123;</div><div class="line">    await Promise.reject(&apos;出错了&apos;);</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">  &#125;</div><div class="line">  return await Promise.resolve(&apos;hello world&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; console.log(v))</div><div class="line">// hello world</div><div class="line"></div><div class="line">// 另一种解决办法就是在await后面的promise对象加上一个catch方法，来处理前面可能会出现的错误，代码如下。</div><div class="line"></div><div class="line">async function f() &#123;</div><div class="line">  await Promise.reject(&apos;出错了&apos;)</div><div class="line">    .catch(e =&gt; console.log(e));</div><div class="line">  return await Promise.resolve(&apos;hello world&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; console.log(v))</div><div class="line">// 出错了</div><div class="line">// hello world</div><div class="line"></div><div class="line">// 当然，我们也可以将多个await命令放进catch方法里，这段代码就省略了。。。</div></pre></td></tr></table></figure>
<p>7，如果await后面的异步操作出错，那么就等同于promise对象状态变为reject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  await new Promise(function (resolve, reject) &#123;</div><div class="line">    throw new Error(&apos;出错了&apos;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; console.log(v))</div><div class="line">.catch(e =&gt; console.log(e))</div><div class="line">// Error：出错了</div></pre></td></tr></table></figure>
<p>上面说了那么多的示例，都是比较片面的讲解使用中的注意事项，完整的示例来讲解<code>async</code>函数的使用方法，所以我下面会主要讲<code>async</code>函数的使用。</p>
<p>1，上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async function getStockPriceByName(name) &#123;</div><div class="line">  var symbol = await getStockSymbol(name);</div><div class="line">  var stockPrice = await getStockPrice(symbol);</div><div class="line">  return stockPrice;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getStockPriceByName(&apos;goog&apos;).then(function (result) &#123;</div><div class="line">  console.log(result);</div><div class="line">&#125;);</div><div class="line">// 最后打印出的这个result就是getStockPriceByName函数中return的stockPrice。</div></pre></td></tr></table></figure>
<p>2，下面代码指定50毫秒以后，输出”hello world”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function timeout(ms) &#123;</div><div class="line">  return new Promise((resolve) =&gt; &#123;</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async function asyncPrint(value, ms) &#123;</div><div class="line">  await timeout(ms);</div><div class="line">  console.log(value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">asyncPrint(&apos;hello world&apos;, 50);</div></pre></td></tr></table></figure>
<p>十一国庆节来公司基本没人，后背也感到一阵阵凉风，这篇博客就先讲到这里吧，有什么完善的地方后面我会再继续补充的。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-09T12:29:36.000Z"><a href="/2016/09/09/javascript异步编程/">2016-09-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/09/javascript异步编程/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="javascript异步编程"><a href="#javascript异步编程" class="headerlink" title="javascript异步编程"></a>javascript异步编程</h2><p>最近nodejs看得有点多，感觉满脑子都是文件处理，异步编程，buffer等，发现学node学多了，前端用到的javascript也会更加豁然开朗，特别是廖雪峰和阮一峰老师的博客，给了我不小的帮助。我想从nodejs开始说起，毕竟这才是编程的核心，现在发现前端用的js只是熟练运用onclick事件等，自己以前还是只接触到了皮毛啊。</p>
<p>回到主题，据传当初Ryan Dahl选择js来作为后台语言时，主要就是看重了js的单线程，同步运行，适合一些高并发的场景，这就从侧面说明了js这门语言的特性：同步，单线程。那么可以多线程异步编程吗？答案当然是肯定，那么，js异步编程有哪几种方法，这几种方法各自的优缺点又如何呢？</p>
<p>说到这里，我又想解释一下同步与异步，第一次听到这两个词语，就要得追溯到大学的操作系统课堂了，OS的运行机制（运行模式）分为<strong>同步（Synchronous）</strong>和<strong>异步（Asynchronous）</strong>。</p>
<p>“同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。”异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</p>
<p>所以针对js的异步编程方法，我准备讲解如下几个方法：</p>
<p>一，回调函数</p>
<p>这是异步编程最最最基本的方法，几乎所有能异步编程的语言都可以用到这个方法。<br><br>回调函数的具体意思是，假设有两个函数，a和b，函数a在前b在后，正常情况的话，程序运行到了函数a，会等待其执行完毕，然后拿到函数a的运行结果，才会继续执行函数b；那么这时，问题就来了，如果函数a运行一秒，我可以等，运行十秒，就难以忍受了，万一函数a卡住了，永远成功不了，你会等到海枯石烂吗？哈哈哈，那怎么办，我下面还有千千万万行的代码啊，辛辛苦苦写了那么久，还没运行到这里，就结束了，逗我啊。。。这个时候，就该回调函数上场了，把函数b写成函数a的回调函数，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 原来的代码</div><div class="line"></div><div class="line">a();</div><div class="line">b();</div><div class="line"></div><div class="line">// 采用回调函数</div><div class="line"></div><div class="line">function a(b)&#123;</div><div class="line">	setTimeout(function()&#123;</div><div class="line">		// a的代码</div><div class="line"></div><div class="line">		b()</div><div class="line">	&#125;,1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用这种方式，我们把同步操作变成了异步操作，a不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p>
<p>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<p>那么问题就来了，学。。。不对，这会产生什么问题？如果回调函数比较多会怎样？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 在前一个动画执行完成后，紧接着执行下一个动画</div><div class="line">$(&apos;xx&apos;).animate(&#123;xxxx&#125;, function()&#123;</div><div class="line">    $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123;    </div><div class="line">    	$(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123;    </div><div class="line">    		$(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123;    </div><div class="line">    			$(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123;    </div><div class="line">    				...</div><div class="line">    			&#125;,1000)</div><div class="line">    		&#125;,1000)</div><div class="line">    	&#125;,1000)</div><div class="line">    &#125;,1000)</div><div class="line">&#125;,1000)</div></pre></td></tr></table></figure>
<p>是不是觉得很傻，代码毫无可读性而言，不过，这是最基本的js异步编程的方法。</p>
<p>二、promise</p>
<p>有了最基本的方法，就会有很多人不满足，想做出优化，写个第三方库啊或者发各种包，各种模块什么的。</p>
<p>最有名的，莫过于promise了，做为前端，大名鼎鼎的jQuery肯定不会不知道吧，说起jQuery，要说的就太多了，赶紧收住。jQuery里的ajax方法，就是典型的参照了promise设计出来的产物，其使用方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">// 配置参数</div><div class="line">&#125;).done(function(retData) &#123;</div><div class="line">...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一套典型的jQuery版的ajax应用方法，后面的done，就是指的前面做完了，返回一个结果retData来，然后再执行其它操作。</p>
<p>在es6中，已经正式出台了promise对象，其基本用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a()</div><div class="line">.then(b)</div><div class="line">.then(c)...</div></pre></td></tr></table></figure>
<p>是不是一下子就简洁了很多？当然，这个也不能说是完美的异步编程解决方案，只能说是完善罢了，其优点确实是简化了不少代码，不过也有不足的地方，那就是维护比较麻烦，因为这样的话，异步多了，你一眼看过去，将会看到一堆的then。。。是不是很尴尬啊，代码的可读性一下子就降低了，你满脑子的then。</p>
<p>三、观察者模式</p>
<p>说起这个，又要回到大学的操作系统课堂了，算了，不浪费时间了，直接进入正题。</p>
<p>观察者模式，你可以理解为，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。</p>
<p>这个方式的实现有很多的插件，就拿我们最熟的jQuery来说好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 函数b订阅done信号</div><div class="line">jQuery.subscribe(&quot;done&quot;, b);</div><div class="line">function a()&#123;</div><div class="line">　　　　setTimeout(function () &#123;</div><div class="line">　　　　　　// a的任务代码</div><div class="line">　　　　　　// a执行完毕后，发布done信号，然后b接收到了done信号，就开始执行b函数</div><div class="line">　　　　　　jQuery.publish(&quot;done&quot;);</div><div class="line">　　　　&#125;, 1000);</div><div class="line">　　&#125;</div><div class="line">　　// 当然，你也可以取消订阅信号的事件，这样的话，以后done信号发布，b函数就不会执行了。</div><div class="line">　　// jQuery.unsubscribe(&quot;done&quot;, f2);</div></pre></td></tr></table></figure>
<p>这个也有一点可以优化的地方，就是发布和订阅的消息太多时，不好管理，事件会太杂乱，有一个整体管理事件的中心就更好了。</p>
<p>四、generator</p>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。其核心意思就是，一段代码执行到某个节点时，暂停执行，然后执行另一段代码，有等了会，再回过头来执行第一段代码剩下的部分，总的来说就是几个代码片段交替执行。</p>
<p>说到这里我觉得现现在generator函数并没有被广泛的大面积的运用，所以先花点时间来介绍下generator函数吧。talk is cheap，show u the code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next()   // &#123; value: 3, done: false &#125;</div><div class="line">g.next()   // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，调用generator函数，会返回一个内部指针（也叫遍历器），就是这里的g，所以说当你直接调用generator函数的时候，它并不会直接返回结果，而里面的yield字段，就表示异步操作需要暂停的地方，通过g指针调用next方法，指针就会开始异动到下一个yield（或者return）的地方去，并且返回当时暂停时所得到的结果value,以及遍历状态done。</p>
<p>下面来看看如何使用generator函数来执行一个真实的异步任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fetch = require(&apos;node-fetch&apos;);</div><div class="line">function* gen()&#123;</div><div class="line">  var url = &apos;https://api.github.com/users/github&apos;;</div><div class="line">  var result = yield fetch(url);</div><div class="line">  console.log(result.bio);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们通过发送请求，然后输出请求返回的结果，去掉yield命令，就完完全全是同步的了，所以这也是yield的一个比较大的特点，对代码改动小，保持代码可读性。。。话说回来，现在声明了这个函数，如何使用呢？使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var g = gen();</div><div class="line">var result = g.next();</div><div class="line">result.value.then(function(data)&#123;</div><div class="line">  return data.json();</div><div class="line">&#125;).then(function(data)&#123;</div><div class="line">  g.next(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<p>发现已经写了好多了，看来一次性写完确实太累啊，留下一个acync函数下次再写吧。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-05T09:24:12.000Z"><a href="/2016/09/05/vue.js 组件入门（一）/">2016-09-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/05/vue.js 组件入门（一）/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="vue-js-组件快速入门（一）"><a href="#vue-js-组件快速入门（一）" class="headerlink" title="vue.js 组件快速入门（一）"></a>vue.js 组件快速入门（一）</h2><p>前几天读了一篇好文章，<a href="http://www.cnblogs.com/keepfool/p/5625583.html" target="_blank" rel="external">vue组件化</a>，这篇算是我自己提炼出来的的归纳与总结吧。</p>
<p>在前端开发中，以前我们会把常用的公共的方法（函数）提取出来，整合为一个库，最有名的当属jQ了吧，然后到了react出现，这些类库主要都是针对view层进行的操作与封装，我们又可以把view层面上的一些东西抽出来进行封装和整理，比如一个table，一个button，一个div等，也可以像曾经提取函数一样抽出来，写成公用的，在需要使用的地方直接引入就可以了，当然，也可以根据你实际运用的需要进行适当的自定义配置，而这些被抽出来共用的table，button，div这些，就叫做组件。</p>
<p>上面是我自己瞎扯的，原文作者讲得比较繁琐，所以我就用自己的语言来概述了一下，虽然这篇文章是我转载的，不过我也参考了其它的文章／博客，知识点的相似度接近80%，但是语言基本上都是我自己重新组织的，所以加了很多自己的想法和思考，下面我们开始进入正题。</p>
<h1 id="vue组件，创建与注册的基本步骤。"><a href="#vue组件，创建与注册的基本步骤。" class="headerlink" title="vue组件，创建与注册的基本步骤。"></a>vue组件，创建与注册的基本步骤。</h1><p>vue组件的使用，有三个步骤，分别是创建组件，注册组件和使用组件，如下图所示。<br><img src="http://oatasl78l.bkt.clouddn.com/vue1.png" alt=""></p>
<p>我们可以用一段代码来演示这三个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;div id=&quot;app&quot;&gt;</div><div class="line">            &lt;!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件--&gt;</div><div class="line">            &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">    </div><div class="line">        // 1.创建一个组件构造器</div><div class="line">        var myComponent = Vue.extend(&#123;</div><div class="line">            template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos;</div><div class="line">        &#125;)</div><div class="line">        </div><div class="line">        // 2.注册组件，并指定组件的标签，组件的HTML标签为&lt;my-component&gt;</div><div class="line">        Vue.component(&apos;my-component&apos;, myComponent)</div><div class="line">        </div><div class="line">        new Vue(&#123;</div><div class="line">            el: &apos;#app&apos;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>运行结果很简单，就是一句“This is my first component!”，可以看到，使用组件和使用普通的HTML元素没什么区别，你可以就把组件当做一个HTML元素来使用。</p>
<p>要理解组件的创建和注册，我们可以用一下几个步骤来详细解释：</p>
<ol>
<li>Vue.extend()是Vue构造器的扩展，调用Vue.extend()创建的是一个组件构造器，而不是一个具体的组件实例。</li>
<li>Vue.extend()构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的HTML。 </li>
<li>使用Vue.component()注册组件时，需要提供2个参数，第1个参数时组件的标签，第2个参数是组件构造器。 </li>
<li>Vue.component()方法内部会调用组件构造器，创建一个组件实例。 </li>
<li>组件应该挂载到某个Vue实例下，否则它不会生效。</li>
</ol>
<p>我们一句一句来分析，先是创建一个组件，代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myComponent = Vue.extend(&#123;</div><div class="line">	template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>创建组件很简单，直接调用vue构造器的扩展方法就行了，里面会传入一个对象，对象里面有个template属性，它指代的是这个组件的view的内容，是不是像react里面的render函数啊，它也是return的view内容，<strong>它们有哪些不同呢？</strong>毕竟学习知识要针对各种不同的但是有类似的知识点来进行归纳，整理和综合，才能进行融会贯通的运用。毕竟古人云：学而时习之，不亦悦乎！<br><br>好了，这是创建，下面是注册了，注册也很简单，一句代码就搞定了：Vue.component(‘my-component’, myComponent);，使用Vue.component方法，传入两个参数，第一个参数是你想注册的组件名，第二个参数是你创建的组件名，是不是有点混淆？先是你通过Vue.extend创建了一个组件，名字叫myComponent，然后为了在HTML中能够当做标签来使用，你需要给你创建的这个组件注册一个组件名，名字叫做my-component，所以你在HTML就可以直接把你注册的组件名当做HTML标签来使用，像这样<my-component></my-component>就可以了。<br><br>现在组件创建好了，也注册好了，可是还不能直接使用，因为还需要new一个Vue实例，才能使用，像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue(&#123;</div><div class="line">    el: &apos;#app&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一个Vue实例接收一个对象，里面的el属性是你组件的挂载节点，于是我又情不自禁地联想到了react，ReactDOM.render( dom , root)，就像这样，react也是将一个view界面的虚拟dom挂载到一个root节点上，而这里的Vue同样，需要将刚才的组件也挂载到某个节点下，这两者之间的异同后面再说吧，先说一点主要的，vue里的节点指的是vue组件的作用域，这点是和react差异比较大的一点，你将vue组件挂载在了某个节点下，意思是这个组件只有在这个节点范围内才可以使用，至于是使用多次，使用一次，还是一次都不使用，都没问题。而我们这个实例上，就是挂载在了id为app的节点上，所以在这个节点的范围内都可以使用<my-component></my-component>的形式，来调用vue组件myComponent。同理，如果你想在多个节点的作用域内使用某个vue组件的话，那你就得多new几次，把组件的挂载到多个节点下面就好了，而如果在没有实例化的组件中非法调用某个vue组件，它将不起任何作用。<br>详细情况可以看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;div id=&quot;app1&quot;&gt;</div><div class="line">            &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div id=&quot;app2&quot;&gt;</div><div class="line">            &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div id=&quot;app3&quot;&gt;</div><div class="line">	        &lt;!--该组件不会被渲染--&gt;</div><div class="line">	        &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">	    &lt;/div&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        var myComponent = Vue.extend(&#123;</div><div class="line">            template: &apos;&lt;div&gt;This is a component!&lt;/div&gt;&apos;</div><div class="line">        &#125;)</div><div class="line">        </div><div class="line">        Vue.component(&apos;my-component&apos;, myComponent)</div><div class="line">        </div><div class="line">        var app1 = new Vue(&#123;</div><div class="line">            el: &apos;#app1&apos;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        var app2 = new Vue(&#123;</div><div class="line">            el: &apos;#app2&apos;</div><div class="line">        &#125;)</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>在上面代码中，我们创建了一个名叫myComponent的vue组件，然后注册了一个名叫my-component的组件来当做HTML标签使用，最后我们实例化时，只在id=”app1”和id=”app2”中挂载了这个vue组件，而在实际使用的时候，我们在id=”app3”中也使用了这个<my-component></my-component>组件，所以最后，只有id=”app1”和id=”app2”的div中组件成功地被替换成了“This is a component!”，而id=”app3”中的<my-component></my-component>标签将不会被渲染。具体效果如下图所示：<br><img src="http://oatasl78l.bkt.clouddn.com/vue2.png" alt=""></p>
<p>好了，一个基本的vue组件的一整套流程基本就完全是这样了，any problems else？我知道，现在还有很多的问题没有解决，比如创建组件，注册组件和实例化挂载到某个节点下，整体步骤比较繁琐；注册组件的时候可以局部注册吗；组件可以嵌套吗？如果可以，如何嵌套；vue组件怎么怎么做成可扩展的？又怎样变为自定义配置呢？</p>
<p>我下一篇博客再细细道来。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-03T08:25:56.000Z"><a href="/2016/09/03/node express实现/">2016-09-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/03/node express实现/"></a></h1>
  

    </header>
    <div class="entry">
      
        <hr>
<h2 id="express实现"><a href="#express实现" class="headerlink" title="express实现"></a>express实现</h2><p>express是node里面一个十分常用的库，用它来搭建服务器，事半功倍，且小巧灵活，有足够多的特性，用来进行各种网页开发。</p>
<p>我们先来看下express的使用的，毕竟知己知彼，百战不殆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//引入express，确保你的项目依赖了express库，否则的话先npm install一下</div><div class="line">var express = require(&apos;express&apos;);</div><div class="line">//执行express函数，</div><div class="line">var app = express();</div><div class="line">// 使用get方法，当请求的路由是hello时，返回hello</div><div class="line">app.get(&apos;/hello&apos;, function (req, res) &#123;</div><div class="line">  res.send(&apos;hello&apos;);</div><div class="line">&#125;);</div><div class="line">// 当请求的路由是world时，返回world</div><div class="line">app.get(&apos;/world&apos;, function (req, res) &#123;</div><div class="line">  res.send(&apos;world&apos;);</div><div class="line">&#125;);</div><div class="line">// 当请求的路由是其它时，返回“没有找到匹配的路径”</div><div class="line">app.get(&apos;*&apos;, function (req, res) &#123;</div><div class="line">	res.setHeader(&apos;content-type&apos;,&apos;text/plain;charset=utf8&apos;);</div><div class="line">	res.end(&apos;没有找到匹配的路径&apos;);</div><div class="line">&#125;);</div><div class="line">// 最后监听端口</div><div class="line">var server = app.listen(3000, function () &#123;</div><div class="line">  console.log(&apos;正在监听3000端口&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面或许就是express最常见，也是最基本的使用吧，启动了一个服务器并且监听3000端口，对/hello的路由返回“hello”，对/world的路由返回“world”，对其他的路由返回“没有找到匹配的路径”。</p>
<p>示例看完了，下面我们来看看具体的实现吧，在这之前，我想说一下http这个模块，毕竟express就是对http进行了一下封装，既然想看看express的内部，当然就离不开http了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">  response.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</div><div class="line">console.log(&apos;正在监听3000端口。&apos;);</div></pre></td></tr></table></figure>
<p>就上面这几行，就已经成功地实现了一个简单的服务器了，我们可以分拆一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.createServer(function(...)&#123;...&#125;).listen(3000);</div></pre></td></tr></table></figure></p>
<p>现在，我们再回过头来看看express。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 首先，声明express函数</div><div class="line">var express = function () &#123;&#125;;</div><div class="line">// 它的内部应该有一个app函数，用来作为实例。</div><div class="line">var express = function () &#123;</div><div class="line">	var app = function(...)&#123;...&#125;</div><div class="line">&#125;;</div><div class="line">// 这个实例还应该有很多的方法，比如get，listen等。（本来我是想用es5的方式写的，后来发现好久没用那种方法，写function写得太累了。。。）</div><div class="line">var express = ()=&gt; &#123;</div><div class="line">	var app = (req,res)=&gt;&#123;...&#125;;</div><div class="line">	app.listen = (...)=&gt;&#123;...&#125;;</div><div class="line">	app.get = (...)=&gt;&#123;...&#125;;</div><div class="line">&#125;;</div><div class="line">// 最后，为了能够完成链式调用，所以我们返回这个实例app，然后exports一下，就完成了。</div><div class="line">var express = ()=&gt; &#123;</div><div class="line">	var app = (...)=&gt;&#123;...&#125;;</div><div class="line">	app.listen = (...)=&gt;&#123;...&#125;;</div><div class="line">	app.get = (...)=&gt;&#123;...&#125;;</div><div class="line">	return app;</div><div class="line">&#125;;</div><div class="line">module.exports = exports = express;</div></pre></td></tr></table></figure>
<p>这就是express基本的框架，如果后续有什么扩展的，也可以直接在里面增加一个函数就好了，<figure class="highlight plain"><figcaption><span>= (...)=>&#123;...&#125; ```，接下来，我们来慢慢分析里面的构造。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">先看一个最简单的吧，listen方法。</div></pre></td></tr></table></figure></p>
<p>app.listen = function (port) {<br>    require(‘http’).createServer(app).listen(port);<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">是不是发现了什么？再上去看一眼http，是不是很相似啊。。。没错，就是这样的。</div></pre></td></tr></table></figure></p>
<p>http.createServer(function(…){…}).listen(3000);<br>```</p>
<p>而中间的app函数，对应的就是http.createServer的参数了。<br>感觉这个listen函数应该不需要多讲。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-21T09:03:14.000Z"><a href="/2016/08/21/vue todo/">2016-08-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/21/vue todo/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="vue-todo示例"><a href="#vue-todo示例" class="headerlink" title="vue todo示例"></a>vue todo示例</h1><p>最近抽空看了下vue，一个轻量级的前端框架（类库），它采用的mvvm模式，且数据双向绑定，刚好官方网站上有一个todo实例，我感觉和redux的todo实例很类似，所以准备将这两个框架的todo实例分别解读一下，来比较一下个中异同。</p>
<p>这个代码就两部分，先是html：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;li v-for=&quot;todo in todos&quot;&gt;</div><div class="line">      &lt;span&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</div><div class="line">      &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>接下来是js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    newTodo: &apos;&apos;,</div><div class="line">    todos: [</div><div class="line">      &#123; text: &apos;Add some todos&apos; &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    addTodo: function () &#123;</div><div class="line">      var text = this.newTodo.trim()</div><div class="line">      if (text) &#123;</div><div class="line">        this.todos.push(&#123; text: text &#125;)</div><div class="line">        this.newTodo = &apos;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    removeTodo: function (index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我第一次看到这段代码的时候觉得有点诧异，就这么点代码就实现了一个todo list，比react少了好多，如果是redux的todo list，别说代码，文件夹数量就可以让你一双手数不过来，而这vue两个文件夹一共才这么点代码，下面来仔细看看这个代码吧。<br>先看下html代码吧，除了原生的html代码外，这里有几个vue特有的属性，显而易见，所有以<strong>v</strong>开头的属性，都是vue特有的属性，比如这里的v-model=”newTodo”，v-on:keyup.enter=”addTodo”，v-for=”todo in todos”，v-on:click=”removeTodo($index)”，一共就这四个吧，而就是字符串模版了，从js文件的某个对象中获取数据来填充到页面上。<br>js代码也很少，估计一共才十多行，抛去中间的内容不看，就成了new Vue({})了，很显然这就是new了一个Vue实例，算是初始化，然后我们再来对内容一行一行地解读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">el: &apos;#app&apos;</div></pre></td></tr></table></figure>
<p>先看一下app在html文件里指代的是什么，一看便知，app在这里指代的是最外层div的id，而这里的＃应该类似于jQuery选择器中的符号吧（所以我猜测这里也可以用“.app”来选择class为app的元素来作为Vue的容器），前面的el应该指的是element吧。<br>再看下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">    newTodo: &apos;&apos;,</div><div class="line">    todos: [</div><div class="line">      &#123; text: &apos;Add some todos&apos; &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个data很明显说明了这里面装的是数据，我们可以看到这里一共有两条数据，一条是newTodo的数据，类型是字符串，另一条是todos数据，类型是数组对象，然后我们现在再返回html中，查看那里用到了这两条数据的，可以看到<strong>v-model=”newTodo”</strong>，所以我们暂时可以知道具有v-model属性的这个input输入框和newTodo这条数据绑定了起来，至于是单向绑定还是双向绑定还是仅仅是初始化的时候绑定一次，我们现在还不知道，接着看下面的todos，<strong>v-for=”todo in todos”</strong>，可以明白的知道，这是个for遍历，类似于for(i in object)一样，而这里的意思就类似于在todos这个数组中遍历一下，然后在li标签内对遍历到的数据进行操作，下面就用到了字符串模版，将需要的数据提取出来就好了。<br>继续往下面看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">methods: &#123;</div><div class="line">    addTodo: function () &#123;</div><div class="line">      var text = this.newTodo.trim()</div><div class="line">      if (text) &#123;</div><div class="line">        this.todos.push(&#123; text: text &#125;)</div><div class="line">        this.newTodo = &apos;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    removeTodo: function (index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分是methods，按照字面意思来看，叫做方法，也就是js中的函数（function），可以看到里面一共包含了两个function，一个是addTodo，另一个是removeTodo，回顾html文件，可以知道调用这两个函数方法的地方分别是<strong>v-on:keyup.enter</strong>和<strong>v-on:click</strong>，前一个就是类似于原生的onKeyup方法，而第二个就是onClick了，不过keyup后面跟了enter，说明这个keyup方法是和enter健绑定的，现在我们可以进入这两个函数内部看看，看它具体的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">addTodo: function () &#123;</div><div class="line">      var text = this.newTodo.trim()</div><div class="line">      if (text) &#123;</div><div class="line">        this.todos.push(&#123; text: text &#125;)</div><div class="line">        this.newTodo = &apos;&apos;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数中主要是在针对this.newTodo进行操作，我们不难发现，newTodo这条数据是和v-model这个属性绑在一起的，然后这个属性又是和input输入框绑定在一起的，所以可以表明这里的this.newTodo指的就是input输入框里的值，然后再将其去除首尾空格，push进todos列表，最后再清空输入框。<br>而我们再来看下另一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">removeTodo: function (index) &#123;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数更简单，就一句话，执行一个数组操作，删除数组的某一项，而这个函数的调用在这里：v-on:click=”removeTodo($index)”，可以看到在调用的时候传入了一个参数$index，这指的是对应的li标签的index，然后当点击的时候，就可以通过index来删除这个li标签了。</p>
<p>说了这么多，我知道，理工科的东西讲再多的道理都是十分抽象的，所以最后我还是上几张图吧，为了能够更好的理解。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%201.png" alt=""><br>图1<br>这是初始化的时候，一切都为空。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%202.png" alt=""><br>图2<br>然后我在输入框里输入数据，按下enter键。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%203.png" alt=""><br>图3<br>可以看到，下面列表中多了一条数据，是我刚才输入的数据。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%204.png" alt=""><br>图4<br>然后我又输入了几条数据，一共三条。</p>
<p><img src="http://oatasl78l.bkt.clouddn.com/vue%205.png" alt=""><br>图5<br>最后我删除其中一条，就删除第二条吧，点击右边的那个小叉就可以了，可以看到这条就被删了，其他的数据不变。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-19T13:42:59.000Z"><a href="/2016/08/19/hexo-search/">2016-08-19</a></time>
      
      
  
    <h1 class="title"><a href="/2016/08/19/hexo-search/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="hexo博客增加搜索功能"><a href="#hexo博客增加搜索功能" class="headerlink" title="hexo博客增加搜索功能"></a>hexo博客增加搜索功能</h1><p>最近在用在某个项目上增加一个搜索框，后端用node＋mongodb实现，本来以为挺简单的，就用node爬一下页面title和href，然后放进mongodb中，再通过前端发请求传数据过来查找，然后node再在mongodb中查找，将数据返回前端。</p>
<p>这是理想情况下的做法，可是现实往往充满了曲折,下面我来简单介绍下这个项目，然后说一下问题吧。</p>
<ol>
<li>这是个内网项目，所以爬虫爬不进去，好在有一个目录页，将所有页面的title和href整理了起来，不过读取这个文件也不是简单的事，因为这个是类似于json格式的文件，但是却没有任何的符号，全是汉字，而我们存储的时候是需要分层次的，这样利于查找，采用node的FS模块可以很容易地读取到文件的内容，但是仅仅是读取，直接存储的话会导致没有层次感，所以我就把这个文件复制了一份出来，通过人工维护的方式将其变为json格式，然后就很好操作了，不过需要人工维护与更新，不算是最好的办法，但是那个文件之前也是人工维护的（虽然我不知道是谁维护，否则可以叫他一起维护下）。</li>
<li>这是个hexo博客系统，纯静态展示的，所有页面均是通过通过hexo的框架，执行hexo g命令的时候，会自动将md文件解析成html（css），然后再通过执行hexo server命令，开一个hexo的服务器，把所有的页面通过服务端渲染到浏览器；因此，我增加的这个搜索框的功能，除了需要自己写服务器和数据库外，还必须把这个项目单独部署，因为hexo的源码上并没有针对服务器的扩展方法（这一点是@南烛帮我一起看的，毕竟我之前对hexo的了解只是会用而已，并没有在它的源码上进行深入研究），因此，这就成为了两个项目，然后把这两个项目部署在同一台服务器上，再通过配置nginx服务，将搜索框从前端发来的请求映射到node服务器监听的那个端口，这样就形成了前后端数据的交互，这里出现了一个比较奇怪的问题，我在我自己电脑上发送请求时，请求能够成功发出去，可就是接收不到返回的内容，然后我从另一台电脑通过花瓶代理请求到我本地来测试接口，却发现是正常的，最后发现是两个项目之间的请求跨域了。</li>
<li>解决跨域，可以选择将项目部署在服务器，然后再测试，不过这就比较麻烦了，修改bug比较蛋疼，或者使用代理，将请求代理到另一个域来，这样修改bug也比较简单，现在开始发请求了，发现查找结果是没有数据，没关系，我刚刚只是随便输入的一个词，现在我输入一个数据库里存在的词重新发送请求，不过问题就出来了，还是没有数据，怎么可能啊，数据库里确实有这个数据啊，怎么会查不到，于是我换了几个数据库里存在的词，再反复查找，结果大多都是不存在，唯一存在的一个是一个英文单词，然后我就查看请求，发现地址没错，参数呢？参数怎么自动给我转码了，我就好奇了，然后我再去后台将这个获取到的请求参数，对比了一下接收到各种参数的情况，发现汉字会自动转码，数字和英文单词会保持不变，但是当查询的字符串中间出现空格的时候，会自动变为加号来填充空格，所以，只有无空格的数字或英语字母才可以直接查找到结果，否则的话都需要人工再进行一次转码，将其转过来，唉，毕竟第一次写服务器，这些都需要靠自己独自摸索。</li>
<li>接下来是mongodb的事情。之前使用百度搜索还是谷歌搜索，我都没发现什么大的问题（可能是我搜索的问题太傻了），这次查询mongodb和mongoose的相关资料，发现百度搜索出来的都是以一些博客，百度知道的回答为主，且各个博客之间相互抄袭也是够无聊的，仅仅只是做到了制造而不是创造。然后我就去谷歌采用英文搜索，stackoverflow，官方网站等都是排在很前面的（不知道百度为什么把人家官网排在很后面），算了，不吐槽了。mongodb这种非关系型轻量级数据库，使用起来是很方便的，增删查改的api都是比较简单的，根据所示范的例子动手稍微写一下就会用了，不过对于第一次使用的我来说，还是遇到了一些问题：存储的时候，mongodb会自动给你加上下划线id，我估计是为了区分存储空间，可是这就会存在一个问题，当我存储了一条数据过后，再储存一条相同的数据进去，是可以存储进去的，因为它们的下划线id不同，这显然不对啊，我否则我一查找，却找到很多条数据，仔细一看却发现这么多条数据都是一样的，不是很搞笑吗，所以我选择了给每条数据加上一个index作为唯一标志符，然后再在每次启动的时候，去读取文件存储进数据库里，存进去之前会先去数据库里通过这个index唯一标志符查找一遍，如果查询结果为空，我才会把这条数据存进去，否则就不存。其实吧，每次存储的时候会人为的自动查找，相当于遍历了一遍数据库，如果是在正常的稍微大一点的项目来说，这是十分十分十分影响性能的，由于我这里是个很小的项目，所以才可以进行这种方式查询；其次是mongo查找的时候，默认的方式是精确匹配，不支持模糊查询，这怎么办呢，难道需要我在查询的时候再遍历一遍数据库，使用indexOf来查询？我感到很可笑，因为你这么傻的方法在实际中是肯定行不通的，再说了，就算可以，那么大小写的模糊查询怎么办？难道要我判断下有没有英文字母然后分别用用大写和小写都来遍历一下？这个时候就可以使用正则了，将查询的字符串改变为正则表达式，这样的话在数据库里它会自动的去匹配所有适合的结果。</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-28T06:33:08.000Z"><a href="/2016/07/28/react demo/">2016-07-28</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/28/react demo/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="redux-example"><a href="#redux-example" class="headerlink" title="redux example"></a>redux example</h2><p>最近在做店铺装修，很很很麻烦的一个项目，刚好里面用到了redux，我发现店铺装修简化一下的话，简直是redux的十分好的一个示例啊，比官网上简单的示例要难，又比难的简单，而且条理结构什么的又很清楚，挺不错的啊。</p>
<p>我先上图吧。<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex1.png" alt=""><br>图1<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex2.png" alt=""><br>图2<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex3.png" alt=""><br>图3<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex4.png" alt=""><br>图4<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex5.png" alt=""><br>图5<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex6.png" alt=""><br>图6<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex7.png" alt=""><br>图7<br><img src="http://oatasl78l.bkt.clouddn.com/redux%20ex8.png" alt=""><br>图8<br><br>好吧，这图截的也是够大的，将就看看吧。。。由图1可以看到，页面一共分为四部分：左，中上，中下，右，也就是氛围四个组件：Left，Top，Center，Right。接下来我说一下交互，如图2所示；我在左边的输入框中输入东西，然后点击增加，可以看到，刚刚新增的数据立马在右边下面部分显示了出来，展示的是刚才新增的数据和一个删除按钮，如图3所示；若你点击展示的数据，那么在右边，也就是编辑组件中会出现一个输入框和编辑按钮，你可以在这里对刚刚点击的数据进行修改然后保存，如图4，图5所示；保存过后就可以看到中间的显示模块对数据进行了更新，如图6所示；接下来是中间上方的保存模块，你点击保存按钮，这个模块同样也能取到当前的数据，这里就用一个弹窗代替好了，如图7所示；最后就是删除按钮，点击后删掉当前这一行的数据，如图8所示。<br><br>好累，说了这么多，口都干了。其实吧，一两句话就可以说完的：在这四个组件中，每个组件都可以取到state，并且可以对state进行操作。说完了，是不是很简单啊。。。<br><br>我们先来看看index.js吧，也就是入口文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var App = React.createClass(&#123;</div><div class="line">    render: function()&#123;</div><div class="line">        return (</div><div class="line">            &lt;div className=&quot;row&quot;&gt;</div><div class="line">                &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt;</div><div class="line">                    &lt;LeftComponent /&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; borderRight: &apos;1px solid #999&apos;, minHeight: &apos;600px&apos;, textAlign: &apos;center&apos; &#125;&#125;&gt;</div><div class="line">                    &lt;TopComponent/&gt;</div><div class="line">                    &lt;CenterComponent/&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt;</div><div class="line">                    &lt;RightComponent /&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;            </div><div class="line">            );</div></pre></td></tr></table></figure>
<p>很简单吧，就是分别放了四个Component组件而已，我们也不用管这些组件是父子关系还是兄弟关系，因为redux不用考虑这些。然后我们去看看action吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// action </div><div class="line">module.exports = &#123;</div><div class="line">	addModelAction: function(name)&#123;</div><div class="line">	    return &#123;</div><div class="line">	        type: &apos;ADD_MODEL&apos;,</div><div class="line">	        name: name</div><div class="line">	    &#125;</div><div class="line">	&#125;,</div><div class="line">	editModelAction: function(index, name) &#123;</div><div class="line">		return &#123;</div><div class="line">			type: &apos;EDIT_MODEL&apos;,</div><div class="line">			index: index,</div><div class="line">			name: name</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	deleteModelAction: function(index) &#123;</div><div class="line">		return &#123;</div><div class="line">			type: &apos;DELETE_MODEL&apos;,</div><div class="line">			index: index</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	activeModelAction: function(index) &#123;</div><div class="line">		return &#123;</div><div class="line">			type: &apos;ACTIVE_MODEL&apos;,</div><div class="line">			index: index</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在action.js这个文件里，我们写了四个action函数，每个函数都返回一个对象作为action，是不是很简单，每个action函数中返回的对象里type都是定义好了的，然后根据传入的参数来配置其他返回参数；然后再来看看reducer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// reducers</div><div class="line">var modelReducer = function(state, action)&#123;</div><div class="line">    switch(action.type)&#123;</div><div class="line">        case &apos;ADD_MODEL&apos;:</div><div class="line">            state.items.push(&#123;</div><div class="line">                name: action.name</div><div class="line">            &#125;);</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        case &apos;DELETE_MODEL&apos;:</div><div class="line">        	state.items.splice(action.index, 1);</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        case &apos;EDIT_MODEL&apos;:</div><div class="line">        	state.items[action.index].name = action.name;</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        case &apos;ACTIVE_MODEL&apos;:</div><div class="line">            state.activeIndex =  action.index; </div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = modelReducer;</div></pre></td></tr></table></figure>
<p>这个也不难，我们都知道reducer需要传入两个参数：state和action，通过action里的type来对state进行相应的操作，最后return state。<br><br>好了，reducer和action都看了，redux三要素现在来看看store。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">import modelReducer from &apos;./reducer&apos;</div><div class="line">var store = createStore(modelReducer, &#123;items: [], activeIndex: -1 &#125;);</div><div class="line">module.exports = store;</div></pre></td></tr></table></figure>
<p>对的，一共就这几行，store=createStore(modelReducer, {items: [], activeIndex: -1 })，第一个参数是reducer，必需的，另一个是state初始化的值，非必需，若不传则默认为undefined。<br><br>其实到这里，这个示例就已经到了尾声了；剩下的就是这四个组件的内部布局，还有就是给按钮绑定事件，当点击的时候用dispatch分发一个对应的action函数给reducer，这些我在之前也已经写过了，所以这里就不再赘述了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-24T06:54:34.000Z"><a href="/2016/07/24/react生命周期/">2016-07-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/24/react生命周期/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="react生命周期解读"><a href="#react生命周期解读" class="headerlink" title="react生命周期解读"></a>react生命周期解读</h1><p>前几天在工作中出现了一个比较怪异的bug，不过还好由于react的单向数据流，从最外层父组件一层一层地往里面找，在每一层都检查一下state和props的值是否正确，总会找到问题，只不过那个组件被前人嵌套了四五层，所以在定位问题的时候比较蛋疼，所以还是最好养成良好的习惯，组件嵌套层级不要太多，而且在开发的时候每一层就别忘了检测props和state，否则后来人会很累的。。。<br><br>经过了long long time，才在某一层组件中找到了问题，具体问题是父组件传入的props改变后子组件通过props来渲染的页面没有发生改变，有疑问吗？父组件传入的props改变，子组件的props不是会自动接收变化并且render吗？嗯，是的，为什么这里没有呢。。。原来有人在开发的时候在<code>getInitialState</code>函数中加了这么一句：<code>this.state.xxx = this.props.xxx</code>，通过这样，他就把props和state关联了起来，心中顿时有无数草泥马狂奔。。。怎么改呢？难道要我把和state关联了的props都取消关联？这个工作量不小。。。还好，react里有个监测props变化的函数：<code>componentWillReceiveProps</code>，然后我再在里面把更新后的props和state关联起来，让state等于新的props就好了，大功告成，这个怪异的问题就解决了。<br><br>有人会觉得奇怪吗？为什么在<code>getInitialState</code>函数中使用了<code>this.state.xxx = this.props.xxx</code>，而在当props更新后传进来时，state依然等于原来的props，这就说到了本片文章的主要，就是react的生命周期。<br></p>
<h2 id="react组件的详细说明和生命周期"><a href="#react组件的详细说明和生命周期" class="headerlink" title="react组件的详细说明和生命周期"></a>react组件的详细说明和生命周期</h2><p>先来说一下react场见的函数吧。<br><br>1，<code>render</code>。<br><br>重要的事情说三遍：render()方法是必须的！render()方法是必须的！！render()方法是必须的！！！<br><br>当使用render方法的时候，它最终return一个单子级组件，这个意思就是说返回<strong>一个</strong>dom 组件，比如一个 div 节点，也可以是其他自定义的组件，有个要点就是一定只能 return 一个 dom 组件，当你有多个单独的dom节点或者单独的自定义组件要 return 的时候，必须要在外面包裹一层 div 才行。当然，你也可以返回 null 或者 false 来表明不需要渲染任何东西。在 return 前会干什么呢？return 的作用是渲染页面的，而渲染页面需要数据react 里的数据主要就是 props 和 state，所以在 render 方法中，它先会自动监测 props 和 state，render 方法有几个需要注意的点：1，render 函数中不能修改 state，所以 setState 方法是不能用的；2，render 并不是渲染真是的 dom ，而是 Virtual DOM，所以在这个方法中，你并不能对 dom 进行操作，this.getDOMNode()也去不到任何节点，只能得到 null。3，不和浏览器交互，例如通过使用 setTimeout。<br><br>2，<code>getInitialState</code><br><br>这是初始化state的方法，仅仅在组件挂载之前调用一次！<br><br>3，<code>getDefaultProps</code><br><br>在组件创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 this.props，（可以使用 in 来检测属性）。该方法在实例创建之前调用，因此不能依赖于 this.props。<br><br>4，<code>componentWillMount</code><br><br>这个方法会在初始化渲染完毕之前立即调用，仅执行一次。可以使用 setState 方法。<br><br>5，<code>componentDidMount</code><br><br>这个方法会在初始化渲染完毕之后立即调用，仅执行一次。这个时候已经渲染完毕了，所以 Virtual DOM 已经成为了真实的 DOM，你可以使用 this.getDOMNode()方法，发送 ajax 请求，或者 setTimeout 等方法。<br><br>6，<code>componentWillReceiveProps</code><br><br>该方法仅仅在组件接收到新的 props 的时候调用。所以初始化的时候不会调用这个方法，传入的参数将是即将接收到的新的 props，一般会通过新老 props 比较，然后再决定需不需要更新页面。<br><br>7，<code>shouldComponentUpdate</code><br><br>当组件接收到了新的 props 或者 state 的时候，即将要渲染页面之前调用这个方法。按常规来说，组件 state 或 props 更新后，往往都是需要重新渲染一下页面的，当然，这不是百分之百，所以这个时候就需要在渲染之前，在判断一下，是否真的需要渲染，在这个方法中可以获得 nextProps 和 nextState，然后我们可以比较，看是不是真的需要渲染，如果需要渲染，就return true，不需要渲染就 return false，这个方法默认是会返回 true 的。这个方法存在的意义就是不该渲染的时候不渲染，节约时间优化性能，当然，组件少了也没什么实际意义，可是当组件数量成百上千的时候，或许就会很明显地感觉到优化的性能了。<br><br>8，<code>componentWillUpdate</code><br><br>这个方法主要是在接收到新的 props 或者 state 之前立刻调用，使用该方法做一些更新之前的准备工作，此时不能更改 state。<br><br>9，<code>componentDidUpdate</code><br><br>个人觉得和componentDidMount类似，只是一个在初始化渲染后调用，一个在更新渲染后调用。<br><br>10，<code>componentWillUnmount</code><br><br>在组件从 DOM 中移除的时候立刻被调用，在该方法中执行任何清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。<br><br>唉，好累，终于把这一大堆函数科普完了，我稍微归纳一下吧，方法大致有以下几类：初始化的时候执行的，初始化渲染前执行的，初始化渲染后执行的，接收更新时执行的，接收更新后渲染之前执行的，接收更新后渲染之后执行的，即将移除前执行的。这么多方法，都是和执行时间有关，并且一个方法后往往会执行另一系列的方法，这就是它的生命周期。<br><br>所以回到上面的问题，当父组件的 props 更新后，子组件的 props 也会更新没错，但是这时并不会重新去执行一次 getInitialState 方法，因为这个方法仅仅在初始化的时候调用一次，所以最后 render 时还是用的之前的 state 来进行渲染，所以我做的就是加上 componentWillReceiveProps 来进行人为更新 state。<br></p>
<h2 id="这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。"><a href="#这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。" class="headerlink" title="这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。"></a>这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。</h2><p><img src="http://oatasl78l.bkt.clouddn.com/react%20cycle1.png" alt=""><br><br><img src="http://oatasl78l.bkt.clouddn.com/react%20cycle2.jpg" alt=""><br><br>上面两张图分别是各个不同的变化会产生的不同的一系列的方法调用，，以及每个方法是否能够对 state 进行更新都做了说明，可以看到，初始化的时候，props 变化的时候，state 变化的时候，都会触发不同方法来进行处理，有的函数是可以不写的，因为它默认会执行，经过上次改bug的事情后，我觉得吧，层级多了的时候还是最好在每个层级里面对 props 和 state 进行控制监测一下，以免发生不必要的错误。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-23T08:48:01.000Z"><a href="/2016/07/23/redux example(1)/">2016-07-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/23/redux example(1)/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="redux-example-1"><a href="#redux-example-1" class="headerlink" title="redux example(1)"></a>redux example(1)</h1><p>最近在学习redux，看了不少相关的资料，发现这个<a href="http://cn.redux.js.org/docs/introduction/Examples.html" target="_blank" rel="external">官方教程</a>的一些例子还是很不错的，由浅入深各个档次都有，所以我稍微看了下，准备有时间的话将示例都自己弄懂，然后分别写篇详细的解读出来，由于是临时起意，所以今天先写第一篇吧。</p>
<h2 id="counter-vanilla"><a href="#counter-vanilla" class="headerlink" title="counter-vanilla"></a>counter-vanilla</h2><p>这是redux中的第一个示例，也就是说是最简单的一个例子，不多说了，先看看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;Redux basic example&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;https://npmcdn.com/redux@latest/dist/redux.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;p&gt;</div><div class="line">        Clicked: &lt;span id=&quot;value&quot;&gt;0&lt;/span&gt; times</div><div class="line">        &lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt;</div><div class="line">        &lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt;</div><div class="line">        &lt;button id=&quot;incrementIfOdd&quot;&gt;Increment if odd&lt;/button&gt;</div><div class="line">        &lt;button id=&quot;incrementAsync&quot;&gt;Increment async&lt;/button&gt;</div><div class="line">      &lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">      function counter(state, action) &#123;</div><div class="line">        if (typeof state === &apos;undefined&apos;) &#123;</div><div class="line">          return 0</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (action.type) &#123;</div><div class="line">          case &apos;INCREMENT&apos;:</div><div class="line">            return state + 1</div><div class="line">          case &apos;DECREMENT&apos;:</div><div class="line">            return state - 1</div><div class="line">          default:</div><div class="line">            return state</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var store = Redux.createStore(counter)</div><div class="line">      var valueEl = document.getElementById(&apos;value&apos;)</div><div class="line">      function render() &#123;</div><div class="line">        valueEl.innerHTML = store.getState().toString()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      render()</div><div class="line">      store.subscribe(render)</div><div class="line"></div><div class="line">      document.getElementById(&apos;increment&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">      document.getElementById(&apos;decrement&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">      document.getElementById(&apos;incrementIfOdd&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          if (store.getState() % 2 !== 0) &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">      document.getElementById(&apos;incrementAsync&apos;)</div><div class="line">        .addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          setTimeout(function () &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;, 1000)</div><div class="line">        &#125;)</div><div class="line">    &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>如上面代码所示，一共也就几十行，而且就这一个文件，毕竟是最基础最简单的一个示例，所以也没有什么文件结构和包依赖，以及到node服务器等，，唯一的一个依赖也通过了script标签引入。<br>不废话了，下面开始讲解一下代码吧。<br><br>dom结构就很简单吧，主要就是一个span标签包裹一个数字，然后就是几个button按钮，点击按钮的时候会让span标签里的数字增一、减一、奇数加一变为偶数、异步加一（也就是加个定时器延迟）。<br><br>下面来看script标签里的代码，也就是实现逻辑和功能的主要代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function counter(state, action) &#123;</div><div class="line">	if (typeof state === &apos;undefined&apos;) &#123;</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	switch (action.type) &#123;</div><div class="line">		case &apos;INCREMENT&apos;:</div><div class="line">			return state + 1</div><div class="line">		case &apos;DECREMENT&apos;:</div><div class="line">        	return state - 1</div><div class="line">       	default:</div><div class="line">        	return state</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码主要实现的是reducer，它主要接收两个参数，一个是state，另一个是action，state指代的是react中的state（状态），也就是这里span标签中的数字，action是一个对象，通过action，reducer就知道该做什么，比如这段代码就是通过判断action.type，来对state进行操作。<br><br>这里有一个值得注意的点，那就是给state设置一个return的默认值，一般来说就写成<strong>function counter(state = initialState, action)</strong>，es6的写法，意思在忘了传state的时候给state传入一个默认值。<br><br>var store = Redux.createStore(counter)<br><br>上面这句代码，主要实现的是用createStore方法，创建store，而传入的参数counter我上面已经说过了，是一个reducer，所以store的创建实际上是这样的：var store = createStore(reducer)。<br><br><strong>整个应用，只能有一个store！</strong>可是，reducer却可以有多个，这样问题就来了，由于创建store的时候需要传入reducer，而store只能有一个，但是reducer却可以有多个，那怎么办？<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">]react-redux</a>中又一个管理reducer的方法，叫做<strong>combineReducers</strong>，它能把所有的reducer集中整合为一个reducers，其使用方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var reducers = combineReducers(&#123;</div><div class="line">  reducers1,</div><div class="line">  reducers2...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>关于react-redux的具体细节后面再说。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var valueEl = document.getElementById(&apos;value&apos;)</div><div class="line">function render() &#123;</div><div class="line">	valueEl.innerHTML = store.getState().toString()</div><div class="line">&#125;</div><div class="line">render()</div><div class="line">store.subscribe(render)</div></pre></td></tr></table></figure>
<p>这段代码就主要就是执行render函数了，store.getState() 函数，它将会返回state。如果是常规react的render函数的话，是将一个dom节点挂载到root element下面去，而在这个示例中，只要将状态挂载到对应的节点上去就可以了。最后一行代码是注册状态监听器，在这里指当store里面的state发生改变时，触发render回调函数<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&apos;increment&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line">document.getElementById(&apos;decrement&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)</div><div class="line">        &#125;)</div><div class="line">document.getElementById(&apos;incrementIfOdd&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          if (store.getState() % 2 !== 0) &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">document.getElementById(&apos;incrementAsync&apos;).addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">          setTimeout(function () &#123;</div><div class="line">            store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)</div><div class="line">          &#125;, 1000)</div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<p>这段代码主要是给下面的各个按钮绑定事件，这里需要做的是分发action，通过<strong>store.dispatch(action)</strong>这个方法，把action传递给reducer，而reducer中已经定义好了具体的函数，会根据接收到的action来判断对state进行什么操作。<br><br>好了，第一个示例到此就基本结束了，下面我再好好地整理一下redux的具体流程：<br><br>1，通过createStore方法创建store，传入reducer参数，<strong>且一个应用只能有一个store。</strong>store常用的方法有：getState方法，用来获取state；dispatch方法用来分发action，subscribe方法用来注册监听器执行回调函数。<br><br>2，创建好store后，通过dispatch方法来分发action给reducer，action是一个对象。<br><br>3，reducer接收到了state（state可传可不传，但是要在reducer中写上没有传state时的情况判断），action后，会根据action里的type属性来对state进行对应的操作。<br><br><strong>我描绘一下redux的流程图，大致这样的：const store = createStore(reducer) –&gt; store.dispatch(action) –&gt; reducer(state, action) –&gt; 根据state渲染页面</strong><br><br><br><br><br><br></p>
<p>auther: Wisdommm</p><br><p>date: 2016-07-23</p>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:wisdommm.github.io">
  </form>
</div>

  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Wisdommm
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>