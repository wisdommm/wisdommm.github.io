[{"title":"震惊！大多数前端都不知道的知识","date":"2017-03-24T09:04:18.000Z","path":"2017/03/24/震惊，大多数前端都还不知道这道题的答案/","text":"写在前面最近看了两篇不错的文章，都是和定时器（setTimeout）有关，所以我想写一篇博客，把那两篇文章能够融合、整理一下。至于标题，参照UC震惊部取的，笑一笑就好了。 正文话不多说，直接进入正题吧，看下面一段代码，结果会输出什么： 1234for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i) 当然是输出0，1，2，3，4，5呀，这么简单的东西也敢问人？ 好吧，我们再看看下面这段代码会输出什么： 123456for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 );&#125;console.log(i); 其实如果你对定时器（setTimeout）有个基本的了解的话，你就会清楚的知道，会输出5，5，5，5，5，5，OK？ 那我想问下，这六个5输出的状态是怎样的，比如在输出时中间的时间间隔关系是怎样的？ 这里有三个选项： A.5-&gt;5-&gt;5-&gt;5-&gt;5-&gt;5，每个5之间都会间隔1秒。 B.555555，所有5一起输出。 C.5-&gt;55555，第一个5输出，等待1秒后后面5个5一起输出。 好的，不卖关子，答案是C，这里面实际上就设计了比较多的知识点，比如同步和异步代码的区别，变量的作用域，闭包等概念，所以实际输出的时候，会先输出for循环外面的那个i，由于i经过了上面的for循环，所以此时i已经是5了，所以会先输出5，然后就是由于定时器的原因，for循环中定时器里有5个一样的console函数，它们都会等待一秒，然后会输出i，而这个时候的i，已经是循环之后的i了，所以会输出5，所以才会5个函数同时等待一秒后，5个5同时输出，这就是选C的原因。这就要求度js的定时器工作机制有基本的了解。 进阶上面的代码，输出方式为5-&gt;55555，那么，如果我想上面代码的输出变为：5-&gt;01234，那么会怎样，这里就考验了同学对于闭包的熟悉程度，其代码如下： 12345678for(var i=0;i&lt;4;i++)&#123; function(j)&#123; setTimeout(function()&#123; console.log(j) &#125;,1000); &#125;(i);&#125;console.log(i); 这里就是运用了IIFE来解决闭包造成的问题，其实我们可以把代码解藕一下，将IIFE函数提出来，就变成了下面这样： 123456789let func = function(j)&#123; setTimeout(function()&#123; console.log(j) &#125;,1000); &#125;for(var i=0;i&lt;5;i++)&#123; func(i);&#125;console.log(i); 既然都到了这里，那么如果我想输出结果变成这样，5-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4,代码应该怎么写？ 123456789let func = function(i)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i);&#125;for(var i=0;i&lt;5;i++)&#123; func(i)&#125;console.log(i); 这里其实已经考察了闭包的灵活运用了，假设把func函数中的形参去掉，变成这样，结果会是怎样的？ 12345678let func = function(/*去掉这里的形参*/)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i);&#125;for(var i=0;i&lt;5;i++)&#123; func(i);&#125; 这样的话，定时器函数的内部就没有保持对外部i的引用，就会变成5-&gt;5-&gt;5-&gt;5-&gt;5。 好吧前面都是小大小闹，看看这里，假设定时器里面传入的不是函数，而是一个IIFE函数的话，结果会怎样？ 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; 这就变成了传入一个IIFE函数进去，setTimeout可以接受一个函数或者字符串作为参数，可是这里的IIFE函数，会怎样呢？所以这里的定时器此时就没有任何的作用了，所以会直接一下子输出01234，不会有定时器功能。 ES6 Promise完了吗？还早呢，这全是回调函数，ES6中的Promise现在已经用得比较广泛了，好吧，现在将上面的代码采用Promise来改写一下，应该怎么写？ 12345678910111213141516const arr = []; // 这里存放异步操作的Promisevar func = function(i)&#123; new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i); &#125;);&#125;for(var i=0;i&lt;5;i++)&#123; arr.push(func(i));&#125;Promise.all(arr).then(()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000);&#125;) 上面就是采用Promise来改写后的代码，这里考察了Promise的熟练运用和新技术的学习，虽然Promise不算什么新技术呢。。。 ES7 async/await好吧，既然Promise不算什么新的技术，那我们来看看新的技术——acync/await函数。老规矩，将上面的异步代码用ES7中的async/await函数重写一下。 123456789101112const sleep = (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, time); &#125;);&#125;(async () =&gt; &#123; for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(i); &#125;&#125;)(); 注意：await后面可以是一个异步函数也可以不是，我之前在sleep中的Promise忘了加上return，结果定时器就没有发生作用。。。无语。 好了ES6的Promise和ES7的async/await函数都讲到了，下面来看下最后一道题： 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 这道题其实初看，还是挺难的，异步就有promise和setTimeout，还有for循环来分散你的注意力，也是危机四伏啊。 其实没必要这么麻烦，我们可以先基本看一遍，知道其主要意思，就是让你去分一下异步与同步，同时还有两种异步来让你去分先后顺序；所以首先，我们需要来去分一下这段代码中的同步和异步先将同步与异步分开，首先来看，哪些是同步哪些是异步：按先后顺序来说，同步的有2，3，5；异步的是1和4。而且结果中，肯定是同步在前异步在后，所以结果应该是（2，3，5）（1，4），括号中的顺序可能会有改动，然后在来每个仔细分析一下，首先是同步，同步其实很简单，就是简单的按先后顺序输出，所以前面的2，3，5，顺序不用改变，这里有一些小陷阱，比如setTimeout的定时为0，其实这还是一个定时器，接下来就是有一个9999的循环，其实这个并不会影响什么，也不需要太在意这个；最后，再来看看异步，先是一个setTimeout的console.log(1)，然后是Promise的回调console.log(4)，假设是两个相同的异步，比如都是setTimeout或者都是Promise，那么也很简单，也将会是按先后顺序输出，现在问题来了，那么setTimeout和Promise这两种回调方法，有什么差异呢？如果在回调上没有差异，那么就是按先后顺序了，结果呢？Promise和setTimeout回调最大的区别在于，Promise的回调，会放在当前事件队列的末尾，但是setTimeout不是，它会放在下一个事件队列的头部，所以Promise比setTimeout会更快执行回调，所以是Promise的回调先输出，所以最终结果也就是2，3，5，4，1。","tags":[]},{"title":"javascript事件机制","date":"2017-03-23T07:15:19.000Z","path":"2017/03/23/js事件机制/","text":"js事件基础先简单介绍一下js的事件吧，其就是你通过一些工具（鼠标，键盘，触摸板，手指等）在网站进行的一系列操作，滚动，点击，触摸，移动等，我们在代码中先定义了这些事件，然后当对应的事件发生的时候，我们所定义的事件就会被自动触发，执行；这就是js的事件，可是这内部的核心机制是什么呢，请看下面。","tags":[]},{"title":"fastClick 基本解读","date":"2017-03-20T11:30:28.000Z","path":"2017/03/20/fastClick/","text":"fast click诞生背景与使用做过移动端前端的同学，应该都知道“点击延迟”，意思就是原生js的click事件在移动浏览器上会有300毫秒的延迟，这样就会让用户觉得卡顿，影响用户体验。为什么会有延迟呢？因为移动浏览器都是支持双击的，比如双击缩放或双击滚动，所以当用户第一次点击屏幕后，浏览器并不知道你是单击还是双击，因此所有的浏览器都效仿了Safari的做法，那就是等待300毫秒。 现在移动端大行其道，已经占据了主流。最显著的一个例子就是，天猫双十一的时候，超过百分之八十的订单都来自于移动端，这也就说明了移动端现在的火热程度。在这个前提下，你移动端的每个点击事件都有300毫秒的延迟，那是绝对不允许的。 后面也出现了很多的解决办法，比如Zepto的tab事件(会引发击穿tab的bug)，fastClick.js等等，所以现在我就准备来好好讲解一下fastClick。 解析引入fastClick源码的第829行：选择引入fastClick的方式，具体代码如下： 1234567891011121314if (typeof define === &apos;function&apos; &amp;&amp; typeof define.amd === &apos;object&apos; &amp;&amp; define.amd) &#123; // 优先兼容AMD的方式 define(function() &#123; return FastClick; &#125;);&#125; else if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; // 其次是commonJs module.exports = FastClick.attach; module.exports.FastClick = FastClick;&#125; else &#123; // 最后兼容原生js window.FastClick = FastClick;&#125; 入口源码第824行：fastClick入口方法 attach 123456// 这里是通过return一个newFastClick函数来进行继承的// 其中layer参数是指的要监听的dom对象// option是用来覆盖自定义参数FastClick.attach = function(layer, options) &#123; return new FastClick(layer, options);&#125;; FastClick 主函数第23行到103行，这里主要是设置一些参数的默认值，这些参数就是FastClick的精华所在，也就是上面option参数中的默认参数值，其代码大致如下。 12345678910this.trackingClick = false;this.trackingClickStart = 0;this.targetElement = null;this.touchStartX = 0;this.touchStartY = 0;this.lastTouchIdentifier = 0;this.touchBoundary = options.touchBoundary || 10;this.layer = layer;this.tapDelay = options.tapDelay || 200;this.tapTimeout = options.tapTimeout || 700; 判断是否需要fastClick第105到107行，判断是否需要引入fastClick，如果不需要则return。 123if (FastClick.notNeeded(layer)) &#123; return;&#125; 话说回来，并不是任何时候都需要引入fastClick的，其官网上面就说得很清楚，下面几种情况，是不需要引入fastClick的。 1，所有pc浏览器。 2，浏览器不支持ontouchstart。 3，安卓中chrome meta中有禁止缩放（user-scalable=”no”）。 4，安卓中chrome meta中有width=”device-width”。 5，黑莓 10.3+。 6，firefox 27+。 7，有-ms-touch-action: manipulation属性的IE10。 8，有touch-action: manipulation属性的IE11。 将自定义的函数绑定在传入的dom节点上第110行到132行。 1234layer.addEventListener(&apos;touchstart&apos;, this.onTouchStart, false);layer.addEventListener(&apos;touchmove&apos;, this.onTouchMove, false);layer.addEventListener(&apos;touchend&apos;, this.onTouchEnd, false);layer.addEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false); 对旧版本android不支持 stopImmediatePropagation 事件的兼容第137行到159行。 这里可以简单说一下 stopImmediatePropagation 和 stopPropagation 的区别吧。stopPropagation是阻止事件冒泡到父级元素，这是最基本的，而stopImmediatePropagation除了能够达到这个要求外，还额外执行了一件事，就是阻止绑定在事件元素的其它同类事件的回调函数的运行，比如下面的示例： 1234567$(&quot;p&quot;).click(function(event) &#123; event.stopImmediatePropagation();&#125;);$(&quot;p&quot;).click(function(event) &#123; // 不会执行以下代码 $(this).css(&quot;background-color&quot;, &quot;#f00&quot;);&#125;); 兼容直接绑定在dom元素上的onclick事件第164行到173行。 1234567if (typeof layer.onclick === &apos;function&apos;) &#123; oldOnClick = layer.onclick; layer.addEventListener(&apos;click&apos;, function(event) &#123; oldOnClick(event); &#125;, false); layer.onclick = null;&#125; 先判定html元素的元素内部是否直接写了onclick事件，类似于这样：，如果有的话，将其使用js绑定在dom上，然后将html元素内的事件清空。 这是为了之后的模拟点击事件。 判断用户终端178-221 通过navigator.userAgent来判断用户的终端类型，其中有个问题是“Windows Phone 8.1 fakes user agent string to look like Android and iPhone.”，所以在判断安卓和iOS的时候需要有一个判断前提，就是非window phone的时候。 needsClick函数，needsFocus函数227-254 判断哪些元素需要原生的click事件，哪些需要原生的focus事件。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051FastClick.prototype.needsClick = function(target) &#123; switch (target.nodeName.toLowerCase()) &#123; // Don&apos;t send a synthetic click to disabled inputs (issue #62) case &apos;button&apos;: case &apos;select&apos;: case &apos;textarea&apos;: if (target.disabled) &#123; return true; &#125; break; case &apos;input&apos;: // File inputs need real clicks on iOS 6 due to a browser bug (issue #68) if ((deviceIsIOS &amp;&amp; target.type === &apos;file&apos;) || target.disabled) &#123; return true; &#125; break; case &apos;label&apos;: case &apos;iframe&apos;: // iOS8 homescreen apps can prevent events bubbling into frames case &apos;video&apos;: return true; &#125; return (/\\bneedsclick\\b/).test(target.className);&#125;;FastClick.prototype.needsFocus = function(target) &#123; switch (target.nodeName.toLowerCase()) &#123; case &apos;textarea&apos;: return true; case &apos;select&apos;: return !deviceIsAndroid; case &apos;input&apos;: switch (target.type) &#123; case &apos;button&apos;: case &apos;checkbox&apos;: case &apos;file&apos;: case &apos;image&apos;: case &apos;radio&apos;: case &apos;submit&apos;: return false; &#125; // No point in attempting to focus disabled inputs return !target.disabled &amp;&amp; !target.readOnly; default: return (/\\bneedsfocus\\b/).test(target.className); &#125;&#125;; 上面这些就是哪些要原生click，原生focus的元素。如果需要，只需要在dom元素的class中加上“needsClick”或者“needsFocus”。像这样： 1&lt;div class=&quot;needsclick&quot;&gt;aaaa&lt;/div&gt; 各种判断311-319行：determineEventType 兼容安卓chrome中的select框事件从click改为mousedown 12345678FastClick.prototype.determineEventType = function(targetElement) &#123; //Issue #159: Android Chrome Select Box does not open with a synthetic click event if (deviceIsAndroid &amp;&amp; targetElement.tagName.toLowerCase() === &apos;select&apos;) &#123; return &apos;mousedown&apos;; &#125; return &apos;click&apos;;&#125;; 327-337行：focus函数 兼容苹果手机(iOS7)setSelectionRange不能正确获取焦点的bug 123456789101112FastClick.prototype.focus = function(targetElement) &#123; var length; // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don&apos;t have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can&apos;t be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724. if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123; length = targetElement.value.length; targetElement.setSelectionRange(length, length); &#125; else &#123; targetElement.focus(); &#125;&#125;; 376-384行：getTargetElementFromEventTarget函数，兼容获取点击元素，iOS 4.1中会获取文字作为焦点，取它的父元素dom 1234567FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) &#123; // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node. if (eventTarget.nodeType === Node.TEXT_NODE) &#123; return eventTarget.parentNode; &#125; return eventTarget;&#125;; 497-512行：findControl函数，为了点击label元素的时候能改找到其所对应的表单元素的焦点 123456789101112131415FastClick.prototype.findControl = function(labelElement) &#123; // Fast path for newer browsers supporting the HTML5 control attribute if (labelElement.control !== undefined) &#123; return labelElement.control; &#125; // All browsers under test that support touch events also support the HTML5 htmlFor attribute if (labelElement.htmlFor) &#123; return document.getElementById(labelElement.htmlFor); &#125; // If no for attribute exists, attempt to retrieve the first labellable descendant element // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label return labelElement.querySelector(&apos;button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea&apos;);&#125;; 461-469：touchHasMoved 手指点击时移动间距大于10px，返回true 123456789FastClick.prototype.touchHasMoved = function(event) &#123; var touch = event.changedTouches[0], boundary = this.touchBoundary; if (Math.abs(touch.pageX - this.touchStartX) &gt; boundary || Math.abs(touch.pageY - this.touchStartY) &gt; boundary) &#123; return true; &#125; return false;&#125;; 478-490：onTouchMove 手指点击时移动间距大于10px，即视为touchmove，不触发模拟click事件 12345678910111213FastClick.prototype.onTouchMove = function(event) &#123; if (!this.trackingClick) &#123; return true; &#125; // If the touch has moved, cancel the click tracking if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) &#123; this.trackingClick = false; this.targetElement = null; &#125; return true;&#125;; 核心方法393-452：onTouchStart函数，tapDelay默认300毫秒，点击时间差小于300毫秒，则阻止事件再次触发，阻止短时间内双击的问题 123456789101112131415161718192021222324252627282930313233343536373839FastClick.prototype.onTouchStart = function(event) &#123; var targetElement, touch, selection; if (event.targetTouches.length &gt; 1) &#123; return true; &#125; targetElement = this.getTargetElementFromEventTarget(event.target); touch = event.targetTouches[0]; if (deviceIsIOS) &#123; selection = window.getSelection(); if (selection.rangeCount &amp;&amp; !selection.isCollapsed) &#123; return true; &#125; if (!deviceIsIOS4) &#123; if (touch.identifier &amp;&amp; touch.identifier === this.lastTouchIdentifier) &#123; event.preventDefault(); return false; &#125; this.lastTouchIdentifier = touch.identifier; this.updateScrollParent(targetElement); &#125; &#125; this.trackingClick = true; this.trackingClickStart = event.timeStamp; this.targetElement = targetElement; this.touchStartX = touch.pageX; this.touchStartY = touch.pageY; if ((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123; event.preventDefault(); &#125; return true;&#125;; 523-612：onTouchEnd函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576FastClick.prototype.onTouchEnd = function(event) &#123; var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement; if (!this.trackingClick) &#123; return true; &#125; if ((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123; this.cancelNextClick = true; return true; &#125; if ((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123; return true; &#125; this.cancelNextClick = false; this.lastClickTime = event.timeStamp; trackingClickStart = this.trackingClickStart; this.trackingClick = false; this.trackingClickStart = 0; if (deviceIsIOSWithBadTarget) &#123; touch = event.changedTouches[0]; targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement; targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent; &#125; targetTagName = targetElement.tagName.toLowerCase(); if (targetTagName === &apos;label&apos;) &#123; forElement = this.findControl(targetElement); if (forElement) &#123; this.focus(targetElement); if (deviceIsAndroid) &#123; return false; &#125; targetElement = forElement; &#125; &#125; else if (this.needsFocus(targetElement)) &#123; if ((event.timeStamp - trackingClickStart) &gt; 100 || (deviceIsIOS &amp;&amp; window.top !== window &amp;&amp; targetTagName === &apos;input&apos;)) &#123; this.targetElement = null; return false; &#125; this.focus(targetElement); this.sendClick(targetElement, event); // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others) if (!deviceIsIOS || targetTagName !== &apos;select&apos;) &#123; this.targetElement = null; event.preventDefault(); &#125; return false; &#125; if (deviceIsIOS &amp;&amp; !deviceIsIOS4) &#123; if (scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123; return true; &#125; &#125; if (!this.needsClick(targetElement)) &#123; // 如果这不是一个需要使用原生click的元素，则屏蔽原生事件，避免触发两次click // 触发一次模拟的click event.preventDefault(); this.sendClick(targetElement, event); &#125; return false;&#125;; 296-311 sendClick（核心方法）12345678910111213141516FastClick.prototype.sendClick = function(targetElement, event) &#123; var clickEvent, touch; if (document.activeElement &amp;&amp; document.activeElement !== targetElement) &#123; document.activeElement.blur(); &#125; touch = event.changedTouches[0]; // 合并成一个点击事件，通过一个额外的属性，确保事件能够被跟踪 // 最后再通过模拟一个点击事件来执行，事件触发器dispatchEvent参考这篇文章 http://blog.csdn.net/magic__man/article/details/51831227 clickEvent = document.createEvent(&apos;MouseEvents&apos;); clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null); clickEvent.forwardedTouchEvent = true; targetElement.dispatchEvent(clickEvent);&#125;; Zepto 点击穿透与 FastClick移动端点击事件中，Zepto中也解决了移动浏览器中300毫秒的事情，但是就出现了各种击穿现象。 1，同页面tap点击弹出弹层，弹层中也有一个button，正好重叠的时候，会出现击穿。 2，tap事件点击，页面跳转，新页面中同位置也有一个按钮，会出现击穿。 解释击穿zepto中的 tap 通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，是通过事件冒泡实现的。在点击完成时（touchstart / touchend）的 tap 事件需要冒泡到 document 上才会触发。而在冒泡到 document 之前，手指接触和离开屏幕（touchstart / touchend）是会触发 click 事件的。 因为 click 事件有延迟（大概是300ms，为了实现safari的双击事件的设计），所以在执行完 tap 事件之后，弹出层立马就隐藏了，此时 click 事件还在延迟的 300ms 之中。当 300ms 到来的时候，click 到的其实是隐藏元素下方的元素。 如果正下方的元素有绑定 click 事件，此时便会触发，如果没有绑定 click 事件的话就当没发生。如果正下方的是 input 输入框（或是 select / radio / checkbox），点击默认 focus 而弹出输入键盘，也就出现了上面的“点透”现象。 击穿的解决办法遮挡由于移动端点击click事件的延后性，导致原本想点击的元素消失了，直接点击到了下面的元素，于是便有了穿透。于是最简单的办法就是在你点击的下方增加一层遮挡的元素，让其300毫秒后自动消失就行了；或者不用延时动画，改为增加一个透明的元素来隔离，也是可以的；这样就从dom方面对其进行了隔离，解决了穿透的问题。 pointer-eventspointer-events是CSS3中的属性，它有很多取值，有用的主要是auto和none，其他属性值为SVG服务。 如果pointer-events的属性值为none，元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。具体实现代码如下： 12345678910$(&apos;#closePopup&apos;).on(&apos;tap&apos;, function(e)&#123; $(&apos;#popupLayer&apos;).hide(); $(&apos;#bgMask&apos;).hide(); $(&apos;#underLayer&apos;).css(&apos;pointer-events&apos;, &apos;none&apos;); setTimeout(function()&#123; $(&apos;#underLayer&apos;).css(&apos;pointer-events&apos;, &apos;auto&apos;); &#125;, 400);&#125;); fastClick使用fastclick库，其实现思路是，取消 click 事件，用 touchend 模拟快速点击行为。只需要一句FastClick.attach(document.body); 从此所有的点击事件，都是用click且不会出现穿透问题，并且没有300毫秒的延迟。 下一篇博客，我会对js的事件机制做一个详细的分析，包括移动端的。","tags":[]},{"title":"ES6中的暂时性死区（TDZ）","date":"2017-02-10T06:54:50.000Z","path":"2017/02/10/ES6 TDZ/","text":"起因故事要从阮一峰老师的一条微博开始说起。。。 这条微博下面有很多的评论，有的厉害的人一眼就指出了这是由于TDZ的原因，并不是什么V8的bug，TDZ是什么？下面我们就来慢慢揭开这层面纱。 变量提升先从最简单的变量提升说起。 12345678console.log(a);var a = 123;// 这里会输出undefined，原因是上面这段代码和下面的这段代码是等价的var a;console.log(a);a = 123; 在ES6中，除了var关键字意外，还多了let和const关键字，有什么差异呢？ 先说const吧，const的意思是定义静态常量，是不可变的，所以我们可以先来开脑洞想想，当const遇上变量提升，会发生什么？ 12345678console.log(a);const a = 123;// 如果const的变量提升存在，则上面代码应该和下面代码等价const a;console.log(a);a = 123; 想必大家都发现问题了吧，很明显，前面说了const是定义的静态常量，是不可变的，假设上面的代码是对的，那么最开始a应该是undefined，可是后面却被再次赋值成了123，和const定义的静态常量不可改变相违背，所以这里就有问题，所以const没有变量提升？至少现在看起来，const是不应该有变量提升的。 然后再来看看let关键字，和上面一样，当let遇见变量提升，又会怎样呢？老规矩，上代码吧。 12345678console.log(a);let a = 123;// 如果let的变量提升存在，则上面代码应该和下面代码等价let a;console.log(a);a = 123; 这段代码，至少看起来是没有问题的，不是吗？可是实际有问题没有，还是要放进浏览器中运行一下才知道，所以我们把这段代码放进chrome里看看。 可惜，似乎很不幸。。。 所以照现在看来，const和let都是没有变量提升的，对吧。 然后我们来看下面一段代码。 123456let e = 12;(function()&#123;console.log(e);let e = 123;&#125;)()// 如果说let真的没有变量提升的话，那么这里应该打印出12，OK？实际上如何呢，还是把代码放进浏览器中运行看看吧。 怎么会是这样呢，不是说好的没有变量提升吗，怎么会报错啊？下面我们来细细分析。 let const 详解在ES6中，最常见的TDZ就是在let/const的使用上，根据ES6中对let/const声明的章节，原文是这样说的： 1The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. 这段话的意思是说，由let/const声明的变量，当它们包含的词法环境实例化时，才会被创建；且只有在变量的词法绑定已经被赋值后，才能被访问（使用）。 这段话详细地说，就是在程序在其词法环境（也就是其对应的作用域，比如模块，函数，块级作用域等）就行实例化的时候，（let/const声明的）变量就已经被创建了，但是这个时候还不能被访问（此时访问会出现not defined），只有当这个变量的词法绑定被赋值后，才能进行访问这个变量，也就是说当这个变量被赋值后，才能正常访问。所以在变量创建到变量赋值这一段时间内，访问时会报错，这段时间就叫做TDZ（暂时死区）。 因此，从上面看来，似乎let/const声明的变量，还是有变量提升（hoist）的作用的，所以这里也是会让很多人误解的地方，实际上，JS中的变量都有变量提升，这是JS语言中，变量的基本特性，but，因为TDZ的作用，所以let/const的变量提升并没有像var那样明显地得到undefined，而是会直接报错：not defined；而且这很明显是一个运行期间才会出现的问题。 所以上面提到的那个例子就已经说明了let也有变量提升，我们再来分析一下这个例子。 123456let e = 12;(function()&#123;// TDZ startconsole.log(e);let e = 123; // TDZ end&#125;)() 在这个IIFE函数中，本来console.log的时候，应该现在函数内部找，找不到的话再往外面找；可是由于下面，e又被在这个函数内重新定义赋值了，虽然是在console.log下面，但是由于是有变量提升的，所以在对应的作用域顶端（也就是这个IIFE函数的顶端），是TDZ start，然后直到这个变量被赋值，才是TDZ end，这中间的区域就叫做TDZ；因此，在console的时候由于内部又声明了变量e，所以在内部找到了变量e于是就不用继续往外面找了，因此不会输出12，又因为console的区域刚好处在TDZ的区域内，所以就算变量e被声明了，可是由于TDZ的存在，在变量被赋值之前暂时还不能访问，所以此时访问会出现报错“not defined”。 在ES6中的let与const声明章节的后面几句，说明了有关变量是如何进行初始化的： 1A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated. 这几句是关于变量初始化的过程的。以let/const所声明的变量（const声明的变量叫做固定的变量），必须是经过声明的赋值语句的求值后，才算初始化完成，而不是创建后就初始化完成。let/var声明过后如果没有赋予初始值，那么会赋值为undefined，但是const不行，const声明了变量后一定需要赋初始值的。初始化完成后才代表TDZ的真正结束，这些在作用域中被声明的变量才能被正常的访问。 下面的示例是一个未初始化完成的结果，它还在TDZ中，所以会发生错误，“x is not defined”。 1let x = x; 因为等号右边的x，它在此时还是一个未被初始化完成的变量，实际上我们就在这同一个表达式中要初始化它。 函数传参预设值TDZ作用在ES6中，很明确的就是与区块作用域(block scope)，以及变量/常量的要如何被初始化有关。实际上在许多ES6新特性中都有出现TDZ作用，而另一个常会被提及的是函数的传参预设值中的TDZ作用。 直接上示例把，看下面的代码。 123456789function foo(x=y,y=1)&#123; console.log(y)&#125;foo(1) // 这不会有错误foo(undefined, 1) // 错误 ReferenceError: y is not definedfoo() // 错误 ReferenceError: y is not defined 上面这些报错的主要原因是在函数声明时传入的形参初始化的这里，x=y,y=1可以看成let x=y,let y=1，这样应该就会清晰很多。 当然，对于传参预设值的作用域，也是作用域话题里一个常被讨论的话题，讨论这到底是属于“全局作用域”还是“函数中的作用域”，抑或是处于这两者之间的“中介区域”？现在看到比较常见的一种说法就是，它是处于“中介的作用域”，夹在这两者之间，仍然会与其它作用域相互影响。一个比较明显的示例就是，使用其它函数作为作为传参的预设值，这通常会是一个回调函数，一般情况下本没什么，但是涉及到作用域相互影响的时候，就会比较难以理解，比如这个示例，我将它大致的整理了一下。 123456789101112let x = 1;function foo(a = 1, b=function()&#123;x = 2;&#125; )&#123; let x = 3; b(); console.log(x);&#125;foo();console.log(x); 上面这个例子，最后会输出什么呢？ 这里有两个console，里面外面各一个，所以会输出两个值，里面的x的值是多少，要看作用域之间相互的影响，而外面的x的值，要看最外围的作用域最后会不会被改变，这也是一个问题。 下面来详细分解一下，函数foo中的x，值可能是2，也可能是3，肯定不是1，这个可以理解吧；而函数外面的那个x，值可能是1，也可能是2，绝不可能是3，这个也可以理解吧。 具体答案是多少？我不知道，或者说没有具体答案，我们可以分别用浏览器和编译器来运行一下代码试试：chrome下面会分别输出3和2，firefox下面会分别输出2和1，然后我就感到奇怪，再使用Edge来试试，结果发现会输出3与2，最后再使用著名的babel编译器，得出的结果是2与1，暂时看来，结果应该有2个，3与2或者2与1，我们分别来分析一下这两个答案吧，看看是什么问题让浏览器都没有统一的答案。 当结果是3与2的时候，说明b函数中的x=2运行了出来，但是由于中介作用域的影响，所以干扰不到函数中原本的区块作用域，但是直接改变了全局x的值。也就是几本认为了函数预设值中的那个函数中的作用域与全局（或者说是函数外层）有影响。 当结果是2与1的时候，就倒过来，中介作用域影响了函数内层的作用域，而没有影响外层的作用域。 因此，只有当中介作用域有自己独立的作用域的时候，完全与函数区块中的作用域以及函数外层中的作用域毫不相干的时候，那这个时候就会输出3与1，很遗憾，现在都是3与2或者2与1，看来中介作用域还是和函数外层（或者内层相关的），至于具体是外层韩还是内层，这个问题现在还没有一个明确的结果吧，否则各种浏览器的输出也就不会有差异了，不只这一个问题，chrome和firefox的差异还有其它，这里就不细讲了。 不管如何，这个作用域的影响仍然是有争议的，目前并没有统一的答案。这代表ES6虽然标准定好了，但里面的一些新特性仍然有实作细节的差异，未来有可能这些差异才会慢慢一致。但对一般的开发者来说，因为知道了有这些情况，所以要尽量避免，以免产生不必要的麻烦。 TDZ的其它陷阱typeof语句1234567// 一般来说，typeof 一个未定义的数据，都是undefined，因此typeof也可以作为判断变量是否存在（被赋值）的一种方法，那是因为之前没有let和const。typeof a; // undefinedtypeof b; // b is not definedlet b=1; 现在typeof也变得不安全了，你不能随意的对变量使用typeof操作，因为现在会有报错的风险，会变成一个陷阱，由于TDZ的设计，使得变量本就不该在声明前被访问。 TDZ期间抛出的错误是运行阶段的错误TDZ期间的错误，全部是运行阶段才会发生的错误，因为它需要变量／常量初始化的过程，在这个过程中，才会创建出TDZ，且真正运行到那里，调用到函数运行里面的代码时，才会TDZ相关的错误才会被抛出。 不用let/const ？其实没错，只要你声明变量的时候，不管局部还是全部，全部使用var，那么你就根本不用关心TDZ。 可是，在浏览器上的运行效能来看，大多数情况下，let效能比var强，且会有块级作用域的概念，这会减少因为局部变量／全局变量所引起的问题，而且let对变量有了更高的要求与标准，比如不允许未定义就使用；不允许重复定义等。。。 最后，附上一篇我做分享时做的展示文稿吧，https://pan.baidu.com/s/1hsl1SVi。。。","tags":[]},{"title":"redux源码解读","date":"2017-01-16T10:01:41.000Z","path":"2017/01/16/redux源码解读/","text":"这是2017年的第一篇博客，上周参加完各种年会聚会，本来准备周末写的，可是周末又突然有事，所以一直拖到现在，而且这是2017的第一篇技术博客，所谓好的开始是成功的一半，希望新的一年，自己可以继续坚持，变得更好。 redux其实我工作项目中接触的redux并不多，应该说只有一两个项目用到了redux，要求也是基本的redux的使用，dispatch一个action这种程度，react-redux也还没有涉及到，可能是项目的复杂程度不够大吧，所以涉及到redux的相关技术现在都是靠自学（唉，现在公司PHP迁移到JAVA，业务压力这么重，哪有时间自学啊，连示例都没看完，囧2333～）。 吐槽完毕，回到正题上来吧，学习一个库和框架最好的方法就是直接看源码，看源码好处有很多，不仅仅是学习API，还可以学习别人编写这个库（框架）的思想，这才是最为重要的，所以这次来写一篇redux源码相关的博客。 redux源码解读先把redux下载下来，发现很小，且没有依赖其他第三方库，简直是短小精悍啊，下面就让我好好见识下里面的思想。 我们直接看到src文件夹下，发现下面一共有七个文件或文件夹，分别是utils，applyMiddleware.js，bindActionCreators.js，combineReducers.js，compose.js，createStore.js，index.js。我们分别来看看。 utils这个是公用的工具方法，里面就warning.js一个文件，打开文件可以看到，里面就一个warning函数。 12345678export default function warning(message) &#123; if (typeof console !== &apos;undefined&apos; &amp;&amp; typeof console.error === &apos;function&apos;) &#123; console.error(message) &#125; try &#123; throw new Error(message) &#125; catch (e) &#123; &#125;&#125; 这个函数的主要目的就是抛出异常（错误），这个应该没什么好说的。 index.js接下来看看index.js文件，这种文件的主要目的一般是作为入口文件，里面代码也不多。 1234567891011121314151617181920212223function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; typeof isCrushed.name === &apos;string&apos; &amp;&amp; isCrushed.name !== &apos;isCrushed&apos;) &#123; warning( &apos;You are currently using minified code outside of NODE_ENV === \\&apos;production\\&apos;. &apos; + &apos;This means that you are running a slower development build of Redux. &apos; + &apos;You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify &apos; + &apos;or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) &apos; + &apos;to ensure you have the correct code for your production build.&apos; )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125; 首先看到一个空函数isCrushed，后面跟了一个if判断，第一个判断条件是process.env.NODE_ENV !== ‘production’，我记得process是node里的一个核心模块，然后我去node环境找了下process.env.NODE_ENV，发现undefined，说明本身是没有这个参数的，谷歌了一下，发现这是node的环境变量，如果process.env.NODE_ENV == ‘production’，则表示生产环境，具体参考地址在这里。这是第一个判断条件，而后面两个判断条件都是判断文件代码是否被压缩，因为如果被压缩了，那么isCrushed函数就不叫isCrushed函数了，同时浏览器发出警告。最后export一堆接口，分别是createStore,combineReducers,bindActionCreators,applyMiddleware,compose这五个。 createStore这应该是redux主要的一个函数，不对，应该是最主要的，顾名思义，createStore的意思就是创建store，而一个应用中只有唯一的一个store，你说这能不重要吗？ 废话不多说，先看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// 首先就定义了一个 ActionTypes 对象，它是一个action，是一个Redux的私有action，不允许外界触发，你可以在这段代码的最后面发现这个action就是初始化时，dispatch的action，也就是初始化Store的状态树和改变reducers后初始化Store的状态树。export var ActionTypes = &#123; INIT: &apos;@@redux/INIT&apos;&#125;// 这是主函数，createStore，它能够接收三个参数，reducer是必须的，preloadedState和enhancer是不必须，先来讲讲参数吧，reducer就是redux里的全局reducer，相当于一个全局的回调函数，返回下一个状态，接受两个参数：当前状态和触发的action（我自己编的，2333～）；preloadedState表示的是初始时的state，比如服务端渲染得到的初始状态，但是如果使用combineReducers来生成reducer，那必须保持状态对象的key和combineReducers中的key相对应；而enhancer是store的增强器函数，可以指定为第三方的中间件，时间旅行，持久化等等，但是这个函数只能用redux提供的applyMiddleware函数来生成。（这个我不怎么清楚，也没怎么用过。。。）export default function createStore(reducer, preloadedState, enhancer) &#123; // 这是判断是否有人传入参数顺序不对，如果是的话调整一下参数位置。 if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) &#123; enhancer = preloadedState preloadedState = undefined &#125; // enhancer只允许传入函数 if (typeof enhancer !== &apos;undefined&apos;) &#123; if (typeof enhancer !== &apos;function&apos;) &#123; throw new Error(&apos;Expected the enhancer to be a function.&apos;) &#125; return enhancer(createStore)(reducer, preloadedState) &#125; // reducer是必填的 if (typeof reducer !== &apos;function&apos;) &#123; throw new Error(&apos;Expected the reducer to be a function.&apos;) &#125; // 初始化参数，将当前状态currentState设置为初始状态preloadedState，初始化时间监听器数组等。 var currentReducer = reducer var currentState = preloadedState var currentListeners = [] var nextListeners = currentListeners var isDispatching = false function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // getState方法，返回当前的状态树currentState。 function getState() &#123; return currentState &#125; // subscribe函数，是给状态树添加监听函数，每当调用dispatch的时候，所有的监听函数就会执行。 function subscribe(listener) &#123; // 判断传入参数是否为函数 if (typeof listener !== &apos;function&apos;) &#123; throw new Error(&apos;Expected listener to be a function.&apos;) &#125; var isSubscribed = true // nextListeners是当前监听的事件列表，每次调用subscribe的时候，就会向nextListeners中push一个被监听的函数，并且将isSubscribed赋值为true。 ensureCanMutateNextListeners() nextListeners.push(listener) // 调用subscribe函数的时候，就会返回一个unsubscribe函数，用来取消监听函数，unsubscribe函数会先将isSubscribed的值改为false，同时将这个函数从当前监听的事件列表，也就是nextListeners中去除掉。 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() var index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; // dispatch函数，作用是分发action function dispatch(action) &#123; // 首先判断action格式 if (!isPlainObject(action)) &#123; throw new Error( &apos;Actions must be plain objects. &apos; + &apos;Use custom middleware for async actions.&apos; ) &#125; // action中type参数是必需的 if (typeof action.type === &apos;undefined&apos;) &#123; throw new Error( &apos;Actions may not have an undefined &quot;type&quot; property. &apos; + &apos;Have you misspelled a constant?&apos; ) &#125; // 判断是否正在dispatch if (isDispatching) &#123; throw new Error(&apos;Reducers may not dispatch actions.&apos;) &#125; // 开始dispatch，将isDispatching赋值为true，然后将currentState和action传给reducer，完成后再将isDispatching的值改为false。 try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; // dispatch完了后执行被监听了的函数，遍历函数列表nextListeners，分别执行里面的每个函数，最后会返回这个action。 var listeners = currentListeners = nextListeners for (var i = 0; i &lt; listeners.length; i++) &#123; listeners[i]() &#125; return action &#125; // 更改reducer，传入一个新的reducer，并且通过分发初始action，来初始化替换后reducer生成的初始化状态并且赋予store的状态。 function replaceReducer(nextReducer) &#123; // 容错判断，reducer必须是函数，是的话就用nextReducer替换掉currentReducer，再重新dispatch一下初始action，初始store。 if (typeof nextReducer !== &apos;function&apos;) &#123; throw new Error(&apos;Expected the nextReducer to be a function.&apos;) &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;) &#125; function observable() &#123; var outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== &apos;object&apos;) &#123; throw new TypeError(&apos;Expected the observer to be an object.&apos;) &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() var unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) // 最后就是返回这些所有的函数，作为暴露的接口使用。 return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 终于把createStore文件解读完了，下面来看看combineReducers函数。 combineReducers.jsreducer函数的作用是得到action后生成新的state，而由于一个app只拥有一个state，所以这个state肯定是比较复杂，数据比较多的，因此这个对应的处理生成state的reducer肯定也会是很复杂的，所以为了降低复杂度，也为了逻辑的解耦，我们会把这个大的reducer拆分成多个小的reducer，而这个combineReducers函数是为了整合所有的小的reducer，重新变为一个大的reducer，这就是combineReducers存在的原因，本来我想直接就把combineReducers的源码放上来的，不过我觉得可以先不忙，先具体的说一说combineReducers做的事情，下面这段讲解借鉴于阮一峰的博客。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187// 可以看到，这个方法有一个前提，就是state的属性名必须与子reducer同名const reducer = combineReducers(&#123; doSomethingWithA, processB, c&#125;)// 如果不同名，则如下const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125;// 然后下面是一个ombineReducers函数的简单的实现，看完了这个再看源码吧。const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;;// 其实这个简洁版的combineReducers还是比较容易理解的，主要就是先拿到reducers的key，然后通过reduce函数将原reducer的各个函数遍历一下返回一个新的reducers函数，很简单吧，至少看到这里，combineReducers函数的大概作用都是已经明白了吧，下面我门来看看其源码。// 前面这三个函数是对各个参数的合法性进行校验，比如reducer，state等。function getUndefinedStateErrorMessage(key, action) &#123; var actionType = action &amp;&amp; action.type var actionName = actionType &amp;&amp; `&quot;$&#123;actionType.toString()&#125;&quot;` || &apos;an action&apos; return ( `Given action $&#123;actionName&#125;, reducer &quot;$&#123;key&#125;&quot; returned undefined. ` + `To ignore an action, you must explicitly return the previous state.` )&#125;function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) &#123; var reducerKeys = Object.keys(reducers) var argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? &apos;preloadedState argument passed to createStore&apos; : &apos;previous state received by the reducer&apos; if (reducerKeys.length === 0) &#123; return ( &apos;Store does not have a valid reducer. Make sure the argument passed &apos; + &apos;to combineReducers is an object whose values are reducers.&apos; ) &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of &quot;` + (&#123;&#125;).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `&quot;. Expected argument to be an object with the following ` + `keys: &quot;$&#123;reducerKeys.join(&apos;&quot;, &quot;&apos;)&#125;&quot;` ) &#125; var unexpectedKeys = Object.keys(inputState).filter(key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key =&gt; &#123; unexpectedKeyCache[key] = true &#125;) if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &apos;keys&apos; : &apos;key&apos;&#125; ` + `&quot;$&#123;unexpectedKeys.join(&apos;&quot;, &quot;&apos;)&#125;&quot; found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `&quot;$&#123;reducerKeys.join(&apos;&quot;, &quot;&apos;)&#125;&quot;. Unexpected keys will be ignored.` ) &#125;&#125;function assertReducerSanity(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; var reducer = reducers[key] var initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === &apos;undefined&apos;) &#123; throw new Error( `Reducer &quot;$&#123;key&#125;&quot; returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined.` ) &#125; var type = &apos;@@redux/PROBE_UNKNOWN_ACTION_&apos; + Math.random().toString(36).substring(7).split(&apos;&apos;).join(&apos;.&apos;) if (typeof reducer(undefined, &#123; type &#125;) === &apos;undefined&apos;) &#123; throw new Error( `Reducer &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. ` + `Don&apos;t try to handle $&#123;ActionTypes.INIT&#125; or other actions in &quot;redux/*&quot; ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined.` ) &#125; &#125;)&#125;// 下面正式进入combineReducers.js文件的主函数，combineReducers（这句话怎么这么怪）export default function combineReducers(reducers) &#123; // 可以看到，首先是获取老的reducers的key数组 var reducerKeys = Object.keys(reducers) var finalReducers = &#123;&#125; for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i] // 判断老的reducer传入的key所对应的value是否是function，如果是，将老的reducer中的对象放入新的finalReducers对象中。 if (typeof reducers[key] === &apos;function&apos;) &#123; finalReducers[key] = reducers[key] &#125; &#125; var finalReducerKeys = Object.keys(finalReducers) // 判断node环境是否为生产环境，之前已经说过了，后面就不再赘述了。 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; var unexpectedKeyCache = &#123;&#125; &#125; // 验证finalReducers是否合法。 var sanityError try &#123; assertReducerSanity(finalReducers) &#125; catch (e) &#123; sanityError = e &#125; // 返回最终生成的reducer。 return function combination(state = &#123;&#125;, action) &#123; if (sanityError) &#123; throw sanityError &#125; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; var hasChanged = false var nextState = &#123;&#125; for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === &apos;undefined&apos;) &#123; var errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; // 遍历一遍看是否改变，然后返回原有状态值或者新的状态值 return hasChanged ? nextState : state &#125;&#125; compose.js123456789101112131415// compose可以接受一组函数参数，从右到左来组合多个函数，然后返回一个组合函数，reduceRight和reduce的差异就是reduceRight是从右边开始遍历的，至于后面的逗号简写方式，可以参考[这个问题](https://segmentfault.com/q/1010000007320321)。export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; 总结？这一次的redux源码解读先讲到这里吧，感觉这个信息量已经很大了，这些代码都是比较精简且耦合度低，没依赖其他的第三方库，仅仅读一遍还是远远不够的，除了代码的优秀，作者的设计思想也是十分优秀的，我还需要不断的学习才能达到这个高度，而至于bindActionCreators和applyMiddleware两个文件没有讲，我准备之后再来讲，外面天都黑了，非工作日一个人在办公室坐了一天，感觉周围都是寒冷😓。。。 2017年的第一篇博客over。","tags":[]},{"title":"D2总结（Fusion Design）","date":"2016-12-18T07:43:05.000Z","path":"2016/12/18/D2总结（1）/","text":"这周末去参加了D2前端技术论坛，听了这么多分享，发现有不少东西可以总结的，可是由于当天确实太累，所以没能及时整理出总结来，只好现在来慢慢回想，还好听分享时记了笔记的。 Fusion简介－－Work Smarter, Not Harder上面那句话是Fusion的代表。在页面开发中，一个前端工程师最讨厌听到的话就是，“产品或者UI说，你的按钮颜色不好看，换一下；你的这个宽度高了，改一下；你的那个边距宅了，调整一下。。。。。。” 不管别的前端怎样想的，反正我最讨厌听到类似的话，每次开发完了，产品和UI验收时都会说很多这种话（因为我做的是后台系统，没有UI稿），导致修改这些小细节也要浪费不少时间，虽然没什么难度，不过真的不想做这些东西啊。。。 这其实就是前端与UI协作中的沟通成本，UI说的一种样式，和我们前端所理解的一种样式在沟通交流中产生了偏差，导致我们开发出来的东西和最初设定的不一样。 说到这里，我想先举几个小示例。 nodejs现在为什么能那么火？就是因为它打通了前端工程师和后端工程师开发协作中的隔阂，直接让前端来写前端和后端，没有了协作问题，也没有了沟通问题；reactNative为什么现在也那么火？是因为它打通了移动端（H5，IOS，android）各个岗位的开发协作与沟通。nodejs真的特别好吗？我不知道，我只知道现在后端的主流还是java；rn是不是特别好，我不知道，因为我没用过，就算不好，但是这一点也不影响他们的伟大，他们的厉害。就因为他们解决了一些开发中普遍的痛点，打通了各个岗位之间的限制与隔阂，将协作与沟通成本直接变为了0，能不伟大？ 回到正题上来，Fusion解决的痛点是什么呢？就是前端工程师和UI设计师直接的沟通与协作问题。 这是Fusion官方的一个简介：Fusion 为设计者，前端开发者提供了一套轻松构建 DPL 的解决方案，将一套新品牌 DPL 的构建过程缩短到几不可见的程度。 并基于此建立了从设计师到前端，覆盖 DPL 从设计，开发，构建，稿件分发，代码发布的一整套完整产品链，目前已趋于成熟。通过Fusion，设计师可以直接更改页面上相对组件的样式，比如更改一个按钮的颜色，没有编程基础的设计师分分钟就可以解决，而不需要前端工程师来找到那个按钮，然后更改一下style里的color。。。 Fusion就是一套品牌可配置的中台 DPL 设计理论，它通过中台DPL可配置功能，完完全全做到了不用写一行代码，就开发出了一套新的组件。 通过一个拖拽平台和部分可配置的样式属性，就解决了这个问题，是不是很厉害呀。 （关于更加详细的介绍，可以参考现场分享出来的ppt） 续：Fusion的相关ppt已经拿到，一波三折啊～～～ https://pan.baidu.com/s/1nuIPw2d","tags":[]},{"title":"react——无状态组件和高阶组件","date":"2016-12-04T08:25:05.000Z","path":"2016/12/04/react无状态组件和高阶组件/","text":"无状态组件先来说说无状态组件吧，顾名思义，无状态组件就是指的没有状态的组件，众所周知在react中，状态指的就是state，而没有state，会有什么好处和坏处呢？ react中所有的数据，都是通过state和props来保存的，state主要是组件内部的数据交流，可以进行各种读写操作，而props主要是组件间的数据交流，一般针对props仅仅执行只读，不会做额外的操作。所以话说回来，无状态组件，没有state，那么内部的逻辑必将大大减少，编写react组件的方便性也将大大提高。 下面是一个简单的无状态组件： 1234567function Hello(props&#123; return &lt;div&gt;Hello&#123;props.name&#125;&lt;/div&gt;&#125;ReactDOM.render(&lt;Hello name=&quot;world&quot; /&gt;, mountNode)// 最后一句也可以这么写ReactDOM.render(Hello(&#123;&quot;name&quot;:&quot;world&quot;&#125;), mountNode) 通过这个简单的示例可以看到，原本需要写的react类定义（React.createClass或者class Component extends React.Component）来创建自己组件的定义，但是由于这仅仅是一个无状态组件（无状态函数），react在渲染的时候也省掉了奖react组件类实例化的过程。 所以对于一些纯静态展示的功能模块，可以考虑作为无状态组件，而无状态组件用来实现服务端渲染也是比较方便的，只要避免去获取dom节点就可以了。 无状态组件的生命周期方法我们可以看到，无状态组件就剩了一个render方法，因此也就没有实现组件的生命周期方法，例如componentDidMount, componentWillUnmount等。那应该怎么办呢？这个时候就用到了高阶组件。 高阶组件高阶组件是什么？通过函数，向现有的组件类添加逻辑，就叫做高阶组件。 之前上面已经说了，无状态组件是没有state的，所以里面基本也就没有什么逻辑，可是如果我现在需要添加逻辑了，且又想继续使用这个无状态组件，怎么办呢？那就可以使用高阶组件。 先来看看这个示例： 1234567891011121314function noId() &#123; return function(Comp) &#123; return class NoID extends Component &#123; render() &#123; const &#123;id, ...others&#125; = this.props; return ( &lt;Comp &#123;...others&#125;/&gt; ) &#125; &#125; &#125;&#125;const WithoutID = noId()(Comp); 这个例子向我们展示了高阶组件的工作方式，通过函数和闭包等方法，改变已有组件的行为，示例里面改变了id属性。 之所以称之为高阶组件，是因为在react中，这种嵌套的逻辑关系会反映到组件树上，层层嵌套就像高阶函数的function in function一样，如下图所示： 从上图可以看出组件树虽然嵌套了许多层，但是实际渲染的无状态组件中的dom结构并没有发生改变，所以我们可以放心地使用高阶组件，哪怕重复使用，也不必担心影响输出的dom结构。而借助函数的表现能力，高阶组件的用途几乎是无穷尽的。 适配器有时候你需要替换一些已有的组件，而新组件接受的参数和原组件并不完全一样. 你可以考虑修改所有原组件的代码来保证传入正确的参数——so bad。 你也可以通过使用高阶组件，把新组件做一层封装： 12345678class ListAdapter extends Component &#123; mapProps(props) &#123; return &#123;/* new props */&#125; &#125; render() &#123; return &lt;NewList &#123;...mapProps(this.props)&#125; /&gt; &#125;&#125; 如果有十个组件需要适配呢？当然，每个组件写十遍也不是不行，不过，高阶组件或许会给你一个更好的答案： 1234567891011function mapProps(mapFn) &#123; return function(Comp) &#123; return class extends Component &#123; render() &#123; return &lt;Comp &#123;...mapFn(this.props)&#125;/&gt; &#125; &#125; &#125; &#125;const ListAdapter = mapProps(mapPropsForNewList)(NewList); 借助高阶组件，关注点被分离得足够彻底，你不需要考虑组件的渲染，你只需要考虑属性的map就够了。 处理副作用在组件中，往往有很多的状态和副作用要处理，最常见的情况就是异步了。 假设我们需要异步加载一个用户列表，通常的代码会是这样的： 1234567891011121314151617181920class UserList extends Component &#123; constructor(props) &#123; super(); this.state = &#123; list: [] &#125; &#125; componentDidMount() &#123; loadUsers() .then(data=&gt; this.setState(&#123;list: data.userList&#125;) ) &#125; render() &#123; return ( &lt;List list=&#123;this.state.list&#125; /&gt; ) &#125; /* other bussiness logics */&#125; 在实际情况中，以上代码往往还会和其他一些业务函数混杂在一起，如果再来一个或多个其他的列表呢，不仅代码会重复，大量有状态和副作用的组件也使得组件难以测试。或许你会考虑使用一些数据管理工具，比如flux或redux，是的，当然可以，可是这就像大炮打蚊子，杀鸡用牛刀。所以回到这个问题上来，我们只是想做一个异步的列表，仅此而已。 使用高阶函数试试： 123456789101112131415161718192021222324252627function connectPromise(&#123;promiseLoader, mapResultToProps&#125;) &#123; return Comp=&gt; &#123; return class AsyncComponent extends Component &#123; constructor(props) &#123; super(); this.state = &#123; result: undefined &#125; &#125; componentDidMount() &#123; promiseLoader() .then(result=&gt; this.setState(&#123;result&#125;)) &#125; render() &#123; return ( &lt;Comp &#123;...mapResultToProps(props)&#125; &#123;...this.props&#125;/&gt; ) &#125; &#125; &#125;&#125;const UserList = connectPromise(&#123; promiseLoader: loadUsers, mapResultToProps: result=&gt; (&#123;list: result.userList&#125;)&#125;)(List); //List can be a pure component 可以看到，这样不仅大量减少了重复的代码，还把散落在各处的异步逻辑封装进了可以单独管理和测试的函数中，在实际业务场景中，只需要按照“纯组件＋配置”就可以实现相同的功能，而无论是纯组件还是配置，都是对单元测试友好的，至少比异步组件友好多了吧。","tags":[]},{"title":"从源码看react生命周期","date":"2016-11-08T04:22:04.000Z","path":"2016/11/08/react生命周期源码解读/","text":"React的主要思想，就是通过构建可复用的组件来构建页面，而每一个组件，就是一个有限的状态机，通过状态控制组件不同的渲染，从而得到不同的界面效果。每个组件都有生命周期，它规定了组件的一些自带方法需要在哪个阶段进行执行以及输出对应的结果。 有限状态机，表示有限个状态，以及在这些状态之间的数据转移和动作方法的执行的行为模型，一般通过状态、事件、转换和动作来描述有限状态机。例如页面上的都个东西有显示和隐藏两种情况，那么一般情况下我们会设计两个方法：show()和hide()来实现显示与隐藏的切换，而react只需要设置某一个状态为true或false，就可以实现这个组件的隐藏和显示转换了。同时，react还引入了组件的生命周期这个概念，通过它就可以实现组件的状态机控制，从而达到“生命周期－状态－组件”的和谐画面。 生命周期之前一篇博客就已经说到了一下生命周期，我在这里再赘述一下吧，react组件自带的一些函数方法，比如getDefaultProps、getInitialState等，会在什么时候执行。 当首次装载组件时，按顺序执行 getDefaultProps、getInitialState、componentWillMount、render 和 componentDidMount； 当卸载组件时，执行 componentWillUnmount； 当重新装载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps； 当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate. 然后具体的状态、属性改变，会触发什么方法，可以参考如下两张图，由于这篇博客重点不在于此，所以就不细细讲解了。 疑问： 为什么react会按照这样的方式来，这样的顺序来执行生命周期？ 为什么react多次render时，会执行生命周期的不同阶段。 为什么getDefaultProps只执行了一次？ react生命周期详解react组件的生命周期，主要通过三种状态来管理，分别是MOUNTING、RECEIVE_PROPS、UNMOUNTING，而其他的方法，例如getDefaultProps、getInitialState，还包括自己定义的一些方法等，都是通过这三个状态来管理的，这三个状态会负责通知对应的组件当前所处的状态，应该执行生命周期中的哪个步骤，比如是否可以更新state，是否能调用自定义函数等。在这三种状态中，MOUNTING指的是加载组件，RECEIVE_PROPS指的是更新组件，UNMOUNTING指的是卸载组件，而每种情况，比如说加载组件（mountComponent），都会有两种方法，will和did，will指的是之前，比如说加载之前，更新之前，而did指的是之后，表示加载之后，更新之后。 creatClass创建组件这是最react组件中的入口方法，负责管理生命周期中的getDefaultProps。getDefaultProps方法在react生命周期中只执行一次，那就是在首次加载组件初始化的时候执行。通过creatClass创建组件，利用原型继承ReactCompositeBase父类，然后按顺序合并mixins，设置初始化defaultProps，创建ReactElement元素，具体信息看看下面的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ReactCompositeComponent 的基类var ReactCompositeComponentBase = function() &#123;&#125;; // 将 Mixin 合并到 ReactCompositeComponentBase 的原型上 assign( ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin );var ReactCompositeComponent = &#123; LifeCycle: CompositeLifeCycle, Base: ReactCompositeComponentBase, // 创建组件 createClass: function(spec) &#123; // 构造函数 var Constructor = function(props, context) &#123; this.props = props; this.context = context; this.state = null; var initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; &#125;; // 原型继承父类 Constructor.prototype = new ReactCompositeComponentBase(); Constructor.prototype.constructor = Constructor; // 合并 mixins injectedMixins.forEach( mixSpecIntoComponent.bind(null, Constructor) ); mixSpecIntoComponent(Constructor, spec); // mixins 合并后装载 defaultProps (React整个生命周期中 getDefaultProps 只执行一次) if (Constructor.getDefaultProps) &#123; Constructor.defaultProps = Constructor.getDefaultProps(); &#125; for (var methodName in ReactCompositeComponentInterface) &#123; if (!Constructor.prototype[methodName]) &#123; Constructor.prototype[methodName] = null; &#125; &#125; return ReactElement.createFactory(Constructor); &#125;&#125; 所以这就解释了，为什么getDefaultProps会在react组件中很早的就被调用，且只被调用一次，因为getDefaultProps是通过Constructor来进行管理的，所以是在整个生命周期中最先开始执行。 状态一：MOUNTINGmountComponent负责管理生命周期中的getInitialState、componentWillMount、render、componentDidMount方法。 mountComponent主要做了以下一些事。 首先通过mountComponent装载组件，此时将状态改为MOUNTING，通过geiInitalState获取初始化的state，初始化更新队列为null。 然后会判断componentWillMount是否存在，如果存在，则执行componentWillMount，若此时使用了setState方法，则不会出发re-render，而是会合并更新队列，和初始化的render一起执行。 到此时，已经完成了MOUNTING的工作，将更新状态改为NULL，如果后面再使用setState方法，则会更改更新状态，然后出发render函数重新渲染。 mountComponent本质上是通过递归的方法来渲染的内容，所以如果一个组件中包含了另外的子组件的话，怎会发现，父组件中的componentWillMount总是会在子组件中的componentWillMount之前调用，而父组件的componentDidMount总是会在子组件的componentDidMount后面调用。 最后当初始化渲染完成后，若存在componentDidMount，则出触发。 这段流程的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 装载组件mountComponent: function(rootID, transaction, mountDepth) &#123; // 当前状态为 MOUNTING this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING; // 当前元素对应的上下文 this.context = this._processContext(this._currentElement._context); // 当前元素对应的 props this.props = this._processProps(this.props); // 获取初始化 state this.state = this.getInitialState(); // 初始化更新队列 this._pendingState = null; this._pendingForceUpdate = false; // componentWillMount 调用setstate，不会触发rerender而是自动提前合并 if (this.componentWillMount) &#123; this.componentWillMount(); if (this._pendingState) &#123; this.state = this._pendingState; this._pendingState = null; &#125; &#125; // 得到 _currentElement 对应的 component 类实例 this._renderedComponent = instantiateReactComponent( this._renderValidatedComponent(), this._currentElement.type ); // 完成 MOUNTING，更新 state this._compositeLifeCycleState = null; // render 递归渲染 var markup = this._renderedComponent.mountComponent( rootID, transaction, mountDepth + 1 ); // 如果存在 this.componentDidMount，则渲染完成后触发 if (this.componentDidMount) &#123; transaction.getReactMountReady().enqueue(this.componentDidMount, this); &#125; return markup;&#125; 详细流程图如下： 状态二：RECEIVE_PROPSupdateComponent负责管理react生命周期中的componentWillReceiveProps、shouldComponentUpdate、componentWillUpadte、render、compoentDidUpdate等方法。 在有组件更新时，react会通过updateComponent来更新组件，如果前后的元素不一致，则说明需要进行组件更新，此时会将状态改为RECEIVE_PROPS。 在进行组件更新的时候，react首先会检查有没有componentWillReceiveProps，如果有，则执行此函数，且componentWillReceiveProps函数中调用setState是不会重复触发render函数的，而是会进行render合并，到这个时刻，RECEIVE_PROPS的工作就已经做完了，然后将状态改为NULL，同时state也将进行更新操作，此时调用this.state，可以获得更新后的state。 然后会调用shouldComponentUpdate来作为最后的判断，判断组件是否更新，return true则会更新，否则不更新；之前已经说过了，react里的组件是通过递归来更新渲染的，而由于递归的特性，所以父组件的componentWillUpdate会在子组件componentWillUpdate之前执行，父组件的componentDidUpdate会在子组件componentDidUpdate之后执行。注意：禁止在shouldComponentUpdate和componentWillUpdate中调用setState，会造成循环调用，直至耗光浏览器内存后崩溃。 updateComponent的具体流程图如下： 下面是具体源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 更新组件updateComponent: function(transaction, prevParentElement, nextParentElement) &#123; var prevContext = this.context; var prevProps = this.props; var nextContext = prevContext; var nextProps = prevProps; if (prevParentElement !== nextParentElement) &#123; nextContext = this._processContext(nextParentElement._context); nextProps = this._processProps(nextParentElement.props); // 当前状态为 RECEIVING_PROPS this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS; // 如果存在 componentWillReceiveProps，则执行 if (this.componentWillReceiveProps) &#123; this.componentWillReceiveProps(nextProps, nextContext); &#125; &#125; // 设置状态为 null，更新 state this._compositeLifeCycleState = null; var nextState = this._pendingState || this.state; this._pendingState = null; var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext); if (!shouldUpdate) &#123; // 如果确定组件不更新，仍然要设置 props 和 state this._currentElement = nextParentElement; this.props = nextProps; this.state = nextState; this.context = nextContext; this._owner = nextParentElement._owner; return; &#125; this._pendingForceUpdate = false; ...... // 如果存在 componentWillUpdate，则触发 if (this.componentWillUpdate) &#123; this.componentWillUpdate(nextProps, nextState, nextContext); &#125; // render 递归渲染 var nextMarkup = this._renderedComponent.mountComponent( thisID, transaction, this._mountDepth + 1 ); // 如果存在 componentDidUpdate，则触发 if (this.componentDidUpdate) &#123; transaction.getReactMountReady().enqueue( this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this ); &#125;&#125;, 状态三：UNMOUNTINGunmountComponent 负责管理生命周期中的 componentWillUnmount。 首先将状态设置为 UNMOUNTING，若存在 componentWillUnmount，则执行；如果此时在 componentWillUnmount 中调用 setState，是不会触发 reRender。更新状态为 NULL，完成组件卸载操作。 具体代码如下所示： 1234567891011121314151617// 卸载组件unmountComponent: function() &#123; // 设置状态为 UNMOUNTING this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING; // 如果存在 componentWillUnmount，则触发 if (this.componentWillUnmount) &#123; this.componentWillUnmount(); &#125; // 更新状态为 null this._compositeLifeCycleState = null; this._renderedComponent.unmountComponent(); this._renderedComponent = null; ReactComponent.Mixin.unmountComponent.call(this);&#125; setState更新机制说起setState，想必用过react的都会知道吧，不过setState的更新机制，你真的知道吗？ 当你调用setState的时候，会对state以及_pendingState更新队列进行合并操作，但是，真正更新state的幕后黑手其实是replaceState。replaceState会先判断当前状态是否是MOUNTING，如果不是，则会立即调用ReactUpdates.enqueueUpdate来执行更新。 当状态不为MOUNTING和RECEIVEPROPS的时候，performUpdateIfNecessary 会获取 _pendingElement、_pendingState、_pendingForceUpdate，并调用 updateComponent 进行组件更新。 如果在 shouldComponentUpdate 或 componentWillUpdate 中调用 setState，此时的状态已经从 RECEIVING_PROPS -&gt; NULL，则 performUpdateIfNecessary 就会调用 updateComponent 进行组件更新，但 updateComponent 又会调用 shouldComponentUpdate 和 componentWillUpdate，因此造成循环调用，使得浏览器内存占满后崩溃。产生如下图的这种死循环： setState具体源码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 更新 statesetState: function(partialState, callback) &#123; // 合并 _pendingState this.replaceState( assign(&#123;&#125;, this._pendingState || this.state, partialState), callback );&#125;,// 更新 statereplaceState: function(completeState, callback) &#123; validateLifeCycleOnReplaceState(this); // 更新队列 this._pendingState = completeState; // 判断状态是否为 MOUNTING，如果不是，即可执行更新 if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) &#123; ReactUpdates.enqueueUpdate(this, callback); &#125;&#125;,// 如果存在 _pendingElement、_pendingState、_pendingForceUpdate，则更新组件performUpdateIfNecessary: function(transaction) &#123; var compositeLifeCycleState = this._compositeLifeCycleState; // 当状态为 MOUNTING 或 RECEIVING_PROPS时，则不更新 if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) &#123; return; &#125; var prevElement = this._currentElement; var nextElement = prevElement; if (this._pendingElement != null) &#123; nextElement = this._pendingElement; this._pendingElement = null; &#125; // 调用 updateComponent this.updateComponent( transaction, prevElement, nextElement );&#125; 总结： React 通过三种状态：MOUNTING、RECEIVE_PROPS、UNMOUNTING，管理整个生命周期的执行顺序； setState 会先进行 _pendingState 更新队列的合并操作，不会立刻 reRender，因此是异步操作，且通过判断状态（MOUNTING、RECEIVE_PROPS）来控制 reRender 的时机； 不建议在 getDefaultProps、getInitialState、shouldComponentUpdate、componentWillUpdate、render 和 componentWillUnmount 中调用 setState，特别注意：不能在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState，会导致循环调用。","tags":[]},{"title":"promise 详解","date":"2016-10-10T12:54:51.000Z","path":"2016/10/10/promise/","text":"虽然之前写了javascript异步编程，不过我发现周围的部分小伙伴，当然也包括我，对promise的认识还是只停留在基础是使用，类似于ajax这种的使用，或者会用promise.then()，对于原生的Promise对象只了解一点甚至不了解，我也是模模糊糊地了解，所以准备写一篇关于promise的博客，顺便也借此机会一举击破promise，不想再搞得模模糊糊的了，彻底得解决掉这个东西。 在去年，准确的说是在2015年6月（我专门查了的，肯定没有错），ECMAScript6的正式版发布了。ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ES6 的目标，是使得 JavaScript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 ES6的改变还是算不小的，其中就包含了提供Promise对象。 Promise是什么？首先，它是一个对象，它的作用是用来进行异步操作，代表着某个异步进行的事件的结果。 Promise对象有以下两个特点： （1），对象的状态不受外界的影线。Promise对象代表一个异步的操作，它包含了三种状态，分别是：Pending（进行中），Resolve（已完成），Reject（已失败）。而异步操作的结果，决定了它将会输出哪一种状态，任何其它操作都无法改变这个状态。这也是Promise名字的由来，也就是承诺的意思，代表一定会去做。 （2），一旦状态改变，就不会再变。虽然Promise不受外界影响状态，不过状态是会在内部进行改变的，它有两种改变状态的可能，一种是从进行中变为已完成（Pending to Resolve），另一种是从进行中变为已失败（Pending to Reject）。除此之外，状态不会再发生其它的变化。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 CODE“talk is cheap,show me the code”. 这是程序员界比较常见的一句话，上面很多概念啊这些死知识讲解完了，下面才开始进入正题，开始代码演示。 由于Promise已经是JS原生对象了，所以直接打开浏览器的控制台，输入Promise，就可以看到一个function Promise，如果报错的话，说明你的浏览器该升级了。 1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 如上面的基本代码所示，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject方法，如果异步操作成功了，则调用resolve方法，将Promise对象的状态从Pending改为Resolve，如果异步操作失败，则调用reject方法，将Promise对象的状态从Pending改为Reject。这是promise最基本的使用方法。 promise的神奇之处在于给了我们return和throw，每个promise都会提供一个then函数和一个catch函数，实际上是then(null,…)函数。基本代码如下： 1234promiseOne.then(function(value)&#123; alert(value); // 这个value是promiseOne中resolve传递出来的值。 // do something&#125;); 在这个then函数里面，我们可以做三件事，1，return 另一个promise；2，return 一个同步的值；3，throw 一个同步异常，‘ throw new Error(‘’) ’。 下面是一些Promise的基本API。 1234561,Promise.resolve()2,Promise.reject()3,Promise.prototype.then()4,Promise.prototype.catch()5,Promise.all([functionOne,functionTwo,...]) // 所有的完成6,Promise.race([functionOne,functionTwo,...]) // 竞速，完成一个即可 Promise.resolve和Promise.reject是Promise的静态方法，使用方法如下： 1234567891011121314Promise.resolve(&quot;value&quot;).then(function(v) &#123; console.log(v,1); &#125;, function(v) &#123; // 不会被调用console.log(v,2);&#125;);// 这时控制台会输出 value,1Promise.resolve(&quot;value&quot;).then(function(v) &#123; console.log(v,1); &#125;, function(v) &#123; console.log(v,2);&#125;);// 这时控制台会输出 value,2 也就是说，Promise.resolve里传入的参数或者promise对象，会被then方法接收，Promise.reject里传入的参数或者promise对象，会被catch方法接收，这一点在上面的new Promise((resolve,reject)=&gt;{if(…){resolve(v)}else{reject(v)}})已经讲过了，意思是一样的，不同之处在于使用的方式不同，下面的方法是直接调用的promise里的静态方法，而没有用到promise这个构造函数。 除了返回基本数据外，一个promise里面也可以返回另一个promise对象。 123456var original = Promise.resolve(true);var cast = Promise.resolve(original);cast.then(function(v) &#123; console.log(v); &#125;);// 控制台会输出 true 我们也可以在promise中抛出异常，这里有同步代码异常和异步代码异常两种。 这是同步代码异常，直接调用promise的reject方法，传入一个error就好了： 1Promise.reject(new Error(&quot;什么鬼&quot;)); 下面是异步代码异常： 12345new Promise(function (resolve, reject) &#123; throw new Error(&apos;悲剧了，又出 bug 了&apos;); &#125;).catch(function(err)&#123; console.log(err); &#125;); 如果有多个callback函数连续回调，可以分别写成promise的状态，然后在每一个promise对象中return下一个promise，for example: 123456789101112131415161718192021222324252627282930313233343536373839var p1 = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;);var p2 = new Promise((resolve,reject)=&gt;&#123; resolve(p1);&#125;);var p3 = new Promise((resolve,reject)=&gt;&#123; resolve(p2);&#125;);p3.then(function(v) &#123; console.log(v); // true&#125;);// 上面是promise链式调用的一种情况，下面是另一种情况，其核心原因都是差不多的。var p1 = (resolve,reject)=&gt;&#123; resolve(1);&#125;var p2 = (resolve,reject)=&gt;&#123; resolve(2);&#125;var p3 = (resolve,reject)=&gt;&#123; resolve(3);&#125;new Promise(p3).then(function(v) &#123; console.log(v); return new Promise(p2).then((v)=&gt;&#123; console.log(v) return new Promise(p1).then((v)=&gt;&#123; console.log(v) &#125;) &#125;)&#125;)","tags":[]},{"title":"javascript异步编程（续）","date":"2016-09-20T11:49:07.000Z","path":"2016/09/20/javascript异步编程（续）/","text":"之前那篇文章讲解了javascript异步式编程的几个方法，比如有回调函数，promise，发布／订阅模式，generator函数等，每一种方式，在其广泛使用的时期，都是很完善的一种方式，不过由于时代的进步，技术的发展，缺点总会暴露出来，更好更完善的方法也会被创造出来。 这篇文章，我就想来说说async函数。 ES7意见征集稿中提供了async函数，这是什么？其实可以用一句话来概括，async函数就是Generator函数的语法糖。 我们从Generator函数开始，代码如下。 123456789101112131415161718192021222324252627// 这是采用fs模块来异步读取文件var fs = require(&apos;fs&apos;);var readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;// 这是使用generator函数的方法，依次读取两个文件var gen = function* ()&#123; var f1 = yield readFile(&apos;/etc/fstab&apos;); var f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;;// 下面是async函数的写法var asyncReadFile = async function ()&#123; var f1 = await readFile(&apos;/etc/fstab&apos;); var f2 = await readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;; 其实一比较，差异很明显，async函数就是将generator函数的星号替换成了async，将yield替换成了await。 仅此而已！仅此而已？ 虽然加入了比较好看的语法糖，不过一个新的方法如果只是比老的方法命名好听，有什么意义呢？下面我来说一下async函数和generator函数的主要区别吧。 更好的语义。既然都看出来了，那最明显的当然是标志符换了，也就是更加语义化了，await和async比星号跟yield更加让人好理解。 更好的适用性。generator函数的执行必须依靠执行器，或者人为的多次调用next方法才能继续执行下去，而async是自带执行器的，这是什么意思呢？意思就是你再也不用管什么next了，也不用管怎么异步执行了，你完完全全就可以把async函数就当做普通的函数来看来，当你想执行的时候，只需要一句var result = async();就可以了，她会自动调用async函数并且自动执行，输出最后结果，你现在可以将什么next方法啊，co模块这些全部放一边了。 返回值是promise。async函数的返回值是promise对象，这比generator函数的返回一个Iterator对象方便多了，你可以使用promise里的then方法来进行下一步的操作。而async函数完全可以看作是多个异步的操作，包装成了一个promise对象，而await就是then方法的语法糖。 下面是一些async函数的具体使用示例。 1，下面代码中，函数f中return的数据，会被promise的then方法的回调函数获取到，所以then方法回调函数里的参数v就是指代的f函数的return的数据，所以控制台才会打印出hello world 123456async function f() &#123; return &apos;hello world&apos;;&#125;f().then(v =&gt; console.log(v))// 打开控制台，你就会看见有一句hello world（前提是你的浏览器支持async） 2，async函数内部抛出错误，会导致返回的promise对象变为reject状态，抛出的错误对象，会被catch方法的回调函数捕捉到。 123456789async function f() &#123; throw new Error(&apos;出错了&apos;);&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 3，async函数返回的promise对象，必须要等到内部await命令的promise对象执行完，才会发生状态的改变，换句话说，也就是async函数内部的await命令执行完了，才会执行then方法的回调函数。如下面的例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log)// &quot;ECMAScript 2017 Language Specification&quot; 4，在正常情况下，await后面应该是一个promise对象，如果不是，那么会被转变为一个立即resolve的promise对象。 123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123，这里await后面的123虽然不是promise对象，不过它会转变为promise对象并立即被resolve，所以在后面的then方法的回调函数里，依然可以正常的运行。 5，async函数返回的promise对象，如果变为了reject状态，则reject的参数会被catch方法的回调函数接收到，示例如下： 12345678async function f() &#123; await Promise.reject(&apos;出错了&apos;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了。上面的await前面没有return语句，但是reject状态的参数依然传入了catch方法的回调函数里，所以说这里有没有return都是不影响的，不过为了统一与规范，还是建议加上。 6，只有程序发现了一个promise函数的状态变为了reject，那么后面的代码将不会执行。 123456789101112131415161718192021222324252627282930313233async function f() &#123; await Promise.reject(&apos;出错了&apos;); await Promise.resolve(&apos;hello world&apos;); // 这句将不会执行&#125;// 所以为了避免这种情况发生，可以将第一个await放在try...catch...语句中，这样代码的执行就不会被中断。async function f() &#123; try &#123; await Promise.reject(&apos;出错了&apos;); &#125; catch(e) &#123; &#125; return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// hello world// 另一种解决办法就是在await后面的promise对象加上一个catch方法，来处理前面可能会出现的错误，代码如下。async function f() &#123; await Promise.reject(&apos;出错了&apos;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world// 当然，我们也可以将多个await命令放进catch方法里，这段代码就省略了。。。 7，如果await后面的异步操作出错，那么就等同于promise对象状态变为reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&apos;出错了&apos;); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面说了那么多的示例，都是比较片面的讲解使用中的注意事项，完整的示例来讲解async函数的使用方法，所以我下面会主要讲async函数的使用。 1，上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 12345678910async function getStockPriceByName(name) &#123; var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; console.log(result);&#125;);// 最后打印出的这个result就是getStockPriceByName函数中return的stockPrice。 2，下面代码指定50毫秒以后，输出”hello world”。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value)&#125;asyncPrint(&apos;hello world&apos;, 50); 十一国庆节来公司基本没人，后背也感到一阵阵凉风，这篇博客就先讲到这里吧，有什么完善的地方后面我会再继续补充的。","tags":[]},{"title":"javascript异步编程","date":"2016-09-09T12:29:36.000Z","path":"2016/09/09/javascript异步编程/","text":"最近nodejs看得有点多，感觉满脑子都是文件处理，异步编程，buffer等，发现学node学多了，前端用到的javascript也会更加豁然开朗，特别是廖雪峰和阮一峰老师的博客，给了我不小的帮助。我想从nodejs开始说起，毕竟这才是编程的核心，现在发现前端用的js只是熟练运用onclick事件等，自己以前还是只接触到了皮毛啊。 回到主题，据传当初Ryan Dahl选择js来作为后台语言时，主要就是看重了js的单线程，同步运行，适合一些高并发的场景，这就从侧面说明了js这门语言的特性：同步，单线程。那么可以多线程异步编程吗？答案当然是肯定，那么，js异步编程有哪几种方法，这几种方法各自的优缺点又如何呢？ 说到这里，我又想解释一下同步与异步，第一次听到这两个词语，就要得追溯到大学的操作系统课堂了，OS的运行机制（运行模式）分为同步（Synchronous）和异步（Asynchronous）。 “同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。”异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。 所以针对js的异步编程方法，我准备讲解如下几个方法： 一，回调函数这是异步编程最最最基本的方法，几乎所有能异步编程的语言都可以用到这个方法。回调函数的具体意思是，假设有两个函数，a和b，函数a在前b在后，正常情况的话，程序运行到了函数a，会等待其执行完毕，然后拿到函数a的运行结果，才会继续执行函数b；那么这时，问题就来了，如果函数a运行一秒，我可以等，运行十秒，就难以忍受了，万一函数a卡住了，永远成功不了，你会等到海枯石烂吗？哈哈哈，那怎么办，我下面还有千千万万行的代码啊，辛辛苦苦写了那么久，还没运行到这里，就结束了，逗我啊。。。这个时候，就该回调函数上场了，把函数b写成函数a的回调函数，像这样： 1234567891011121314// 原来的代码a();b();// 采用回调函数function a(b)&#123; setTimeout(function()&#123; // a的代码 b() &#125;,1000);&#125; 采用这种方式，我们把同步操作变成了异步操作，a不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 那么问题就来了，学。。。不对，这会产生什么问题？如果回调函数比较多会怎样？ 123456789101112// 在前一个动画执行完成后，紧接着执行下一个动画$(&apos;xx&apos;).animate(&#123;xxxx&#125;, function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; ... &#125;,1000) &#125;,1000) &#125;,1000) &#125;,1000)&#125;,1000) 是不是觉得很傻，代码毫无可读性而言，不过，这是最基本的js异步编程的方法。 二、promise有了最基本的方法，就会有很多人不满足，想做出优化，写个第三方库啊或者发各种包，各种模块什么的。 最有名的，莫过于promise了，做为前端，大名鼎鼎的jQuery肯定不会不知道吧，说起jQuery，要说的就太多了，赶紧收住。jQuery里的ajax方法，就是典型的参照了promise设计出来的产物，其使用方法是： 12345$.ajax(&#123;// 配置参数&#125;).done(function(retData) &#123;...&#125;); 这是一套典型的jQuery版的ajax应用方法，后面的done，就是指的前面做完了，返回一个结果retData来，然后再执行其它操作。 在es6中，已经正式出台了promise对象，其基本用法如下： 123a().then(b).then(c)... 是不是一下子就简洁了很多？当然，这个也不能说是完美的异步编程解决方案，只能说是完善罢了，其优点确实是简化了不少代码，不过也有不足的地方，那就是维护比较麻烦，因为这样的话，异步多了，你一眼看过去，将会看到一堆的then。。。是不是很尴尬啊，代码的可读性一下子就降低了，你满脑子的then。 三、观察者模式说起这个，又要回到大学的操作系统课堂了，算了，不浪费时间了，直接进入正题。 观察者模式，你可以理解为，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。 这个方式的实现有很多的插件，就拿我们最熟的jQuery来说好了。 1234567891011// 函数b订阅done信号jQuery.subscribe(&quot;done&quot;, b);function a()&#123; setTimeout(function () &#123; // a的任务代码 // a执行完毕后，发布done信号，然后b接收到了done信号，就开始执行b函数 jQuery.publish(&quot;done&quot;); &#125;, 1000); &#125; // 当然，你也可以取消订阅信号的事件，这样的话，以后done信号发布，b函数就不会执行了。 // jQuery.unsubscribe(&quot;done&quot;, f2); 这个也有一点可以优化的地方，就是发布和订阅的消息太多时，不好管理，事件会太杂乱，有一个整体管理事件的中心就更好了。 四、generatorGenerator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。其核心意思就是，一段代码执行到某个节点时，暂停执行，然后执行另一段代码，有等了会，再回过头来执行第一段代码剩下的部分，总的来说就是几个代码片段交替执行。 说到这里我觉得现现在generator函数并没有被广泛的大面积的运用，所以先花点时间来介绍下generator函数吧。talk is cheap，show u the code. 1234567function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; 上面的代码中，调用generator函数，会返回一个内部指针（也叫遍历器），就是这里的g，所以说当你直接调用generator函数的时候，它并不会直接返回结果，而里面的yield字段，就表示异步操作需要暂停的地方，通过g指针调用next方法，指针就会开始异动到下一个yield（或者return）的地方去，并且返回当时暂停时所得到的结果value,以及遍历状态done。 下面来看看如何使用generator函数来执行一个真实的异步任务。 123456var fetch = require(&apos;node-fetch&apos;);function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result.bio);&#125; 这里我们通过发送请求，然后输出请求返回的结果，去掉yield命令，就完完全全是同步的了，所以这也是yield的一个比较大的特点，对代码改动小，保持代码可读性。。。话说回来，现在声明了这个函数，如何使用呢？使用方法如下： 1234567var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 发现已经写了好多了，看来一次性写完确实太累啊，留下一个acync函数下次再写吧。","tags":[]},{"title":"vue.js 组件快速入门（一）","date":"2016-09-05T09:24:12.000Z","path":"2016/09/05/vue.js 组件入门（一）/","text":"前几天读了一篇好文章，vue组件化，这篇算是我自己提炼出来的的归纳与总结吧。 在前端开发中，以前我们会把常用的公共的方法（函数）提取出来，整合为一个库，最有名的当属jQ了吧，然后到了react出现，这些类库主要都是针对view层进行的操作与封装，我们又可以把view层面上的一些东西抽出来进行封装和整理，比如一个table，一个button，一个div等，也可以像曾经提取函数一样抽出来，写成公用的，在需要使用的地方直接引入就可以了，当然，也可以根据你实际运用的需要进行适当的自定义配置，而这些被抽出来共用的table，button，div这些，就叫做组件。 上面是我自己瞎扯的，原文作者讲得比较繁琐，所以我就用自己的语言来概述了一下，虽然这篇文章是我转载的，不过我也参考了其它的文章／博客，知识点的相似度接近80%，但是语言基本上都是我自己重新组织的，所以加了很多自己的想法和思考，下面我们开始进入正题。 ###vue组件，创建与注册的基本步骤。 vue组件的使用，有三个步骤，分别是创建组件，注册组件和使用组件，如下图所示。 我们可以用一段代码来演示这三个步骤： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.创建一个组件构造器 var myComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos; &#125;) // 2.注册组件，并指定组件的标签，组件的HTML标签为&lt;my-component&gt; Vue.component(&apos;my-component&apos;, myComponent) new Vue(&#123; el: &apos;#app&apos; &#125;); &lt;/script&gt;&lt;/html&gt; 运行结果很简单，就是一句“This is my first component!”，可以看到，使用组件和使用普通的HTML元素没什么区别，你可以就把组件当做一个HTML元素来使用。 要理解组件的创建和注册，我们可以用一下几个步骤来详细解释： Vue.extend()是Vue构造器的扩展，调用Vue.extend()创建的是一个组件构造器，而不是一个具体的组件实例。 Vue.extend()构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的HTML。 使用Vue.component()注册组件时，需要提供2个参数，第1个参数时组件的标签，第2个参数是组件构造器。 Vue.component()方法内部会调用组件构造器，创建一个组件实例。 组件应该挂载到某个Vue实例下，否则它不会生效。 我们一句一句来分析，先是创建一个组件，代码是 123myComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos;&#125;) 创建组件很简单，直接调用vue构造器的扩展方法就行了，里面会传入一个对象，对象里面有个template属性，它指代的是这个组件的view的内容，是不是像react里面的render函数啊，它也是return的view内容，它们有哪些不同呢？毕竟学习知识要针对各种不同的但是有类似的知识点来进行归纳，整理和综合，才能进行融会贯通的运用。毕竟古人云：学而时习之，不亦悦乎！ 好了，这是创建，下面是注册了，注册也很简单，一句代码就搞定了：Vue.component(‘my-component’, myComponent);，使用Vue.component方法，传入两个参数，第一个参数是你想注册的组件名，第二个参数是你创建的组件名，是不是有点混淆？先是你通过Vue.extend创建了一个组件，名字叫myComponent，然后为了在HTML中能够当做标签来使用，你需要给你创建的这个组件注册一个组件名，名字叫做my-component，所以你在HTML就可以直接把你注册的组件名当做HTML标签来使用，像这样就可以了。现在组件创建好了，也注册好了，可是还不能直接使用，因为还需要new一个Vue实例，才能使用，像这样 123Vue(&#123; el: &apos;#app&apos;&#125;); 一个Vue实例接收一个对象，里面的el属性是你组件的挂载节点，于是我又情不自禁地联想到了react，ReactDOM.render( dom , root)，就像这样，react也是将一个view界面的虚拟dom挂载到一个root节点上，而这里的Vue同样，需要将刚才的组件也挂载到某个节点下，这两者之间的异同后面再说吧，先说一点主要的，vue里的节点指的是vue组件的作用域，这点是和react差异比较大的一点，你将vue组件挂载在了某个节点下，意思是这个组件只有在这个节点范围内才可以使用，至于是使用多次，使用一次，还是一次都不使用，都没问题。而我们这个实例上，就是挂载在了id为app的节点上，所以在这个节点的范围内都可以使用的形式，来调用vue组件myComponent。同理，如果你想在多个节点的作用域内使用某个vue组件的话，那你就得多new几次，把组件的挂载到多个节点下面就好了，而如果在没有实例化的组件中非法调用某个vue组件，它将不起任何作用。详细情况可以看以下代码： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app1&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;div id=&quot;app2&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;div id=&quot;app3&quot;&gt; &lt;!--该组件不会被渲染--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var myComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;This is a component!&lt;/div&gt;&apos; &#125;) Vue.component(&apos;my-component&apos;, myComponent) var app1 = new Vue(&#123; el: &apos;#app1&apos; &#125;); var app2 = new Vue(&#123; el: &apos;#app2&apos; &#125;) &lt;/script&gt;&lt;/html&gt; 在上面代码中，我们创建了一个名叫myComponent的vue组件，然后注册了一个名叫my-component的组件来当做HTML标签使用，最后我们实例化时，只在id=”app1”和id=”app2”中挂载了这个vue组件，而在实际使用的时候，我们在id=”app3”中也使用了这个组件，所以最后，只有id=”app1”和id=”app2”的div中组件成功地被替换成了“This is a component!”，而id=”app3”中的标签将不会被渲染。具体效果如下图所示： 好了，一个基本的vue组件的一整套流程基本就完全是这样了，any problems else？我知道，现在还有很多的问题没有解决，比如创建组件，注册组件和实例化挂载到某个节点下，整体步骤比较繁琐；注册组件的时候可以局部注册吗；组件可以嵌套吗？如果可以，如何嵌套；vue组件怎么怎么做成可扩展的？又怎样变为自定义配置呢？ 我下一篇博客再细细道来。","tags":[]},{"title":"express实现","date":"2016-09-03T08:25:56.000Z","path":"2016/09/03/node express实现/","text":"express是node里面一个十分常用的库，用它来搭建服务器，事半功倍，且小巧灵活，有足够多的特性，用来进行各种网页开发。 我们先来看下express的使用的，毕竟知己知彼，百战不殆。 123456789101112131415161718192021//引入express，确保你的项目依赖了express库，否则的话先npm install一下var express = require(&apos;express&apos;);//执行express函数，var app = express();// 使用get方法，当请求的路由是hello时，返回helloapp.get(&apos;/hello&apos;, function (req, res) &#123; res.send(&apos;hello&apos;);&#125;);// 当请求的路由是world时，返回worldapp.get(&apos;/world&apos;, function (req, res) &#123; res.send(&apos;world&apos;);&#125;);// 当请求的路由是其它时，返回“没有找到匹配的路径”app.get(&apos;*&apos;, function (req, res) &#123; res.setHeader(&apos;content-type&apos;,&apos;text/plain;charset=utf8&apos;); res.end(&apos;没有找到匹配的路径&apos;);&#125;);// 最后监听端口var server = app.listen(3000, function () &#123; console.log(&apos;正在监听3000端口&apos;);&#125;); 上面或许就是express最常见，也是最基本的使用吧，启动了一个服务器并且监听3000端口，对/hello的路由返回“hello”，对/world的路由返回“world”，对其他的路由返回“没有找到匹配的路径”。 示例看完了，下面我们来看看具体的实现吧，在这之前，我想说一下http这个模块，毕竟express就是对http进行了一下封装，既然想看看express的内部，当然就离不开http了。 123456var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.end(&apos;Hello World\\n&apos;);&#125;).listen(3000, &apos;127.0.0.1&apos;);console.log(&apos;正在监听3000端口。&apos;); 就上面这几行，就已经成功地实现了一个简单的服务器了，我们可以分拆一下。1http.createServer(function(...)&#123;...&#125;).listen(3000); 现在，我们再回过头来看看express。 1234567891011121314151617181920// 首先，声明express函数var express = function () &#123;&#125;;// 它的内部应该有一个app函数，用来作为实例。var express = function () &#123; var app = function(...)&#123;...&#125;&#125;;// 这个实例还应该有很多的方法，比如get，listen等。（本来我是想用es5的方式写的，后来发现好久没用那种方法，写function写得太累了。。。）var express = ()=&gt; &#123; var app = (req,res)=&gt;&#123;...&#125;; app.listen = (...)=&gt;&#123;...&#125;; app.get = (...)=&gt;&#123;...&#125;;&#125;;// 最后，为了能够完成链式调用，所以我们返回这个实例app，然后exports一下，就完成了。var express = ()=&gt; &#123; var app = (...)=&gt;&#123;...&#125;; app.listen = (...)=&gt;&#123;...&#125;; app.get = (...)=&gt;&#123;...&#125;; return app;&#125;;module.exports = exports = express; 这就是express基本的框架，如果后续有什么扩展的，也可以直接在里面增加一个函数就好了，= (...)=>&#123;...&#125; ```，接下来，我们来慢慢分析里面的构造。12先看一个最简单的吧，listen方法。 app.listen = function (port) { require(‘http’).createServer(app).listen(port);};12是不是发现了什么？再上去看一眼http，是不是很相似啊。。。没错，就是这样的。 http.createServer(function(…){…}).listen(3000);``` 而中间的app函数，对应的就是http.createServer的参数了。感觉这个listen函数应该不需要多讲。","tags":[]},{"title":"react, es5 or es6 ?","date":"2016-08-25T08:07:53.000Z","path":"2016/08/25/react es5还是es6 ？/","text":"随着es6的逐渐普及，新的语法糖，对我们以前写js的习惯也有着不小的冲击，比如说我好久都没写过function这个词语了，取而代之的是“=&gt;”箭头函数，var也基本不用了，现在用let，以及其他等等。 但是对于写react，es5和es6的变化，还是稍微有一些不同的，“talk is cheap,show the code”。 这是es5的写法： 12345678910111213141516171819202122232425262728var InputControlES5 = React.createClass(&#123; defaultProps：&#123; initialValue：&apos;&apos; &#125;, propTypes：&#123; initialValue：React.PropTypes.string &#125;, // Set up initial state getInitialState：function() &#123; return &#123; text：this.props.initialValue || &apos;placeholder&apos; &#125;; &#125;, handleChange：function(event) &#123; this.setState(&#123; text：event.target.value &#125;); &#125;, render：function() &#123; return ( &lt;div&gt; Type something： &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 下面是es6的写法： 1234567891011121314151617181920212223242526272829303132class InputControlES6 extends React.Component &#123; constructor(props) &#123; super(props); // Set up initial state this.state = &#123; text：props.initialValue || &apos;placeholder&apos; &#125;; // Functions must be bound manually with ES6 classes this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123; text：event.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; Type something： &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;InputControlES6.propTypes = &#123; initialValue：React.PropTypes.string&#125;;InputControlES6.defaultProps = &#123; initialValue：&apos;&apos;&#125;; 一下是一些关键的不同点： 创建方式不同es5是通过creatClass来创建的react组件，而es6是通过class extends来创建的，或许这是最直接的嫩个发现的差异吧，毕竟这在第一行。 函数的绑定话说以前，我修改过别人用es6写的react代码，我习惯在每个函数后面加上一个逗号，然后我在render函数中增加了一个事件，对应执行的函数是this.xxx，结果呢？报了一堆的错（包括之前的逗号），“this.xxx is undefined.”，当时我还不知道es6与es5的差异，当时就一脸无辜的表情，然后没办法，我把别人的代码全部用es5重写了一遍，并且当时表示以后都会一直使用es5的方式来写react。唉，人的一生，自身的努力很重要，但是也要考虑到历史的进程。。。于是我也就做了一点微小的工作，也开始采用es6的方式来写react了。 好了，说回正题，es5使用的是creatClass的方式来创建react组件，每一个函数都会自动被react绑定，所以就不会有“this.xxx is undefined.”这样的报错了。但是es6的class就不同了，你在render函数里使用到的this.xxx函数，都需要自己手动去构造函数中绑定它们，当然，你也可以通过插件来自动绑定，还有一种方式就是你可以在调用这个函数的地方，直接增加bind(this)来进行绑定，比如这样来绑定this。 上面的几种方式都可以绑定this，不过在性能上来说，却还是有一定差距的。首先是引入第三方库来自动绑定，如果是一个比较大型的项目，引入一个比较小的库，来解决比较多比较繁琐的bind的问题，还是可以的，不过前提是项目比较大，需要在引入第三方库和人为绑定之间权衡利弊。剩下的方法就是在构造函数里绑定this还是在render函数里绑定this，工作量其实是差不多的，但是这里涉及到一个生命周期的问题，构造函数，在整个react声明周期里，只会调用一次，但是render就不一样了，任何组件的任何属性改变或者状态改变，都可能处罚render函数来重新渲染，所以render函数一般是会执行多次的，既然执行多次，那么里面的bind(this)自然也是会执行多次，这与在构造函数里只执行一次来比，当然就会慢一些。有没有更好的办法呢？我在文章开始就说过了，es6有一个比较明显的特性就是箭头函数，它是会自动绑定this的，你可以在定义函数的地方直接使用箭头函数，代码如下： 12345handleChange = (event) =&gt; &#123; this.setState(&#123; text: event.target.value &#125;);&#125; 这样的话，也就不用考虑绑定this的事情了，是不是很方便啊。 构造函数中的superes6的constructor需要接收props，并且调用super(props)，这是相对于es5所改变的一点，这个记住就行了。 初始化state在es5中，react组件初始化的时候会执行一个getinitialState函数，而es6中却不是这样，在调用super之后，会直接设置一个this.state的对象来初始化，this.state = {…}。 getdefaultProps和propTypes和初始化state一样，在es5中，也有一个函数来单独初始化props，就是getdefaultProps，而es6就是用上面的那个super方法，es5中可以直接在这个函数下面接着写propTypes来限定接收的参数的类型，而es6就不一样了，它将propTypes直接放在了react组件之外，因为这些将会是类本身的属性，所以需要放在类的外部来单独定义。es7易经又将定义属性改回了类的内部，不过这个还没普及。 1234567891011class Person extends React.Component &#123; static propTypes = &#123; name: React.PropTypes.string, age: React.PropTypes.string &#125;; static defaultProps = &#123; name: &apos;&apos;, age: -1 &#125;; ...&#125; 用哪个方法才好？Facebook已经声明了React.createClass将最终会被ES6的classes替代，但是他们也说“在我们找到当前mixin所使用的例子的替代者以及在语言上支持类属性的初始化器前，我们不打算废弃React.createClass”。 在任何可以使用无状态函数式组件的地方使用它。简单而且会强制性地简化你的组件。 对于一些需要state，生命周期方法或是通过ref来操作潜在的DOM节点的复杂组件来讲，请使用class。 尽管知道这三种写法风格很棒，但在StackOverflow或者其他地方查找解决方案时可能仍会看到一些混杂着ES5和ES6写法的答案。ES6风格已经非常流行了，但这不会是你看到的唯一一种写法。","tags":[]},{"title":"vue todo示例","date":"2016-08-21T09:03:14.000Z","path":"2016/08/21/vue todo/","text":"最近抽空看了下vue，一个轻量级的前端框架（类库），它采用的mvvm模式，且数据双向绑定，刚好官方网站上有一个todo实例，我感觉和redux的todo实例很类似，所以准备将这两个框架的todo实例分别解读一下，来比较一下个中异同。 这个代码就两部分，先是html：123456789&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &lt;span&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt; &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 接下来是js代码： 123456789101112131415161718192021new Vue(&#123; el: &apos;#app&apos;, data: &#123; newTodo: &apos;&apos;, todos: [ &#123; text: &apos;Add some todos&apos; &#125; ] &#125;, methods: &#123; addTodo: function () &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125; &#125;, removeTodo: function (index) &#123; this.todos.splice(index, 1) &#125; &#125;&#125;) 我第一次看到这段代码的时候觉得有点诧异，就这么点代码就实现了一个todo list，比react少了好多，如果是redux的todo list，别说代码，文件夹数量就可以让你一双手数不过来，而这vue两个文件夹一共才这么点代码，下面来仔细看看这个代码吧。先看下html代码吧，除了原生的html代码外，这里有几个vue特有的属性，显而易见，所有以v开头的属性，都是vue特有的属性，比如这里的v-model=”newTodo”，v-on:keyup.enter=”addTodo”，v-for=”todo in todos”，v-on:click=”removeTodo($index)”，一共就这四个吧，而就是字符串模版了，从js文件的某个对象中获取数据来填充到页面上。js代码也很少，估计一共才十多行，抛去中间的内容不看，就成了new Vue({})了，很显然这就是new了一个Vue实例，算是初始化，然后我们再来对内容一行一行地解读。 1el: &apos;#app&apos; 先看一下app在html文件里指代的是什么，一看便知，app在这里指代的是最外层div的id，而这里的＃应该类似于jQuery选择器中的符号吧（所以我猜测这里也可以用“.app”来选择class为app的元素来作为Vue的容器），前面的el应该指的是element吧。再看下面： 123456data: &#123; newTodo: &apos;&apos;, todos: [ &#123; text: &apos;Add some todos&apos; &#125; ] &#125; 这个data很明显说明了这里面装的是数据，我们可以看到这里一共有两条数据，一条是newTodo的数据，类型是字符串，另一条是todos数据，类型是数组对象，然后我们现在再返回html中，查看那里用到了这两条数据的，可以看到v-model=”newTodo”，所以我们暂时可以知道具有v-model属性的这个input输入框和newTodo这条数据绑定了起来，至于是单向绑定还是双向绑定还是仅仅是初始化的时候绑定一次，我们现在还不知道，接着看下面的todos，v-for=”todo in todos”，可以明白的知道，这是个for遍历，类似于for(i in object)一样，而这里的意思就类似于在todos这个数组中遍历一下，然后在li标签内对遍历到的数据进行操作，下面就用到了字符串模版，将需要的数据提取出来就好了。继续往下面看： 123456789101112methods: &#123; addTodo: function () &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125; &#125;, removeTodo: function (index) &#123; this.todos.splice(index, 1) &#125;&#125; 这部分是methods，按照字面意思来看，叫做方法，也就是js中的函数（function），可以看到里面一共包含了两个function，一个是addTodo，另一个是removeTodo，回顾html文件，可以知道调用这两个函数方法的地方分别是v-on:keyup.enter和v-on:click，前一个就是类似于原生的onKeyup方法，而第二个就是onClick了，不过keyup后面跟了enter，说明这个keyup方法是和enter健绑定的，现在我们可以进入这两个函数内部看看，看它具体的实现方法。 1234567addTodo: function () &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125;&#125; 这个函数中主要是在针对this.newTodo进行操作，我们不难发现，newTodo这条数据是和v-model这个属性绑在一起的，然后这个属性又是和input输入框绑定在一起的，所以可以表明这里的this.newTodo指的就是input输入框里的值，然后再将其去除首尾空格，push进todos列表，最后再清空输入框。而我们再来看下另一个函数： 123removeTodo: function (index) &#123; this.todos.splice(index, 1)&#125; 这个函数更简单，就一句话，执行一个数组操作，删除数组的某一项，而这个函数的调用在这里：v-on:click=”removeTodo($index)”，可以看到在调用的时候传入了一个参数$index，这指的是对应的li标签的index，然后当点击的时候，就可以通过index来删除这个li标签了。 说了这么多，我知道，理工科的东西讲再多的道理都是十分抽象的，所以最后我还是上几张图吧，为了能够更好的理解。 图1这是初始化的时候，一切都为空。 图2然后我在输入框里输入数据，按下enter键。 图3可以看到，下面列表中多了一条数据，是我刚才输入的数据。 图4然后我又输入了几条数据，一共三条。 图5最后我删除其中一条，就删除第二条吧，点击右边的那个小叉就可以了，可以看到这条就被删了，其他的数据不变。","tags":[]},{"title":"hexo博客增加搜索功能","date":"2016-08-19T13:42:59.000Z","path":"2016/08/19/hexo-search/","text":"最近在用在某个项目上增加一个搜索框，后端用node＋mongodb实现，本来以为挺简单的，就用node爬一下页面title和href，然后放进mongodb中，再通过前端发请求传数据过来查找，然后node再在mongodb中查找，将数据返回前端。 这是理想情况下的做法，可是现实往往充满了曲折,下面我来简单介绍下这个项目，然后说一下问题吧。 这是个内网项目，所以爬虫爬不进去，好在有一个目录页，将所有页面的title和href整理了起来，不过读取这个文件也不是简单的事，因为这个是类似于json格式的文件，但是却没有任何的符号，全是汉字，而我们存储的时候是需要分层次的，这样利于查找，采用node的FS模块可以很容易地读取到文件的内容，但是仅仅是读取，直接存储的话会导致没有层次感，所以我就把这个文件复制了一份出来，通过人工维护的方式将其变为json格式，然后就很好操作了，不过需要人工维护与更新，不算是最好的办法，但是那个文件之前也是人工维护的（虽然我不知道是谁维护，否则可以叫他一起维护下）。 这是个hexo博客系统，纯静态展示的，所有页面均是通过通过hexo的框架，执行hexo g命令的时候，会自动将md文件解析成html（css），然后再通过执行hexo server命令，开一个hexo的服务器，把所有的页面通过服务端渲染到浏览器；因此，我增加的这个搜索框的功能，除了需要自己写服务器和数据库外，还必须把这个项目单独部署，因为hexo的源码上并没有针对服务器的扩展方法（这一点是@南烛帮我一起看的，毕竟我之前对hexo的了解只是会用而已，并没有在它的源码上进行深入研究），因此，这就成为了两个项目，然后把这两个项目部署在同一台服务器上，再通过配置nginx服务，将搜索框从前端发来的请求映射到node服务器监听的那个端口，这样就形成了前后端数据的交互，这里出现了一个比较奇怪的问题，我在我自己电脑上发送请求时，请求能够成功发出去，可就是接收不到返回的内容，然后我从另一台电脑通过花瓶代理请求到我本地来测试接口，却发现是正常的，最后发现是两个项目之间的请求跨域了。 解决跨域，可以选择将项目部署在服务器，然后再测试，不过这就比较麻烦了，修改bug比较蛋疼，或者使用代理，将请求代理到另一个域来，这样修改bug也比较简单，现在开始发请求了，发现查找结果是没有数据，没关系，我刚刚只是随便输入的一个词，现在我输入一个数据库里存在的词重新发送请求，不过问题就出来了，还是没有数据，怎么可能啊，数据库里确实有这个数据啊，怎么会查不到，于是我换了几个数据库里存在的词，再反复查找，结果大多都是不存在，唯一存在的一个是一个英文单词，然后我就查看请求，发现地址没错，参数呢？参数怎么自动给我转码了，我就好奇了，然后我再去后台将这个获取到的请求参数，对比了一下接收到各种参数的情况，发现汉字会自动转码，数字和英文单词会保持不变，但是当查询的字符串中间出现空格的时候，会自动变为加号来填充空格，所以，只有无空格的数字或英语字母才可以直接查找到结果，否则的话都需要人工再进行一次转码，将其转过来，唉，毕竟第一次写服务器，这些都需要靠自己独自摸索。 接下来是mongodb的事情。之前使用百度搜索还是谷歌搜索，我都没发现什么大的问题（可能是我搜索的问题太傻了），这次查询mongodb和mongoose的相关资料，发现百度搜索出来的都是以一些博客，百度知道的回答为主，且各个博客之间相互抄袭也是够无聊的，仅仅只是做到了制造而不是创造。然后我就去谷歌采用英文搜索，stackoverflow，官方网站等都是排在很前面的（不知道百度为什么把人家官网排在很后面），算了，不吐槽了。mongodb这种非关系型轻量级数据库，使用起来是很方便的，增删查改的api都是比较简单的，根据所示范的例子动手稍微写一下就会用了，不过对于第一次使用的我来说，还是遇到了一些问题：存储的时候，mongodb会自动给你加上下划线id，我估计是为了区分存储空间，可是这就会存在一个问题，当我存储了一条数据过后，再储存一条相同的数据进去，是可以存储进去的，因为它们的下划线id不同，这显然不对啊，我否则我一查找，却找到很多条数据，仔细一看却发现这么多条数据都是一样的，不是很搞笑吗，所以我选择了给每条数据加上一个index作为唯一标志符，然后再在每次启动的时候，去读取文件存储进数据库里，存进去之前会先去数据库里通过这个index唯一标志符查找一遍，如果查询结果为空，我才会把这条数据存进去，否则就不存。其实吧，每次存储的时候会人为的自动查找，相当于遍历了一遍数据库，如果是在正常的稍微大一点的项目来说，这是十分十分十分影响性能的，由于我这里是个很小的项目，所以才可以进行这种方式查询；其次是mongo查找的时候，默认的方式是精确匹配，不支持模糊查询，这怎么办呢，难道需要我在查询的时候再遍历一遍数据库，使用indexOf来查询？我感到很可笑，因为你这么傻的方法在实际中是肯定行不通的，再说了，就算可以，那么大小写的模糊查询怎么办？难道要我判断下有没有英文字母然后分别用用大写和小写都来遍历一下？这个时候就可以使用正则了，将查询的字符串改变为正则表达式，这样的话在数据库里它会自动的去匹配所有适合的结果。","tags":[]},{"title":"redux 店铺装修","date":"2016-07-28T06:33:08.000Z","path":"2016/07/28/react demo/","text":"最近在做店铺装修，很很很麻烦的一个项目，刚好里面用到了redux，我发现店铺装修简化一下的话，简直是redux的十分好的一个示例啊，比官网上简单的示例要难，又比难的简单，而且条理结构什么的又很清楚，挺不错的啊。 我先上图吧。图1图2图3图4图5图6图7图8 好吧，这图截的也是够大的，将就看看吧。。。由图1可以看到，页面一共分为四部分：左，中上，中下，右，也就是氛围四个组件：Left，Top，Center，Right。接下来我说一下交互，如图2所示；我在左边的输入框中输入东西，然后点击增加，可以看到，刚刚新增的数据立马在右边下面部分显示了出来，展示的是刚才新增的数据和一个删除按钮，如图3所示；若你点击展示的数据，那么在右边，也就是编辑组件中会出现一个输入框和编辑按钮，你可以在这里对刚刚点击的数据进行修改然后保存，如图4，图5所示；保存过后就可以看到中间的显示模块对数据进行了更新，如图6所示；接下来是中间上方的保存模块，你点击保存按钮，这个模块同样也能取到当前的数据，这里就用一个弹窗代替好了，如图7所示；最后就是删除按钮，点击后删掉当前这一行的数据，如图8所示。 好累，说了这么多，口都干了。其实吧，一两句话就可以说完的：在这四个组件中，每个组件都可以取到state，并且可以对state进行操作。说完了，是不是很简单啊。。。 我们先来看看index.js吧，也就是入口文件。 12345678910111213141516var App = React.createClass(&#123; render: function()&#123; return ( &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; &lt;LeftComponent /&gt; &lt;/div&gt; &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; borderRight: &apos;1px solid #999&apos;, minHeight: &apos;600px&apos;, textAlign: &apos;center&apos; &#125;&#125;&gt; &lt;TopComponent/&gt; &lt;CenterComponent/&gt; &lt;/div&gt; &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; &lt;RightComponent /&gt; &lt;/div&gt; &lt;/div&gt; ); 很简单吧，就是分别放了四个Component组件而已，我们也不用管这些组件是父子关系还是兄弟关系，因为redux不用考虑这些。然后我们去看看action吧。 12345678910111213141516171819202122232425262728// action module.exports = &#123; addModelAction: function(name)&#123; return &#123; type: &apos;ADD_MODEL&apos;, name: name &#125; &#125;, editModelAction: function(index, name) &#123; return &#123; type: &apos;EDIT_MODEL&apos;, index: index, name: name &#125; &#125;, deleteModelAction: function(index) &#123; return &#123; type: &apos;DELETE_MODEL&apos;, index: index &#125; &#125;, activeModelAction: function(index) &#123; return &#123; type: &apos;ACTIVE_MODEL&apos;, index: index &#125; &#125;&#125;; 在action.js这个文件里，我们写了四个action函数，每个函数都返回一个对象作为action，是不是很简单，每个action函数中返回的对象里type都是定义好了的，然后根据传入的参数来配置其他返回参数；然后再来看看reducer。 123456789101112131415161718192021222324252627// reducersvar modelReducer = function(state, action)&#123; switch(action.type)&#123; case &apos;ADD_MODEL&apos;: state.items.push(&#123; name: action.name &#125;); return state; break; case &apos;DELETE_MODEL&apos;: state.items.splice(action.index, 1); return state; break; case &apos;EDIT_MODEL&apos;: state.items[action.index].name = action.name; return state; break; case &apos;ACTIVE_MODEL&apos;: state.activeIndex = action.index; return state; break; default: return state; &#125;&#125;;module.exports = modelReducer; 这个也不难，我们都知道reducer需要传入两个参数：state和action，通过action里的type来对state进行相应的操作，最后return state。 好了，reducer和action都看了，redux三要素现在来看看store。 1234import &#123; createStore &#125; from &apos;redux&apos;import modelReducer from &apos;./reducer&apos;var store = createStore(modelReducer, &#123;items: [], activeIndex: -1 &#125;);module.exports = store; 对的，一共就这几行，store=createStore(modelReducer, {items: [], activeIndex: -1 })，第一个参数是reducer，必需的，另一个是state初始化的值，非必需，若不传则默认为undefined。 其实到这里，这个示例就已经到了尾声了；剩下的就是这四个组件的内部布局，还有就是给按钮绑定事件，当点击的时候用dispatch分发一个对应的action函数给reducer，这些我在之前也已经写过了，所以这里就不再赘述了。","tags":[]},{"title":"react生命周期解读","date":"2016-07-24T06:54:34.000Z","path":"2016/07/24/react生命周期/","text":"前几天在工作中出现了一个比较怪异的bug，不过还好由于react的单向数据流，从最外层父组件一层一层地往里面找，在每一层都检查一下state和props的值是否正确，总会找到问题，只不过那个组件被前人嵌套了四五层，所以在定位问题的时候比较蛋疼，所以还是最好养成良好的习惯，组件嵌套层级不要太多，而且在开发的时候每一层就别忘了检测props和state，否则后来人会很累的。。。 经过了long long time，才在某一层组件中找到了问题，具体问题是父组件传入的props改变后子组件通过props来渲染的页面没有发生改变，有疑问吗？父组件传入的props改变，子组件的props不是会自动接收变化并且render吗？嗯，是的，为什么这里没有呢。。。原来有人在开发的时候在getInitialState函数中加了这么一句：this.state.xxx = this.props.xxx，通过这样，他就把props和state关联了起来，心中顿时有无数草泥马狂奔。。。怎么改呢？难道要我把和state关联了的props都取消关联？这个工作量不小。。。还好，react里有个监测props变化的函数：componentWillReceiveProps，然后我再在里面把更新后的props和state关联起来，让state等于新的props就好了，大功告成，这个怪异的问题就解决了。 有人会觉得奇怪吗？为什么在getInitialState函数中使用了this.state.xxx = this.props.xxx，而在当props更新后传进来时，state依然等于原来的props，这就说到了本片文章的主要，就是react的生命周期。 react组件的详细说明和生命周期先来说一下react场见的函数吧。 1，render 重要的事情说三遍：render()方法是必须的！render()方法是必须的！！render()方法是必须的！！！ 当使用render方法的时候，它最终return一个单子级组件，这个意思就是说返回一个dom 组件，比如一个 div 节点，也可以是其他自定义的组件，有个要点就是一定只能 return 一个 dom 组件，当你有多个单独的dom节点或者单独的自定义组件要 return 的时候，必须要在外面包裹一层 div 才行。当然，你也可以返回 null 或者 false 来表明不需要渲染任何东西。在 return 前会干什么呢？return 的作用是渲染页面的，而渲染页面需要数据react 里的数据主要就是 props 和 state，所以在 render 方法中，它先会自动监测 props 和 state，render 方法有几个需要注意的点：1，render 函数中不能修改 state，所以 setState 方法是不能用的；2，render 并不是渲染真是的 dom ，而是 Virtual DOM，所以在这个方法中，你并不能对 dom 进行操作，this.getDOMNode()也去不到任何节点，只能得到 null。3，不和浏览器交互，例如通过使用 setTimeout。 2，getInitialState 这是初始化state的方法，仅仅在组件挂载之前调用一次！ 3，getDefaultProps 在组件创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 this.props，（可以使用 in 来检测属性）。该方法在实例创建之前调用，因此不能依赖于 this.props。 4，componentWillMount 这个方法会在初始化渲染完毕之前立即调用，仅执行一次。可以使用 setState 方法。 5，componentDidMount 这个方法会在初始化渲染完毕之后立即调用，仅执行一次。这个时候已经渲染完毕了，所以 Virtual DOM 已经成为了真实的 DOM，你可以使用 this.getDOMNode()方法，发送 ajax 请求，或者 setTimeout 等方法。 6，componentWillReceiveProps 该方法仅仅在组件接收到新的 props 的时候调用。所以初始化的时候不会调用这个方法，传入的参数将是即将接收到的新的 props，一般会通过新老 props 比较，然后再决定需不需要更新页面。 7，shouldComponentUpdate 当组件接收到了新的 props 或者 state 的时候，即将要渲染页面之前调用这个方法。按常规来说，组件 state 或 props 更新后，往往都是需要重新渲染一下页面的，当然，这不是百分之百，所以这个时候就需要在渲染之前，在判断一下，是否真的需要渲染，在这个方法中可以获得 nextProps 和 nextState，然后我们可以比较，看是不是真的需要渲染，如果需要渲染，就return true，不需要渲染就 return false，这个方法默认是会返回 true 的。这个方法存在的意义就是不该渲染的时候不渲染，节约时间优化性能，当然，组件少了也没什么实际意义，可是当组件数量成百上千的时候，或许就会很明显地感觉到优化的性能了。 8，componentWillUpdate 这个方法主要是在接收到新的 props 或者 state 之前立刻调用，使用该方法做一些更新之前的准备工作，此时不能更改 state。 9，componentDidUpdate 个人觉得和componentDidMount类似，只是一个在初始化渲染后调用，一个在更新渲染后调用。 10，componentWillUnmount 在组件从 DOM 中移除的时候立刻被调用，在该方法中执行任何清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。 唉，好累，终于把这一大堆函数科普完了，我稍微归纳一下吧，方法大致有以下几类：初始化的时候执行的，初始化渲染前执行的，初始化渲染后执行的，接收更新时执行的，接收更新后渲染之前执行的，接收更新后渲染之后执行的，即将移除前执行的。这么多方法，都是和执行时间有关，并且一个方法后往往会执行另一系列的方法，这就是它的生命周期。 所以回到上面的问题，当父组件的 props 更新后，子组件的 props 也会更新没错，但是这时并不会重新去执行一次 getInitialState 方法，因为这个方法仅仅在初始化的时候调用一次，所以最后 render 时还是用的之前的 state 来进行渲染，所以我做的就是加上 componentWillReceiveProps 来进行人为更新 state。 这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。 上面两张图分别是各个不同的变化会产生的不同的一系列的方法调用，，以及每个方法是否能够对 state 进行更新都做了说明，可以看到，初始化的时候，props 变化的时候，state 变化的时候，都会触发不同方法来进行处理，有的函数是可以不写的，因为它默认会执行，经过上次改bug的事情后，我觉得吧，层级多了的时候还是最好在每个层级里面对 props 和 state 进行控制监测一下，以免发生不必要的错误。","tags":[]},{"title":"redux example(1)","date":"2016-07-23T08:48:01.000Z","path":"2016/07/23/redux example(1)/","text":"最近在学习redux，看了不少相关的资料，发现这个官方教程的一些例子还是很不错的，由浅入深各个档次都有，所以我稍微看了下，准备有时间的话将示例都自己弄懂，然后分别写篇详细的解读出来，由于是临时起意，所以今天先写第一篇吧。 counter-vanilla这是redux中的第一个示例，也就是说是最简单的一个例子，不多说了，先看看代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Redux basic example&lt;/title&gt; &lt;script src=&quot;https://npmcdn.com/redux@latest/dist/redux.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; Clicked: &lt;span id=&quot;value&quot;&gt;0&lt;/span&gt; times &lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button id=&quot;incrementIfOdd&quot;&gt;Increment if odd&lt;/button&gt; &lt;button id=&quot;incrementAsync&quot;&gt;Increment async&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; function counter(state, action) &#123; if (typeof state === &apos;undefined&apos;) &#123; return 0 &#125; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1 case &apos;DECREMENT&apos;: return state - 1 default: return state &#125; &#125; var store = Redux.createStore(counter) var valueEl = document.getElementById(&apos;value&apos;) function render() &#123; valueEl.innerHTML = store.getState().toString() &#125; render() store.subscribe(render) document.getElementById(&apos;increment&apos;) .addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;) document.getElementById(&apos;decrement&apos;) .addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;) &#125;) document.getElementById(&apos;incrementIfOdd&apos;) .addEventListener(&apos;click&apos;, function () &#123; if (store.getState() % 2 !== 0) &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125; &#125;) document.getElementById(&apos;incrementAsync&apos;) .addEventListener(&apos;click&apos;, function () &#123; setTimeout(function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;, 1000) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如上面代码所示，一共也就几十行，而且就这一个文件，毕竟是最基础最简单的一个示例，所以也没有什么文件结构和包依赖，以及到node服务器等，，唯一的一个依赖也通过了script标签引入。不废话了，下面开始讲解一下代码吧。 dom结构就很简单吧，主要就是一个span标签包裹一个数字，然后就是几个button按钮，点击按钮的时候会让span标签里的数字增一、减一、奇数加一变为偶数、异步加一（也就是加个定时器延迟）。 下面来看script标签里的代码，也就是实现逻辑和功能的主要代码。 12345678910111213function counter(state, action) &#123; if (typeof state === &apos;undefined&apos;) &#123; return 0 &#125; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1 case &apos;DECREMENT&apos;: return state - 1 default: return state &#125;&#125; 这段代码主要实现的是reducer，它主要接收两个参数，一个是state，另一个是action，state指代的是react中的state（状态），也就是这里span标签中的数字，action是一个对象，通过action，reducer就知道该做什么，比如这段代码就是通过判断action.type，来对state进行操作。 这里有一个值得注意的点，那就是给state设置一个return的默认值，一般来说就写成function counter(state = initialState, action)，es6的写法，意思在忘了传state的时候给state传入一个默认值。 var store = Redux.createStore(counter) 上面这句代码，主要实现的是用createStore方法，创建store，而传入的参数counter我上面已经说过了，是一个reducer，所以store的创建实际上是这样的：var store = createStore(reducer)。 整个应用，只能有一个store！可是，reducer却可以有多个，这样问题就来了，由于创建store的时候需要传入reducer，而store只能有一个，但是reducer却可以有多个，那怎么办？]react-redux中又一个管理reducer的方法，叫做combineReducers，它能把所有的reducer集中整合为一个reducers，其使用方法是： 1234var reducers = combineReducers(&#123; reducers1, reducers2...&#125;) 关于react-redux的具体细节后面再说。 123456var valueEl = document.getElementById(&apos;value&apos;)function render() &#123; valueEl.innerHTML = store.getState().toString()&#125;render()store.subscribe(render) 这段代码就主要就是执行render函数了，store.getState() 函数，它将会返回state。如果是常规react的render函数的话，是将一个dom节点挂载到root element下面去，而在这个示例中，只要将状态挂载到对应的节点上去就可以了。最后一行代码是注册状态监听器，在这里指当store里面的state发生改变时，触发render回调函数 12345678910111213141516document.getElementById(&apos;increment&apos;).addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;)document.getElementById(&apos;decrement&apos;).addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;) &#125;)document.getElementById(&apos;incrementIfOdd&apos;).addEventListener(&apos;click&apos;, function () &#123; if (store.getState() % 2 !== 0) &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125; &#125;)document.getElementById(&apos;incrementAsync&apos;).addEventListener(&apos;click&apos;, function () &#123; setTimeout(function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;, 1000) &#125;) 这段代码主要是给下面的各个按钮绑定事件，这里需要做的是分发action，通过store.dispatch(action)这个方法，把action传递给reducer，而reducer中已经定义好了具体的函数，会根据接收到的action来判断对state进行什么操作。 好了，第一个示例到此就基本结束了，下面我再好好地整理一下redux的具体流程： 1，通过createStore方法创建store，传入reducer参数，且一个应用只能有一个store。store常用的方法有：getState方法，用来获取state；dispatch方法用来分发action，subscribe方法用来注册监听器执行回调函数。 2，创建好store后，通过dispatch方法来分发action给reducer，action是一个对象。 3，reducer接收到了state（state可传可不传，但是要在reducer中写上没有传state时的情况判断），action后，会根据action里的type属性来对state进行对应的操作。 我描绘一下redux的流程图，大致这样的：const store = createStore(reducer) –&gt; store.dispatch(action) –&gt; reducer(state, action) –&gt; 根据state渲染页面","tags":[]}]