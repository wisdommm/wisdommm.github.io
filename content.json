[{"title":"js常见手写系列","date":"2020-08-08T07:25:33.683Z","path":"2020/08/08/js常见手写系列/","text":"1234567891011121314151617// 一，filterArray.prototype.newFilter = function(fn , context)&#123; if( !Array.isArray(this) )&#123; throw Error(&apos;not array&apos;); return; &#125; let res = []; let arr = this; for(let i = 0 ; i &lt; arr.length ; i++)&#123; let tmp = fn.call(context , arr[i] , i); if(tmp)&#123; res.push(tmp); &#125; &#125; return res;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284// 二，mapArray.prototype.map = function(fn)&#123; if( !Array.isArray(this) )&#123; throw Error(&apos;not array&apos;); return; &#125; let res = []; let arr = this; for(let i = 0 ; i &lt; arr.length ; i++)&#123; let tmp = fn( arr[i] , i , arr); res.push(tmp); &#125; return res;&#125;// 三，call/applyFunction.prototype.newCall = function(obj , ...args)&#123; obj = obj || window; bj.fn = this; let res = obj.fn(...args); delete obj.fn; return res;&#125;Function.prototype.newApply = function(obj , arr)&#123; obj = obj || window; bj.fn = this; let res = obj.fn(...arr); delete obj.fn; return res;&#125;// 四，newfunction newOption(fn,...args)&#123; if(typeof fn !== &apos;function&apos;)&#123; throw Error(&apos;not function&apos;); &#125; let obj = &#123;&#125;; obj._proto_ = fn.prototype; let res = fn.apply(obj , args); return typeof res === &apos;object&apos; ? res : obj;&#125;// 五，bindFunction.prototype.newBind = function(context , ...args1)&#123; let self = this; let fNOP = function()&#123;&#125; let fBound = function(...args2)&#123; self.apply( this instanceof fBound ? this : context , args1.concat(args2) ); &#125; fNop.prototype = this.prototype; fBound.prototype = new fNop(); return fBound;&#125;// 六，防抖// 简易版function debounce(fn , wait)&#123; let timer = null; let context = this; return function(...args)&#123; clearTimeout(timer); setTimeout(()=&gt;&#123; fn.apply(context , args); &#125;,wait) &#125;&#125;// 完全版function debounce(fn , wait , immediate)&#123; let timer; let result; let debounced = function(...args)&#123; let context = this; if(timer) clearTimeout(timer); if(immediate)&#123; let callNow = !timer; timer = setTimeout(()=&gt;&#123; timer = null; &#125;,wait) if(callNow)result = fn.apply(context , args); &#125;else&#123; timer = setTimeout(()=&gt;&#123; fn.apply(context , args); &#125;,wait); &#125; return result; &#125; debounced.cancel = function()&#123; clearTimeout(timer); timer = null; &#125;&#125;// 七，节流// 简易版function throttle(fn , wait)&#123; let context = this; let prev = 0; let timer = null; return function(...args)&#123; clearTimeout(timer); let now = +new Date(); if(now - prev &gt; wait)&#123; prev = now; fn.apply(context , args); &#125; else &#123; timer = setTimeout(fn, time); &#125; &#125;&#125;// 完全版function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125;; return throttled;&#125;// 八，deepClone深拷贝function deepClone(obj)&#123; if(typeod obj !== &apos;object&apos;)return; let newObj = obj instanceof Array ? [] : &#123;&#125;; for(let i in obj)&#123; if( obj.hasOwnProperty(i) )&#123; // shallowClone // newObj[key] = obj[key]; // deepClone newObj[i] = typeof obj[i] === &apos;object&apos; ? deepClone(obj[i]) : obj[i]; &#125; &#125; return newObj;&#125;// 九，数组flattenfunction flatten(arr)&#123; if( Array.isArray(arr) )return; let res = []; for(let i in arr)&#123; if(arr[i] instanceof Array)&#123; res = res.concat( flatten( arr[i] ) ); &#125;else&#123; res.push(arr[i]); &#125; &#125; return res;&#125;// 十，实现一系列函数，能够达到如下调用：one(add(two())) 输出 3；two(add(one())) 输出 3。function add(...args1)&#123; return function(...args2)&#123; return args1.concat(args2).reduce((a,b)=&gt;a+b); &#125;&#125;function one(fn)&#123; return fn ? fn(1) : 1;&#125;function two(fn)&#123; return fn ? fn(2) : 2;&#125;// 十一，instanceoffunction instanceof(left , right)&#123; left = left._proto_; let prototype = right.prototype; while(true)&#123; // 核心原理是，在实例对象上不断通过_proto_在原型链上查找，看是否能找到原型的prototype if(!left)return false; if(left === prototype)return true; left = left._proto_; &#125;&#125;// 十二，实现一个EventEmitter，支持on、off、once、emit事件class EventEmitter&#123; constructor()&#123; this.list = &#123;&#125;; &#125; on(name , fn)&#123; if(!this.list[name])this.list[name] = [fn]; this.list[name].push(fn); &#125; off(name , fn)&#123; if( this.list[name] )&#123; let index = this.list[name].indexOf(fn); index &gt; -1 ? this.list[name].splice(index , 1) : null; &#125; &#125; once(name , fn)&#123; let self = this; this.on(name , one); function one(...args)&#123; fn.call(self , ...args) self.off(name, one); &#125; &#125; emit(name , ...args)&#123; if(this.list[name])&#123; this.list[name].forEach(fn=&gt;&#123; fn.call(this , ...args); &#125;); &#125; &#125;&#125;// 十三，数据双向绑定//es5版，核心是对象描述符 Object.defineProperty(obj, &quot;value&quot;, &#123; get: function () &#123; return value; &#125;, set: function (newValue) &#123; value = newValue; // 当数据进行改变，触发对应的响应事件 // 。。。 &#125; &#125;);// es6版，核心是proxylet handler = &#123; set(target , key , value)&#123; target[key] = value; // Reflect写法 Reflect.set(target, key, value)； &#125;, get(target , key)&#123; return target[key]; // Reflect写法 return Reflect.get(target, key); &#125;&#125;let p = new Proxy(&#123;&#125; , handler);// p.value = 123// p.a","tags":[]},{"title":"会员（用户增长）业务这几年","date":"2020-07-29T03:45:39.225Z","path":"2020/07/29/会员业务这几年/","text":"会员运营本质还是要围绕用户需求 在会员领域里，学到了对的道理，真的可以过好这一生。","tags":[]},{"title":"AI智能化","date":"2020-07-01T05:25:22.744Z","path":"2020/07/01/AI浪潮来临，拥抱智能化/","text":"这是我在大部门分享的一个卷积神经网络的一个ppt，一共有三讲左右，这是第一讲，由于这里不方便放keynote，所以就放在语雀吧，地址在这里：https://www.yuque.com/yinyingxian/dptfgb/mk6vla","tags":[]},{"title":"写在2020初（2019总结）","date":"2020-03-29T09:38:17.756Z","path":"2020/03/29/写在2020初/","text":"这本来是一篇2019的总结，不过在2020年初，一次加班压测后的车祸，改变了很多，接着是全中国新冠病毒引起的肺炎疫情，让我在医院过了这辈子最特殊的一个新年，每天在病房里望着窗外，突然就不想做年末总结了，或许我要复盘的不仅仅我这一年，而是需要复盘我这一辈子。 感谢首先是感谢，感谢媛媛那么辛苦的照顾我，特别是后面看了灏阳拍的照片，发现当我在病床上昏迷时，你累得趴在病床的护栏上睡着了，真的很心疼，一想到你冬天雨夜的凌晨五点起床，拿着我的大羽绒服跑到医院来，真的很难想象，小小的你哪来这么大的毅力，每次想到这里，眼泪都会止不住的流，当我得知你在我出事后连续照顾我48小时没合眼，我是真的憋不住了，所有的情绪所有的眼泪所有的难过，都发泄了出来，那一瞬间，我觉得，这辈子要找的人，已经确定了，这个世界上，除了父母，我的眼里只有你了。 还有彬哥和灏阳，虽然平时没发现这么“啰嗦”，当我出事后，跑到医院来，同时后面隔三差五还不断打电话来询问情况，很是感动，特别是我说我可以在家办公后，还为了保险，强制性让我多休息了一周，部门里每天白天晚上还分别有一个同学来照料我，大家所有的帮助，我将铭记于心，以后用行动来好好报答。 还有我对接的产品、运营、ued、开发、测试等，真的十分感谢，特别是夕尘，当听到我出事后，当天晚上的别墅party立即取消，损失了几千元的别墅费不说，还立马带着部门一起来医院看我，后来我醒来后，发现整个病房已经被鲜花水果这些堆满了，能和大家一起合作，真是我的荣幸。 还有就是我的父母和妹妹，真的没想到，他们千里迢迢从重庆到杭州来也就算了，居然还带了这么多的东西，特别是我爸带来的两大包肉，媛媛说她拿一包就已经十分费力了。。。去年是十分忙碌的一年，我和家里的联系也少了很多，经常父母在微信上找我的时候，我都是在公司加班，一年都没怎么和家里聊过天，没关心关心爷爷奶奶的身体，没关心父母的压力，没关心妹妹的学业，在病床上想到这里，觉得自己好惭愧，不是一个合格的孙子、儿子、哥哥，总是以工作忙为接口，现在觉得，工作再忙，其他事情再重要，和自己的家人比，也是不能比的，一个人心中占据首要地位的，必须是自己的家人，因为我们遇到任何困难的时候，能拼尽一切保护我们的，只有自己的家人。 遗憾上面是意外之后的一些感触，不过也有些遗憾，就是19年那么拼命的一年，本想在最后2、3个月在技术上好好出一些结果，争取能够去晋升一把，没想到被这意外打乱了所有节奏，结果大家看到的就是拼命带业务的我，虽然天猫超市成立事业部后第一年的会员业务确实广受好评，包括我本人也被运营在邮件里点名表扬，不过我也知道，仅仅是带业务，去晋升还是比较没有说服力的，还是希望有一点技术产出更站得住脚，这点彬哥给我说过，我也给他说过我后面两个月左右的规划，谁知道意外果然来得比明天要早，不过这里还是要感谢狂雪，他都给我说了两次了，分析我今年晋升的概率怎样怎样，其实这些我又何尝不知道，我只是想要业务+技术两手都抓紧，这样晋升也会更加稳固一点，只是没想到，他还给媛媛也说了，分析了一堆我晋升的概率啥的，说我可能性很大，可是谁也没想到这个意外来得这么突然，直接减少了我两个多月接近三个月的产出，在此，我说一句对不住了，兄弟，今年没有办法晋升，等我晋升了，请你吃大餐。 未来和媛媛一起买房、结婚、生子，这是铁打的事实，我给灏阳也这样说，这无非是时间问题而已，当我春节在病房里和媛媛视频时，她以为我是特别疼痛才哭，所以心疼得跟我一起哭了，其实她不知道，我哭只是因为太想她了，自从认识她以后，从没分开过这么长时间，平时春节也就一周，而这次因为疫情，居然一个多月，和媛媛视频时自己眼泪就不自觉地流了出来，害得后面一周她都不敢和我视频，都是文字了，说哭肿了眼睛不好看。 然后是工作，经历了繁忙和意外的一年，没想到2020年是更加意外的，我的业务和产品同学虽然没变，不过人数更加多了，不知道会不会更加繁忙，反正有这么一群好伙伴，再累也没事，给自己的上下游（产品、业务、测试、ued、后端和客户端）带来更多的价值，不是值得高兴吗？不过再忙也不要忽略家人，这点要时刻提醒自己。 最后，20年的晋升是无望了，加把力，21年晋升p7吧，为了我自己，以及我爱的家人和我可爱的同事们，大家一起加油！","tags":[]},{"title":"展望 5G","date":"2019-05-02T07:26:05.059Z","path":"2019/05/02/展望5G/","text":"（本文仅针对5G在应用层面，对社会带来的改变，关于一些波长、波段、频率、基站、运营商等事情，这里不做介绍） 2019年1月10日，工信部宣布发放5G临时牌照，拉开我国5G商用建网的大幕，2019年也是5G产业进入全面商用的关键一年，全球5G网络的部署已经启动，各个国家，各个运营商都在拼命竞争中。 现在全世界都在转型数字化经济，而5G网络带来的改变，将会把世界拉入一个新的阶段，翻开新的篇章。 对用户端简单而言，就是用户体验的再一次飞跃，直接点说就是网络情况会更好，所以下面针对这个网速相关情况的优化（比如网速快、延时短、稳定性高等），来头脑风暴一下。 我喜欢通过类比的方式来描述，以交通方式为例，我们从以前的骑马、马车，到近现代的自行车、船、火车，再到汽车、动车、高铁、飞机、火箭等，交通方式的不断发展，人类社会也在不断地进步；而到了现在数字化时代，互联网就是那一条信息道路，网速就是上面的交通工具，你用1G网络上网，就像你在道路上走路，2G网络上网，就像是骑自行车，3G就是汽车，4G就是火车，而即将到来的5G，很多人就认为其是飞机，可以做到你想去哪，立即就去。 由于本人经历原因，只知道3G到4G时候的变化，可以先简单回想一下其中的改变然后再来展望4G到5G的进化。 或许对于大多数互联网人来说，3G到4G时的变化都会很深刻，因为刚好促进了PC互联网社会转型到移动互联网社会，why？这中间有什么关系嘛？这里面关系可大着呢，以前流量又贵又慢，就像你在信息公路上开车，但是车速却不能超过20km/h，路还十分的拥堵，所以很多人还是喜欢去PC上，毕竟有线宽带的体验发展了这么几十年，效果还是不错的，但是有个问题，就是有线PC的缺点，价格贵、笨重、不灵活、PC门槛比手机高等，都是问题，所以导致有线网络的普及率一直不高，据新闻报道，2018年中国的智能机普及率就已经达到68%，而智能机普及率全球排名第一的韩国，居然高达94%，这是多么恐怖的一件事（不知道韩国的小康率达到94%没有，反正中国我估计是没有，高层说2020年中国彻底消灭贫困人口，进入全面小康，目测有点难。。。扯远了），我觉得这里面核心原因有两点：一是人与人的交流越来越多，每个人也都会选择更方便、灵活的方式，这是最基本的人性，以前写信的时候，一个月收到对方一封信，有了电脑的时候，可以天天给对方发邮件，但是现在有了手机，每分每秒你都可以和别人文字、语音、视频交流，只要你愿意的话；二是价格，不管是手机价格还是网络资费，都随着社会的发展，技术不断提升使得资费不断降低，作为我这个年纪的人，大家应该都不会忘记动感地带5元30m的流量套餐吧？如果放在现在，按照5元30m的标准，你耍抖音、快手，或是逛逛淘宝，打几局王者荣耀和吃鸡，少说也是几百m没了吧，轻轻松松一天消费好几十元的流量，所以抖音快手也是搭着4G无线化的福利，如果倒退好几年，我根本不敢用流量打开这些软件，而且现在只能手机的价格不断降低（或许苹果还是这么贵，不过你需要看的不是某一个品牌和某一款手机，你看看整体），几百块一千出头一个的智能手机到处都是，比如1000以下的红米，打王者荣耀等游戏毫无问题，但是电脑现在普遍还是好几千一台，价格门槛降低，也就提高了普及率，然后就造就了欣欣向荣的移动互联网行业，君不见移动互联网最火的2014年左右，好多公司靠着一个app就融资无数，还有更多的公司靠着ppt融资，现在靠着小程序容易的不也是这样吗？ 雷布斯有言道：站在风口上，猪都能飞起来。而我们需要做的，就是找到那个风口并且站过去。 说了这么久3G到4G，现在我们来幻想一下5G的情况，也就是说在网络情况更上一个台阶的基础上，人们的生活，我们的社会又将会发生怎样的改变。毕竟谁都知道，这又将会是一个大的风口。 从基础开始说吧，随着网速变快，人们信息交互的介质也在不断变化，从文字、语音、图片、视频影像等，以后会不会发明出更新的一种介质来作为信息交流的承载呢？同时在现有的上面优化这是完全可以确定的，比如从高清进化到超清，再到蓝光、原画等等，这已是毋庸置疑的未来， 所以我们可以畅想（不是幻想，未来正在来的路上）一下，假设某一天视频全部到了原画阶段且网络时延在1ms左右，社会会怎么变？天啊，我感觉我说十天十夜都说不完。首先，就在视频影像（包括ar、vr）阶段，以后打电话说不定都不是语音或者视频了，而是可以直接面对面全息影像进行沟通，虽然对方离你十万八千米，但是一个高精度的全息影响就站在你身边，除了你不能切实地抓到对方外，其他和真人毫无差别，你也不再需要坐在家里看电视环游世界了，这种高精度的还原，让你和真实的体验差别不断缩小。到时候我们的手机和电视电脑等，肯定全部都是可以展示全息影像的，这又将会是一个行业的巨变；同时，这将会是对整个社会的颠覆（颠覆一词可能短时间来看有点夸张，长时间来看绝对没问题），医疗、教育、安保、交通、工业等，将全部进行改革进化；医疗上，依托于高精度的全息影像，医生远程做手术将会变得可行，普通的病将不需要再去医院，医生直接通过全息影像就可以知道你是什么病，然后直接把要吃什么药告诉你就好了；教育上，现在公开课已经有不少了，如果以后，在你家里看公开课的感觉简直和就在哈佛大学的教室里听世界顶级教授上课的感觉一样，是不是学校也没必要了（或者教室可以变小，因为大多数人都会在家里直接上课）？在工业和安保上，将会更加智能化，很多难度高的事情，危险度高的事情，将会由机器代替人类来完成，比如拆弹，或者很多工业上的高精尖工作，甚至是交通上的开汽车开火车开飞机，都将会有人为远程控制+系统程序一起来完成（这些事情其实现在已经存在了，不过还没有大规模普及，里面涉及到网络、硬件、软件的综合发展）。 再来说下和互联网有关的，网络速度快了，互联网绝对是第一收益的行业，就互联网从业人员来说，是不是以后就可以不用考虑网络优化了？？？比如在IE6、7时代，大多数程序员还要考虑兼容IE6，但是你看现在，还有几个程序员在兼容IE6？ 还有一点就是云服务，一切都将上云，现在的信息量，所有的手机/电脑存储已经很吃力了（用户端），如果网速再上一个台阶，普通用户的电脑/手机存储是远远不能满足的，且现在云服务大多是针对B端用户和一些C端的开发者使用的，对一些普通C端用户来说，根本不知道那是什么，所以云服务后面应该会有一波大的爆发，针对普通C端用户；我们甚至可以再想得极端一点，5G的理论速度是20Gbps，相当于20000m/s，以现有内存/硬盘/ssd来看，到那个时候全部报废，那个时候我从网上下载一部5000吗的电影只需要0.25秒，我从本地打开居然要3秒，所以要么那个时候的存储行业全部跟着革新换代，要么就是像柯达一样在历史的洪流中化为尘埃。当然，这只是理论速度，长期来看肯定会有达到的一天，至于全社会，整个国家上云后，所产生的其他隐私/安全问题，个人而言，国家应该会创办一个国家的公共云服务，或者对现在社会上企业的云服务进行强力监管，这里就先不深入讨论。 最后，就是觉得社会瞬息万变，时代的洪流汹涌而来，有成王败寇，也有风口的猪，不由得想起三国演义的篇头词语：滚滚长江东逝水，浪花淘尽英雄。","tags":[]},{"title":"新零售智能硬件-终端前端调试技巧","date":"2018-12-09T06:39:05.000Z","path":"2018/12/09/零售终端测试技巧/","text":"现在的新零售包含了许多的硬件，并且线下环境将会因为各种硬件性能的不够成熟完善，再加上时好时坏的网络情况，都给线下带来了很多的不确定性与困难性，这也就给调试带来了不小的麻烦。 比如一张拍照后经过后端各种处理的图片，本来应该展示的时候却没有展示，这时候就需要前端工程师来排查问题，毕竟显示层的所有问题都是属于前端的问题。 如果你运气好或者线下经验比较多的话，你就会发现大多数图片相关的问题都是偶现，不是必现，有可能你重新来一次，问题就已经不会复现了，只不过说不定什么时候这个bug又会心情不好地出来，怎么解决呢？后面再说。 既然出了问题当然就需要解决问题，我们就需要对这台设备进行调试。 对这台设备进行调试前，我们首先需要做一些准备工作： 你的电脑先要链接内网，然后起本地服务。 你要调试的设备也要有内网环境，同时设备里已经安装了一个测试包。 将你电脑的环境代理到调试设备上，花瓶可以，或者其他代理工具都可以，然后就可以在调试设备中访问你的本地项目页面了。 还有一些基本知识你也需要知道：比如你要知道mtop接口VConsole是抓取不到的，需要做降级处理； https的数据在花瓶中抓到的也是乱码，你要先安装ssl证书； 还有一些特殊的接口，比如hybrid接口，除了将其console／alert输出来看，基本没有其他办法，并且打印出来看完了过后你还要记得clear，否则如果不小心带了一个alert上线，你就要哭死了（这个问题建议用一个全局的方法统一处理，或是在build的时候引入一些去debugger的插件）； 前端能检查到的接口种类是有限的，客户端直接对后端发起的请求前端是获取不到的； 一些静态资源的加载详细信息，前端都是拿不到的（除了图片加载的onerror和onload）。 都当前端完成了准备工作，经过了长时间检查后，如果还没找到问题，就要客户端／后端来检查了，毕竟不是每个接口都是前端能拿到的，比如客户端的网络请求，前端就拿不到，需要客户端同学代或后端看一下请求日志，这就更加麻烦了。 以上的流程都是标准状态，如果你有持之以恒的信心完成了，那也是调试效率低下的表现，但是很多时候，我们零售终端的开发都是需要去线下场地的，也就是说我们不一定是在公司，毕竟电脑想变成内网环境，阿里郎可以很轻松解决，但是其他设备想连内网，就麻烦多了；同时根据我做线下的一点小小的经验，上线后的问题，80%主要是硬件和网络所引起的加载失败或者效果卡顿，点击偏移等等。 首先说下网络，想了解网络情况，唯一的解决方法就是拿到当时请求和加载资源的详细信息，这就说明你必须有一个对项目内的所有请求和资源加载的监控，并且为了能够做到实时调试，所以就必须有一个地方能够实时查看这些数据。 零售终端日志列表 先来说如何获取这些数据。 在业务层面来说，前端和客户端可以对自己所用到的接口等都做统计，尤其是接口响应时间和资源加载时间，这样我们才能知道某时某刻的具体网络情况是怎样的，业务层面搜集了数据然后集中上报到某个服务器（设备数量很多时，数据量可能会很大，要注意），但是这就有个问题，那么多接口，如果都在业务层面来做，工作量将会很大，并且对其他业务的接入的门槛也将会提高，所以这个就不能放在业务层面来做，这就需要放在零售终端底层统一做掉，客户端底层是可以对这个app内的所有请求／加载进行监控的，所以上面提到的各种接口，http／https、mtop、hybrid、静态资源加载，都可以获取到详细信息，包括但不仅限于入参、出参、起止时间等等，所以其他零售终端的业务也就统一静默接入了这个功能，他们唯一要做的就是打开这个监控数据的开关，真正做到了零成本，这是第一个好处；第二个好处就是客户端的本地存储功能，现在线下网络环境不好，所以我们一边在优化网络加载的情况下，另一边也是在不断降低网络波动对业务的影响，比如POS机，这是线下最重要的一个设备，直接涉及到钱的，不能因为网络差就让顾客买单失败或者产生其他错误，还有就是试妆镜子，也不能因为网络差就让顾客不能正常试妆，在零售终端这边现在都做到了不管网络怎么变化，这些功能都将可以正常使用，然后缓存在客户端本地，等网络变正常了，将会把一些订单信息或者试妆信息统一传输给服务器。 云端真机调试所以现在我们已经获取到了这些数据，后面就是展示出来，展示的地方刚好有现成的，就展示在零售终端平台中，后面的话，如果再遇到一些线下设备的异常情况，我们就可以直接在某个地方去实时查询异常时候的各种信息数据，而不是自己艰难的起服务来调试。 到这里，这算是解决一个调试的大问题了，后面呢？线下零售终端设备有的特别庞大且笨重，有时候你要调试的时候，你手边却没有这些设备，这就很麻烦了，不像手机那么容易得到，所以此时就想到了云端真机调试，现在这种云端真机调试有许多，比如UC的IRMA，淘宝的磨刀石，这里就不再缀诉了，目前天猫魔镜已经接入了磨刀石，每当有什么地方需要修改后，我本地改完了就可以通过磨刀石在云端真机调试，并且可以去终端管理平台上查看具体调试信息。 总结和之前的调试方法相比，不管你想调试哪一台设备都可以设备的距离，并且让你可以实时查看任一台你想要查看的的接口和资源信息，这样就形成了从个人电脑到调试的设备再到设备日志的一个闭环，真正做到让你的线下设备调试效率大幅度上升。","tags":[]},{"title":"BlockChain 十年踪迹（转）","date":"2018-11-01T06:54:39.000Z","path":"2018/11/01/BlockChain 十年踪迹/","text":"2008年10月31日，一场社会实验开始，中本聪带着比特币和区块链出现。 十年间，伴随着比特币和区块链发展的不同阶段，极客、矿工、投机者与小白不断涌入，留下暴富、神话、骗局、信仰、革命等关键词。 十年后，比特币和区块链或已不再是中本聪的初衷，二者也不只是少数极客的玩具，而是俨然要掀起一场科技革命。 回顾这场科技浪潮的各大事件节点，不只是为了纪念，更是以史为鉴，砥砺前行。 2008—2009 关键词：中本聪，创世 大事记：2008年10月31日，中本聪在他所在的密码学邮件群组中发布了比特币白皮书——《一种点对点的电子现金系统》，比特币自此诞生。 2009年1月3日，比特币创世区块被中本聪挖出，他在区块中留下“2009年1月3日，英国财政大臣在第二次拯救银行的边缘”的注解，这是当天《泰晤士报》的头条标题。 2009年1月12日，中本聪将10枚比特币转给了比特币早期开发者Hal Finney，这是第一笔比特币转账。 中本聪希望通过比特币网络创造一种全新的金融货币体系，这是他对屡遭金融危机的当今金融体系的不满，以及对未来新体系的畅想。 但是，这样一个具有无限想象力的新技术远远超出了它的初衷，在其他领域也迸发了足够大的想象力。 2010 关键：披萨，漏洞，交易，极客玩具 大事件：2010年5月22日，比特币爱好者“Laszlo Hanyecz”用10000个比特币买了一张价值25美元的披萨优惠券。 2010年7月18日，P2P传输网络“电驴”创始人Jed McCaleb上线了全球第一个比特币在线交易所“Mt. Gox”（门头沟），一度承担全球超过70%的比特币交易。 2010年8月15日，比特币协议中一个漏洞被攻击，黑客凭空生成1844亿枚比特币。第二天，比特币社区紧急修复了这个漏洞。 2010年，未来影响区块链发展的两位重要人物踏入比特币的世界。ByteMaster（BM）和Vitalik Buterin（V神）开始对比特币网络进行思考。 这是第一笔公开的比特币与实物交易，这一天也成了比特币历史上有名“比特币披萨日”。比特币作为一个金融体系的畅想有了更多实际存在的意义。 比特币漏洞也促使更多的技术极客有了改进它的想法，这一年中本聪从网络上消失了，更多的探索者跃跃欲试。 2011—2012 关键词：门头沟，美剧，丝绸之路，监管 大事件：2011年6月19日，Mt.Gox（门头沟）被黑客攻击，黑客在短时里将比特币价格压至0.01美元，致使Mt.Gox等交易所被迫暂时关停。 2011年6月，暗网“丝绸之路”开始有大量的非法比特币交易，比特币被作为“官方货币”在暗网中交易毒品、枪支等。比特币开始与地下黑市交易扯上瓜葛。 2011年6月9日，中国第一个比特币交易网站“比特币中国”上线。 2011年12月19，美剧《傲骨贤妻》宣布将播出比特币故事主题的新一集剧情，备受关注。而据说，后来的比特币交易平台OKCoin的创世人徐明星就是受到了此剧情影响。 2012年6月，美国蝴蝶实验室宣布ASIC矿机，并宣布把新产品上市时间定在2012年9月，此时距离比特币第一次产能减半仅有半年。 2012年7月，烤猫（Friedcat）在论坛上宣称自己能造出ASIC矿机，吴忌寒投入10万身家，并帮烤猫筹钱，最后成功筹集了100万元资金。 2012年11月28，比特币产出迎来首次“产能减半”，每个区块产生的比特币从50个减至25个。 比特币因其特性与暗网非法交易产生联系，这是比特币在合法性的一大阻碍，也是为人诟病的短板。 比特币不再只是极客的玩具，越来越多的人被其“金融属性”吸引，比特币正处在大规模产业化的前期。 2013 关键词：矿机，交易所，比特大陆 大事件：2013年年初，张楠骞（南瓜张）第一个研发出ASIC矿机，并命名为“阿瓦隆”，但直到9月才发货，前三批次总共1500台。 2013年6月，烤猫的矿机USB终于面世，并保持了对全网20%算力的控制。 2013年9月1日，李林的比特币交易平台火币网上线。2013年，徐明星的比特币交易平台OKCoin问世。 2013年10月29日，Robocoin和Bitcoiniacs在温哥华推出全球首款比特币ATM。 2013年12月5日，中国央行等五部委发布暴跌《关于防范比特币风险的通知》，宣布比特币非货币，并禁止所有金融机构参与比特币业务。 2013年底，吴忌寒用从投资烤猫赚的几千万资本，在和詹克团的合作下，研制出了蚂蚁S1矿机，矿机厂商比特大陆开始登上历史舞台。 这是比特币诞生的第四个年头，此时比特币和区块链已经有最够大的传播。这段时间众多的区块链世界的”名人们”注意到了它的存在。 ASIC比特币矿机问世，也孕育着这个市场的新巨头的出现。比特币开始走向大规模商业化的阶段。 2014—2016 关键词：ETH，烤猫，智能合约，2.0 大事件：2014年2月24日，Mt.Gox（门头沟）称超过85万枚比特币在过去几年里被盗，并宣布关闭交易所，比特币价格出现巨大波动。 2014年7月24，所开发的以太坊项目开始进行预售，共募集31529个比特币，按当时市值约为1800万美元，而此时他才19岁。V神名号由此得来。 2014年8月，由于矿机研发问题和市场形势不好，烤猫第一次出现在公众面前，不得不为产品做宣传。不过这成了他最后一次露面，之后彻底失联。 2015年1月26日，比特币交易平台coinbase上线。 2015年5月，暗网“丝绸之路”创始人“Ross Ulbricht”被判处终身监禁并不得假释，而罪名是被指控洗钱、黑客入侵、贩卖毒品等7项。 2016年6月15日左右，以太坊上一个智能合约众筹项目The DAO被黑客攻击，以太坊面临重大危机。 2016年7月20日，以太坊分叉为两条链，ETC和ETH，挽回了The DAO的大部分损失。 2016年7月9日，比特币迎来第二次“产能减半”，每个区块出矿将从25枚比特币减少为12.5枚。 2015年10月31日，比特币登上《经济学人》杂志封面。 以太坊诞生后，确实给区块链行业注入了新鲜的血液，也让技术爱好者们看到了区块链更多的应用可能。智能合约在随后的日子里，引起了区块链行业的一阵新热潮。 2017 关键词：代币募资，EOS，3.0 大事件：2017年4月，ByteMaster（BM）创立了BlockOne公司，并公布了新项目EOS。 2017年7月4日，赵长鹏创办的币安交易所上线，由于其一系列营销活动和选择在94后出国，迅速成长为全球最大数字货币交易平台。 2017年9月4日，国家七部委联合发布了公告，禁止境内形式的代币私募行为。 2017年，无疑是代币募资的集中爆发年，这一年使用以太坊智能合约发行代币的项目多如牛毛。但是大多数成为了“圈钱”的垃圾项目。 2017年春节前后，3点钟无眠区块链社群火爆，一种区块链的信仰者或观察者在微信群中发表自己的观点。这也是引发2018年中国区块链异常火热的重要因素之一。 这一年无数代币募资出现，在狂潮落下后，大部分被淘汰。经过了一轮清洗，给了优质创业者更多机会。狂热是短暂的，在接下来的一段安静期，努力和有才华的人才能笑到最后。 BM的EOS一度被看作是区块链的3.0，但是区块链从业者仍需把眼光放长远些，区块链的发展可能还需要不止一个十年，不止一个3.0。 2018 关键词：交易挖矿，探索，应用，上市 大事件：2018年5月底，FCoin上线，因其交易挖矿分红模式吸引巨大流量。上线半个月，日交易量就超过币安、OKEx、火币三者之和。但好景不长，交易挖抗模式迅速宣告失败。 2018年9月，世界最大矿机生产商比特大陆向港交所递交招股书。另外两家排名前三的矿机公司嘉楠耘智和亿邦国际也向港交所递交了招股书。 2018年10月10日，《2018年胡润百富榜》发布，共有詹克团、吴忌寒、赵长鹏、徐明星、李笑来等14位行业富豪上榜。 2018年10月，对方消息指出Coinbase即将上市(IPO)，预计募集5亿美元。 2018年，各国均在积极规范代币募资的行为，监管政策逐渐完善。谋求代币合法合规成了行业共识，欺诈性的代币募资行为在逐渐减少，公众的防范意识进一步增强。 2018年，关于区块链的讨论开始多起来，票改、无币区块链、链改、通证经济、赋能实体经济等新概念被提出，区块链开始从比特币中慢慢脱离出来。 2018年，多个行业开始用区块链进行尝试和实验，包括电子发票、版权、货物溯源、司法存证等诸多实例。 2018年是比特币和区块链诞生十周年，一个重要的节点。 比特币和区块链一起走过了十年，比特币作为区块链世界的第一个产物被推上了神坛。未来区块链在更多领域将有更大的想象力，而比特币可能会成为一个被赋予价值的区块链纪念品。 在区块链蛮荒之时被供奉的神灵，也将逐渐退去神秘，回归凡人。","tags":[]},{"title":"RxJS(一)","date":"2018-09-26T12:30:45.000Z","path":"2018/09/26/Rxjs(一)/","text":"又是好久好久好久没有写技术文章了，主要是都在忙业务，唉，年初过个春节，然后搞了618，上半年就过去了，下半年中秋国庆一过，双十一忙到昏厥，一年也就这样过去了。。。作为阿里的程序员，有时候感觉时间过得真的好快，不知道自己又留下了些什么，可能确实留下了很多东西，比如每年的繁忙，业务的发展，技术的进阶，但是都是存在于深深的脑海里，好好想了想，还是想写下来，但是有的业务耦合太强的又不敢写，所以只好自己提炼一下纯技术的东西，放在博客里。今天这是RxJS的第一篇文章，后续会出多篇，变成一个完整的RxJS学习系列。 一，RxJS是什么？RxJS的全称叫做 Reactive Extension for JavaScript，Reactive Extension也可以简写为ReactiveX，至于Reactive Extension为什么要缩写为Rx而不是Re，我也不知道，总的意思就是JavaScript的Reactive Extension模式的实现，因为这只是一种实现的模式，和具体语言无关，所以除了RxJS，还有RxJava、Rx.NET、RxCpp、Rx.rb、RxPy等，这种。 在介绍Reactive Extension编程模式之前，我想先介绍两种其他的编程模式，就是响应式编程和函数式编程。 1，函数式编程说起函数式编程，大家应该都不会陌生，顾名思义，函数式编程就是使用函数来解决问题的一种编程方式。用过Redux的同学应该都会明白，Redux就是纯函数式的编程，我们可以归纳一下Redux的几个特点：不修改老的state，而是返回新的state；入参一定的时候，出参数也一定；使用声明式函数；其实这就是纯函数最大的三个特点：1，不可变数据；2，纯函数；3，声明式。这里我就不做过多介绍了，有兴趣的可以下去自己查下资料看看。 2，响应式编程（Reactive Programming）这个响应式编程呢，举个最简单的示例，就是excel函数，比如大家在使用excel的时候，需要计算一列数值的和，我们只需要选中这列之外的一个空白的区域，然后在公式部分输入“=”，再用鼠标选中你所想要计算的那一列或一部分的区域，那么你选中的这个区域里的数值，就会自动变成你想要计算的那一列的值了，与此同时，不管你这一列中，任意位置的值想要怎么变化，最终结果的值也是会同时进行改变的，这也就是说，结果区域的值会随着你那一列的区域中值的变化而作出“响应”，这就叫响应式编程。","tags":[]},{"title":"ipfs：星际文件系统","date":"2018-06-08T03:48:33.000Z","path":"2018/06/08/ipfs/","text":"写在前面比特币（Bitcoin）是区块链中最火最大的一个项目，其原因就是因为去中心化（Centralization），或者我们可以认为，是“多中心化”，因为点对点（peer to peer）的操作，是任何一个点（peer），都成为了中心，当每点都成为了中心，也就可以粗略的认为没有了中心，因为中心太多了，也正是由于中心太多，所以这个项目不会受制与某一个人或某一个团体，不会被少部分人控制，大家的权利和义务都是一样的，保障了绝对的公平。上面是比特币的特点，然后人们根据比特币的这个特点，从底层的技术中，提取出来了区块链（block chain）技术，也就造就了现在繁荣的区块链生态。 http说了那么多废话，其实就是想说，比特币，是区块链技术在货币上引用的产物，当然，区块链还可以运用到我们生活中的各行各业，现在我主要想说的，就是区块链运用到电脑传输协议上的产物，ipfs。 要说一个东西好，那肯定是有比较物的，比如我要说ipfs的优点，那么我就说出ipfs之前的http有什么缺点，并且ipfs怎么解决的这些问题，两者相比较，才能知道具体的好与不好。 所以我现在先说下http，作为tcp/ip的应用层协议，http无疑是很成功的，优点也有众多，有了http，才有浏览器，才有网站，才有客户端，才有各种有趣的网页与应用，所以说http是当今互联网世界的根基，也毫不为过，互联网公司将内容数据放到服务器上，普通用户通过浏览器、客户端等各种形式的终端来访问服务器，获取这些数据，这一过程就是我们常说的“上网”。在此过程中，这些数据的传输都是遵照HTTP的定下的标准。所以说，当前的互联网是运行在HTTP的规则之下的，这就是http协议的优点。 但是很不幸，它遇上了区块链这个划时代的东西，所以从区块链开来，http有一个很严重的弊端，就是服务器，这是一个很明显的中心，在区块链中，是不允许出现的情况，为什么呢？结合当下的社会事情来说，比如说“X涵段子”，“X走大事件”等的下架就是这个问题，谁让它们下架的？当然是相关部门，那相关部门怎么让他们下架的呢？前面就说了，你网站中的所有资源文件，客户端中的资源文件，都放在服务器上，所以要控制这个网站，只要控制住这个网站的服务器就好了，难吗？不难，如果很难的话，天朝这种只会扫黄打非的police，是肯定解决不了的。当然，除了服务器这个明显的中心节点后，还有网络拥堵，DDOS攻击（参照最近阮一峰老师博客事件）等问题，所以当区块链技术遇上网络通信协议，ipfs就出来了。 ipfsipfs的终极目标：要革http的命。 当然，这只是个很大的口号，就像小时候我想考北大，但是最终去了北大青鸟一样，毕竟“人有多大胆，地有多大产”，之前在炒币时，大家整天想着都是百倍币，千倍币，像我这种最高的时候才赚20%的人，说出来是会丢了炒币人的面子的，毕竟在很多人眼里，数字货币是未来世界的通行证，法币就是一文不值的草纸，我觉得这就有点过激，有点浮躁了，这就像我们当初高喊共产主义，三五年赶超英美，迈向共产主义社会一样，或许人类社会最重发展进步，会走到共产主义社会，不过可能会是“一万年”吧。 扯远了，还是说会ipfs吧，从简单开始说，bt下载估计大家都用过吧，尤其是男生，而且bt下载是封锁不了的，它没有服务器的概念，是从你电脑里直接传输东西给我，没有经过服务器等大型中心节点，比如银行可以禁止我转账给你100元，但是绝不能禁止我当面给你一百元一样，完全不可能禁止住，而bt下载技术又是十分成熟的技术，只是将bt下载里，文件以torrent形式来传播改为了ipfs里文件系统的组织形式。 另一个区别是，内容的传输方式不一样。IPFS的传输方式不像HTTP那样依赖骨干网络，而是通过用户间的连接来传输。每个用户都是一个微型节点，这些节点连接到一起，形成一个立体的拓扑网络，数据从一个节点到另一个节点，跟跑接力赛一样。就算某个节点出错了，那马上换另一个节点走就成。而传统的HTTP路线则是树状的，有关键节点存在，所以很容易被监控或者攻击。 start说了半天废话，作为一个技术人员，我只想说“talk is cheap,show me the code”。 ipfs的工作原理：IPFS 为每个文件根据其内容计算出一个唯一的HASH，每个节点储存部分文件数据以及确定每个文件所在节点位置的分布式哈希表。用户访问文件时提供文件的 HASH，依据哈希表找到文件并返回文件数据。与 CDN 不同的是，每个 IPFS 节点都是一个数据源，不需要再从中心服务器获取数据。 btw，Filecoin 是运行在 IPFS 上的激励层。Filecoin 提供一个巨大云储存市场，使用者支付一定的金额来获得分布式的存储服务，而矿工将自己的机器作为 Filecoin 中的节点存储数据，来获得工作证明，以此来激发更多的人来加入 IPFS 的节点网络中。你可以在gate.io中买到～～～～～～ install先打开ipfs官网，下载，当然，我们优越的天朝早就把这么危险的网址给墙了，这么危险的东西，还是留着去资本主义吧，所以你要翻墙才能下载，这里就不多赘述了。 下载后记得解压，然后执行里面的 install.sh 文件，执行后你可以通过运行 ipfs help来测试是否安装成功。 创建节点运行 ipfs init 命令，将会自动创建 ipfs 节点，创建成功的话，将会有如下提示信息： 123456initializing IPFS node at /Users/Morning/.ipfsgenerating 2048-bit RSA keypair...donepeer identity: QmPh21fdkT9k3SCa83GMdErTwWAxyy3dcvUZiYYF2E5BDeto get started, enter: ipfs cat /ipfs/QmPh21fdkT9k3SCa83GMdErTwWAxyy3dcvUZiYYF2E5BDe/readme ipfs 的所有信息就储存在了 /Users/Morning/.ipfs 这下面。 运行节点1$ ipfs daemon 执行daemon命令，启动 ipfs 的守护进程，将本地节点连入ipfs节点网络，同步节点数据，参与数据的储存与分发。执行后将会显示如下信息： 123456789Initializing daemon...Swarm listening on /ip4/127.0.0.1/tcp/4001Swarm listening on /ip6/::1/tcp/4001Swarm listening on /p2p-circuit/ipfs/QmPh21fdkT9k3SCa83GMdErTwWAxyy3dcvUZiYYF2E5BDeSwarm announcing /ip4/127.0.0.1/tcp/4001Swarm announcing /ip6/::1/tcp/4001API server listening on /ip4/127.0.0.1/tcp/5001Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080Daemon is ready 这下，你就在 ipfs 网络中了，你自己就是其中的一个节点，你可以自己上传或者下载文件了。 添加文件命令很简单，一句 “ ipfs add 文件 ” 就好了，比如我当前目录下有个 readme.md 文件，里面就一句 hellp ipfs， 然后我在终端里输入： 12345678910111213141516$ ipfs add readme.md// 终端返回如下added Qmc6XfTRVX8FnYhMJ9wdgyq87qhgSZubTxUDYU4aX8m2ps readme.md// 说明本地 ipfs 网络已经加入了这个 readme.md 文件，并且其对应的 ipfs 里的hash值是Qmc6XfTRVX8FnYhMJ9wdgyq87qhgSZubTxUDYU4aX8m2ps，若你的daemon进程正在运行的话，本地的数据将会被自动同步到ipfs网络。// 接下来我们通过cat名了来验证文件ipfs cat Qmc6XfTRVX8FnYhMJ9wdgyq87qhgSZubTxUDYU4aX8m2ps// 输入将会如下# hello ipfs// 我们可以使用 IPFS 官方提供的 HTTP 网关加文件 HASH 来访问文件。// 官方: https://ipfs.io/ipfs/&lt;HASH&gt;// 代理: https://ipfs.infura.io/ipfs/&lt;HASH&gt;// 如果要上传文件夹，就用add -f 文件夹路径 就好了，这里就不多说了 修改文件在 IPFS 上其实并不存在修改文件这么一说，只要你将文件上传至 IPFS 网络后，这份文件将一直保存在 IPFS 网络中，除非所有保存该数据的节点都丢失了该数据。如果想修改文件，只能重新使用 add 命令来上传修改后的文件，生成一个新的 HASH。 any problem else？ 我发布了一个网页，地址是xxx，然后我修改了这个网页，再发布，地址就变了。。。万一网站的用户有一千万，你需要去通知一千万用户？？？ 为了解决这个问题，我们可以使用 IPNS (Interplanetary Naming System) ，IPFS内部的域名系统， 将新的 HASH 与自己的节点 ID 绑定。使用 ipfs name publish 命令： 12345$ ipfs name publish QmTQLbdGA9pQcwj7Wgf17AYAUcZcEyuijftupz1YCcf9MnPublished to QmbBsAzF69zvuseNgsE1t8wPYnJrXaYTpt6z6Kitsnc7ZA: /ipfs/QmTQLbdGA9pQcwj7Wgf17AYAUcZcEyuijftupz1YCcf9Mn// 然后不管你后面怎么更新文件，域名都只是一个，在有了固定的地址后，我们还可以通过反向代理或者修改 DNS TXT 的方式来绑定自己的域名。https://ipfs.infura.io/ipns/QmbBsAzF69zvuseNgsE1t8wPYnJrXaYTpt6z6Kitsnc7ZA/ otheripfs上的其他有趣的项目：https://github.com/ipfs/awesome-ipfs#apps 也许在不久的将来 IPFS 真的能成为一个流行通用的网络协议，真正实现一个更快更安全以及更加开放的网络。 作为历史的见证者，我们可以在 IPFS 上创造并分享属于我们的永恒的时刻。","tags":[]},{"title":"react 16 新特性 说明","date":"2018-05-31T08:07:45.000Z","path":"2018/05/31/react 16 新特性/","text":"context说起context，就要从原生的react数据流说起。 在以前，react的数据传递，都是通过父组件的prop，向子组件传递，当组件嵌套层级过多时，就需要一层一层的将prop传递下去，当组件嵌套的层级足够多时。。。那我只能说，代码给你，你来吧。 这里就需要说一下context，在之前，官方是没有context api的，并且也一直不推荐使用，就像redux一样，如果你不知道该不该用，或者不熟悉该不该用，那就不要用。 说了这么久，我们先来介绍下context是个什么东西吧，刚才说到，react的数据传递，都是通过父组件的prop，向子组件传递，当组件嵌套层级过多时，就需要一层一层的将prop传递下去，当组件嵌套的层级足够多时，就很蛋疼，所以就要解决啊，解决的思想是，将所有的数据，变成一个store，并且将这个store的位置提到最高，高于任何组件的，所以这个context，也就是指的“上下文环境”，让一个树状组件上所有组件都能访问同一个共同的对象 具体如下代码： 1234567891011121314151617181920212223// 我们假设我们开发的组件叫App，为了给这个App加一个全局的一个数据仓库，在这外面再包一层Provider就好了，然后把你想要传递的数据，当作Provider的属性，这样就可以使数据变成一个全局的数据了。&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;// Provider.js // 而Provider，里面就是直接返回他的子组件就好了，并且还有一个函数来获取当前的storegetChildContext()&#123; return &#123; store: this.props.store &#125;;&#125;render() &#123; return this.props.children;&#125;// store.js// 然后来看看这个store，这里的createStore是直接引用自redux，而这里的reducer，就是redux里面的reducer，需要自己接受state，action，然后根据你自己的业务需要，判断action.type，来返回新的state，且务必遵守纯函数的原则。const initValues = &#123; // 初始化state数据&#125;;const store = createStore(reducer, initValues);","tags":[]},{"title":"2017年总结 && 2018年计划","date":"2017-12-29T11:40:22.000Z","path":"2017/12/29/2017总结/","text":"写在前面占位符～～～～～～详细内容稍后再完善～～～～～～ ～～～～～～～～～～～～～～～～～～～～～～～～～～ 不知不觉，2017年又过完了，当然，是阳历，中国传统的农历2017年，也还剩一个月多点，所以说一个月后，我也就要离开本命年，走进狗年，开始25岁的征程了。 去年就一个字吧，忙！ 从年初在忙着找房子，年中忙着找工作，年末忙着找bug，这一年糊里糊涂地就过去了，光阴荏苒，岁月流逝，虽然累虽然经历了不少的麻烦与困难，不过所幸，结局都还是不错的。 年初的时候，一直舍不得家人，不知道为什么，和之前从重庆到杭州来的感觉不一样，这一次格外难过，可能是柯兰当时准备离职吧，毕竟我和柯兰在原公司过得都不怎么开心，不安的情绪也就一直在身边，所以心情比较down，感觉重庆有太多的舍不得，那一刻，我承认，我差点就打包行李回重庆或者成都了，想回去过悠闲的日子，可是还是没勇气，也割舍不下杭州的人和事，没办法，所以哭过了之后还是擦擦眼泪继续去上班，这算是2017年初的第一个小波折吧。 接下来是换房子，之前那个地方我已经厌烦了，之前一直不喜欢合租，没办法，终于去找了合租，也是巧合，沉木刚好也在找室友，他是挖财的，也是搞笑，第一次租的时候，沉木租出去了，后来被放鸽子，又叫我们回来租，还浪费了我500元的定金，虽然这笔钱最后是沉木出了呢，所以还是和沉木一起合租了，对了，还有个蚂蚁金服的女生，这个女生也是不断刷新了我的三观，足够懒，足够不爱卫生（或者说不爱护公共区域的卫生，那就是素质问题了），反正我也是很无语拿她无可奈何，女的要是不爱卫生，比男生狂多了，我在她面前感觉就是一个洁癖患者，要不是看在金都新城那房子确实不错的前提上，我早就想搬走了，唉。。。 房子的事解决了，就继续在mgj写代码，陪媛媛了。 夏天的时候和公司一起去舟山outting，虽然有苦有泪脚上有水泡，不过确实蛮有意思的，第一次徒步那么久，那么多人，为了一个目标一起努力的情景，人生也是难得遇见几次，很荣幸我遇见了一次，就是从小白脸晒黑了。 后面就是准备骑驴找马地换工作了，实话说，我在前公司的时候，没出来看看，一直还觉得不错，走出来看了就会发现，世界确实很大，可以说是众生万象，有很客气的大公司，也有很傲气的大公司，有很谦虚的小公司，也有很抠的小公司，在此，我还是要给滴滴北京技术平台部道个歉，毕竟后来没去是我的错，甚感惭愧，滴滴的那个领导（好像叫小泽）我也特别感激，说只要我以后想去，就算我被hr拉黑了他也会帮我，还跟我交流了很久，面试时谈得也十分nice，可是hr太厉害，我也深感无奈，也算巧合，刚好在我入职滴滴前的两周，又同时拿到了tmall的offer，工资倒是差不多，既然两个offer几乎没差别，但是我就找不到去北京滴滴的理由了啊～只能说时机真是妙啊。后面就是来了阿里，新零售供应链事业部下的零售终端技术部门，是天猫互动娱乐部门的原班人马，也就是寻微原来的部门，哦，寻微原来叫紫溪啊～～～阿里真是大啊，这是最直观的一个感觉，园区那么多，部门那么多，人数那么多，业务那么多，有好多东西需要学习的呢，就像你去图书馆一样，知识是免费的，但是需要自带容器。 入职阿里是9月底，刚好赶上双十一的开发时间，不知道算不算幸运，立马就披挂上阵，项目最忙的时候，通宵也是常有的事，最开始以为11点，12点下班算比较晚的了，后面却接着是第一次第二次第三次通宵，算是应了那一句话吧，没有经历过双十一的阿里人，不是真正的阿里人，我也很好的秉承了每逢大促胖三斤的原则，没能抵住夜宵的攻势，基本毫无招架之力就投降了，双十一的时候，园区内的活动还是比较欢乐的，各种有意思的活动，参与一次双十一还是蛮不错的，算是一段很丰富的经历了吧。","tags":[]},{"title":"md5算法","date":"2017-11-27T11:56:23.000Z","path":"2017/11/27/md5算法解析/","text":"好久没写过博客了，主要原因是平时工作太忙，难得有个休假也就想躺在床上看看电影听听歌，放松一下。。。最近突然看到某个公众号里的几篇和md5相关的文章，本来也不想看的，然后就想到了大学，想到了吴梃教授在离散数学课上和我们聊的md5。。。觉得不想把大学里的东西丢太多，所以还是好好看了下这几篇md5的文章，md5算法，破解md5，然后自己仔做整理，沉淀下来。","tags":[]},{"title":"页面表单后台配置化方案","date":"2017-08-07T10:25:00.000Z","path":"2017/08/07/页面表单field后台配置化方案/","text":"写在前面又是好久没有写博客了，之前写了太多纯技术相关的文章，后来吧，发现技术是技术，可是学习技术的最终点，是要在业务中实现落地，会的技能再多，不能在具体的业务场景下得到结果得到产出，都是不是好的技术，毕竟，公司也好社会也罢，都是结果导向的。 页面表单配置化方案开始这个解决方案要从我所在的业务场景说起，我主要做的是crm和商家相关的，大多数都是对内的一些后台系统，其业务特点是：轻样式（基本不会用到什么绚丽的，高难度的效果），重交互（各种逻辑交叉纵横，剪不断，理还乱）。而又会涉及到各个系统之间的交流，比如面向买家的，面向商家的，面向客服的，这之间都会有联系，一个纠纷单（申诉，维权或举报），首先从买家端发起，经过处理，然后流到商家端，商家也会处理（或不处理，等到时间终止），最后流向客服端，客服来进行最终的判定，一个维权单才会算作结束。且买卖和商家的系统分别会涉及到PC和H5。 上面是crm的基本业务介绍，然后就开始进入正题，表单配置化。 这种To B的业务，最最最常用的，就是各种表单，而且逻辑也十分复杂；且由于涉及到的表单比较多，经常会涉及到表单的变动。最基本的方法就是前端在页面上添加一个表单组件，然后后端在接口增加那个组件对应的字段，这样就ok了，但是这会涉及一些问题或麻烦，比如每次只增加一个简单的输入框，却需要前端后端一起来工作，维护成本比较高；其次是组件化（模块）程度不够高，复用基本上靠的是复制加粘贴。 所以为了解决crm表单维护的麻烦，提高维护的效率，所以才作出了这套表单后台配置化的方案，将表单维护的前后端开发打通，以后要想再更改表单什么的，能够一个人（不管是不是技术人员）快速完成。 我所接触的表单最开始，是在PHP的老系统里，当时还是用的jQuery，当时处理表单变化的方案就是将表单分解为各个模版，比如一个select，下面有5个选项，那么你就需要5个模版，当使用者选择某一个选项时，展示对应的模版，如果有修改，就需要前端修改模版，后端修改接口，这也就是最基本的方法。这个我就不另外截图了。 下面要说的是某次开发中遇到的情况，这是一个表单，但是并不完整，可以看到，顶部的下拉框还属于未选择状态，然后当你选择下拉框的时候，会进行一个异步请求，将会收到这个下拉选项所对应的一些额外的表单数据，最后你用拿到的数据渲染出一些新的表单，再和原来已经存在的表单合并，就变成了一个新的表单。 这算是页面表单配置化的雏形吧，这个时候有了一点基本的表单后台配置化思想，但是问题还是有很多，比如组件不够全，渲染全靠遍历，没有涉及表单间的嵌套，表单的校验，表单事件是写死的，后台数据是后台开发人员配的，对其他人员使用不友好等等问题，但是已经迈出了第一步，那就是表单数据由接口获取。所以这个时候就有了个想法，既然部分表单组件可以是由接口动态获取数据渲染的，那么为什么不能将所有的表单组件都这样做呢？ 最后，我们就开始了将这个想法具体实现，第一次就是在crm业务中的纠纷处理平台中，通过其特有的买家、卖家、客服，三端都有的关联，业务场景和实现环境都比较适合，所以才决定用在纠纷处理平台中。 新版纠纷平台中的表单后台配置化既然决定在纠纷处理平台中实践了，但是问题还是有很多的，比如之前的表单数据是后台直接写在代码中的，我们为了让非技术人员，主要是对应的客服人员，也能够友好的使用这个系统，我们专门在客服系统里做了一个可视化的表单配置界面（将配置页放在客服系统是因为这是内部系统，安全系数比较高，且又和商家、用户的系统有一定的关联，客服系统本身就是整个大项目结构中的一环，所以放在客服系统里），解决了非技术人员的使用问题，这是第一个问题；接下来是组件的丰富程度，这里组件就分为基本组件和业务组件，基本组件倒是比较简单，但是业务组件就比较麻烦了，千奇百怪的各种组件，且实用频率又不高，但是想到可能会给后面他人的维护带来很大的帮助，所以我们开始做的第一步，就是完善组件库，包括传图组件，原图组件，商品验证链接组件等等等等，这些具体的业务组件，我会在后面再做整理；组件够完善了，后台也都配置好了，接下来的问题就是前端渲染了，渲染中最大的一个问题就是数据多了，怎么高效地渲染？由于表单会有嵌套，且很可能是多层嵌套的存在，所以我们需要在渲染上进行一下优化，最基本的map循环遍历，然后渲染，后面如果每次发生变化，再map，这是最简单最基本的方法，但是由于效率太低，所以需要进行优化，我们最终选择的优化方法是拿到这个巨大的json对象后，第一次遍历一下，将多维的表单降维成一维的，并且在每个表单组件上都加上了parent和children属性，以及display属性，parent和children属性是用来找到当前表单所依赖的父组件和当前表单能够影响到的子组件，而最后的display就是表示当前表单的展示状态，这种遍历方法优化了很多的时间，可是没有数据就没有说服力，所以我专门通过模拟数据来获取它们的所耗时长，一组是优化前的数据，层级暂定于三层，每层1000个（数据太小了结果可信度不高，且耗时精度也不够高，虽然现实生活中基本不会有一个表单的表单组件达到3000个），另一种是3000个表单，层级仅仅是一级，最重模拟的结果是，第一种方法耗时299毫秒，而第二种方法耗时2毫秒，两种方法耗时差距不言而喻。 确定了基本思路后，然后就开始完善组件库，因为这种配置化的，一定需要有一个完善的组件库作为基础来支撑，能够让配置的时候来随意调用组件，毕竟巧妇难为无米之炊，这里的组件分为两类，一种是基础组件，在react中，几本的表单组件，通过一个Filed组件就几本能够搞定了，况且我们也有不止一个的react组件库（现在正在进行技术收敛中），所以在基础组件这方面，几本不需要担心什么，除了基础组件，然后就是千奇百怪的业务组件了吧，我稍微整理了一下，业务组件现在有这么几个：可展开与折叠的卡片布局组件，上传图片，带搜索功能的下拉框（里面又细分为单选、多选、同步、异步），图片库图片上传组件，地址组件，pc图片预览组件，h5图片预览组件，商品校验组件，带选中和排序的table，windows下自动调用打印和打印预览的组件，订单卡片组件，以及其他。。。 完善业务组件库是一项工作量不小的活，虽然我在这里就列了各个组件的名字，但是实际开发中还是需要克服各种各样的问题的；当组件库完善之后，现在就要正式开始项目的开发了，先在后台有一个表单配置的列表，你可以知道某人在某个时间修改了哪个表单，这样做的目的是出了问题能够更快速的找到相关责任人，整个后台的列表页，里面最主要的功能就是元件配置页，它有添加元件，元件排序，以及预览功能。具体后台配置的页面，请参考下面图片。 这是后台界面，开始添加配置表单时候最开始的样子，这个页面现在还是空白的因为这个表单现在还没有添加任何的表单元件，右上角有三个按钮，分别是添加元件，保存元件排序，以及预览功能，保存元件排序功能和预览功能是一定要有表单元件后，才能执行操作的，所以我们先点击添加元件按钮。 上面两张图片，是点击添加元件后的弹窗，上面的中英文字段，长描述短描述，最底部的是否必填选项，还有默认值，都是组件通用的，每个组件都有这几个选项，唯一不通的是默认值会根据组件的不同类型，需要的默认值类型也不同，现在来说最重要的两个选项，那就是出现条件和类型，类型指的是你所需要的组件类型，它具体的类型如下图，由于弹窗下拉框中截图不方便，所以我直接从代码里截图吧， 可以看到，它一共有这么多的组件类型，除了前面的五种选项是基本组件意外，其他的组件全是需要自己封装的业务组件，光封装这些组件就费了不小的力，至于出现条件那一栏，我们稍后再说，然后再看具体的各个类型的差异。 这是选择短文本框的情形，可以看到，选择了类型后，下面的表单会新出一个校验规则这一栏，里面就是根据当前选中的表单元件的类型，再来配置对应的校验数据，这里是文本框，校验规则可以是简单的字符长度限制，也可以直接传过来一段正则公式来进行匹配，当然，后面的长文本框也是类似，我就不再赘述了。 然后再来看单选框，多选框，下拉单选框，这几个也是一类的，他们所需要的数据都是key-value的键值对，这个加号，就会出现名-值对让你填写，这个名就是key，值就是value，展示的是名操作的是值，然后右边的上下箭头是选择数据的排序顺序，旁边的减号是删除这一行的数据。 然后就是日期组件，日期组件在后台配置的时候就比较简单，主要问题是在前端如何能够将日期组件和对应的change事件良好的绑定起来，日期组件只需要传一个默认的时间日期就好了，也可以不传默认值。 接下来是图片上传组件，最开始设想的时候，想着所有校验规则都由前端来做，所以有了图片大小的校验规则，后来发现前端做这个校验比较麻烦，所以这个由后端来做，前端的这个配置功能也暂时没有下掉，至于图片数量和格式，就比较容易校验了，而这个图片上传组件，在开发的时候，也考虑了要不要缩略图，后来决定不将缩略图包含在内，因为并不是所有图片上传都需要缩略图，而又由于缩略的排版样式以及删除，都不一样，所以我们将这个功能放在组件外部，让需要的人自己去实现缩略功能，uni图片上传和原图上传，在后端配置来说，也是类似（但是在前端展示可就千差万别了）。 这是商品链接的组件，首先是一个输入框，旁边有一个校验按钮，你往这个输入框里填入一段商品链接，然后点击校验，会向后端发请求，分为自己的商品，xxx网站商品，aaa网站商品等，如果成功，则会展示商品的链接和缩略图展示，如果失败，则是一段错误提示的语句。校验规则比较简单，就是需不需要限制为xxx链接。还有就是数量限制。 后面的注册时间注册地址，就是比较简单的了，也没有什么好说的，下面我主要说一下之前留下的问题，出现条件这一栏吧。 最开始知道要做层级的时候，是十分抗拒的，因为特别麻烦，用不断的去遍历来解决，也特别low，特别没效率；但是当我仔细分析后我发现，实际上层级嵌套，有两个关键的节点，就是单选框和下拉框（这两个本质都是一样的，都是多个选项选一个），所以只要抓住这两个关键的节点，层级的嵌套，就十分简单了，所以当没有单选框和下拉框的时候，就肯定不会存在表单的层级嵌套，所以出现条件就是空，也就是表示默认的第一层，最外面的层级，当有了下拉框或者单选框的时候，就会变成下面这种： 你可以选择在哪一个（下拉框或单选框）组件时（出现条件的第一个下拉框），选中什么值的时候（出现条件的第二个下拉框），才出现你当前配置的这个表单元件，然后不断重复，就可以完成你想要的层级关系。 然后在表单外面也是可以有排序，增删功能的，这里要额外说一下这个预览功能，第一版本是没有的，所以配置好了要立即看到结果还比较麻烦，现在有了预览，配置好了下一秒就可以看到结果，大大的提高了效率。 后台配置好了，接下来是前端的渲染，我们将后台配置的所有数据作为一个十分庞大的json对象，直接返回给前端展示页来展示，前面已经说了，前台页面拿到这些数据后，会将多层级的数据拍平改为一级的数据，并且为了不保持其原有的层级信息，将每一个组件里都增加了parent和children属性，来表达其所依赖的父组件以及下面影响的子组件，然后自己通过switch方法，将所有可能出现的组件类型做成一个渲染的模版，包括将这个组件内的所有的信息都绑定在对应组件的属性上，出了上面说了parent，children，display等，还有checkRule，name，操作函数func，内置的数据等等，而且据我们所观察，表单层级嵌套，只有在下拉框和大选框的时候才会存在（其实下拉框和单选框本质上是一个意思，都是多选一的意思），所以我们会在下拉框和单选框的时候对数据进行遍历，这样就可以免去很多无用的遍历，大大提高效率。且最终我们提交的时候，会将拿到的所有数据，分别与其组件中的checkRule相进行校验，如果全部通过，才能进行提交，而这个校验规则checkRule，也是根据不同的组件变化的，比如说图片上传组件中最大最小张的限制，多选按钮中至少选一项等等，而普通的输入框就比较简单了，后台直接传过来一个正则公式相匹配就好了。 所以总的来说，后台的主要难点是层级嵌套在可视化界面上的配置，并且为了将配置的结果做到所见即所得，所以有一个预览功能，能够配置好了，下一秒就能看到结果，前台方面就是高效地渲染，以及各个组件提交前的校验，这样配置出来的表单，就做到了一劳永逸，除非后面有十分大的业务变更，否则后续维护的人力成本可以说是很少很少了。 总结：所以总的来说，这就是一个针对系统页面上表单比较多的时候，制订的一个表单后台配置化的方案，使用者（不管是不是技术人员）通过后台的可视化配置界面，能够即时性地对页面上的表单模版进行增删改，嵌套与校验等操作，最大的优点就是快捷迅速简单，不再像以前一样，前端改页面，后端改接口字段，然后测试，ok之后最后发布。","tags":[]},{"title":"几种常见的算法","date":"2017-08-07T10:24:32.000Z","path":"2017/08/07/算法/","text":"起因前几天和后端联调的时候，在空闲时间闲聊，不知怎么就聊到了归并排序，然后就瞎扯了一通时间复杂度，空间复杂度什么的，最后说到了归并排序在实际的应用，就是内存有限的情况下，大文件的排序。然后我就觉得，有些东西还是挺有用挺值得牢记的，就算短时间用不到，最好也还是不要忘，虽然大学学的很多东西，好多都因为暂时没用，还给老师了呢，比如计算机组成原理，操作系统，计算机系统结构等，觉得很是惭愧，于是就趁着周末看了下箱底的书，温习了一遍以前的一些基本算法，后来觉得还是要做一个沉淀写成博客会比较好，所以我就写了这篇博客，来提醒自己不要忘记。 插入排序算法描述： 1.从第一个元素开始，默认为该元素已经被排序。 2.取出下一个元素，在已经排序的元素序列中从后向前扫描。 3.如果该元素（已排序）大于新元素，将该元素移到下一位置。 4.重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置。 5.将新元素插入到该位置后。 6.重复步骤 2~5。 1234567891011121314151617// 举个例子：现在有一个数组 a=[7,3,1,2,9,6,8]。7,3,1,2,9,6,8[7] 3,1,2,9,6,8 // 第一步 取出第一个元素7，并且已经被排序[3,7] 1,2,9,6,8 // 第二步 取出第二个元素3，并且将3和之前的数组进行排序。[1,3,7] 2,9,6,8 // 后面就是取数，排序，然后不断重复，直到排序完成。[1,2,3,7] 9,6,8[1,2,3,7,9] 6,8[1,2,3,6,7,9] 8[1,2,3,6,7,8,9] 这个排序的核心编程思路就是双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将未排序元素设为标杆，与已排序的元素进行比较，小于则交换位置，大于则位置不动。时间复杂度O(n^2)，具体代码实现如下： 123456789101112131415function insertSort(arr)&#123; var tmp; for(var i=1;i&lt;arr.length;i++)&#123; tmp = arr[i]; for(var j=i;j&gt;=0;j--)&#123; if(arr[j-1]&gt;tmp)&#123; arr[j]=arr[j-1]; &#125;else&#123; arr[j]=tmp; break; &#125; &#125; &#125; returan arr&#125; 选择排序这个排序和插入排序的相似度很高，唯一不同的是，插入排序的方式是从第一个开始，然后选第二个，第三个。。。按照各元素的位置来选，而选择排序的意思就是，每次选的时候，都选择的是余下数组中最大（最小）的那个数，我还是以上面的数组来举个例子。 1234567891011121314151617// 举个例子：现在有一个数组 a=[7,3,1,2,9,6,8]。并且每次选择选最大7,3,1,2,9,6,8[9] 7,3,1,2,6,8 // 第一步 取出最大的元素9，并且排序[9,8] 7,3,1,2,6 // 第二步 取出余下的最大元素8，并且将8直接push进之前的数组。[9,8,7] 3,1,2,6 // 后面就是取数，排序，然后不断重复，直到排序完成。[9,8,7,6] 3,1,2[9,8,7,6,3] 1,2[9,8,7,6,3,2] 1[9,8,7,6,3,2,1] 这个算法的时间复杂度也是O(n^2)，具体代码实现见下面： 12345678910111213141516function selsetSort(arr)&#123; var len = arr.length; var index; for(var i=0;i&lt;len-1;i++)&#123; index=i; for(var j=i+1;j&lt;len;j++)&#123; if(arr[index]&gt;arr[j])&#123;//寻找最小值 index=j;//保存最小值的索引 &#125; &#125; var temp =arr[i]; arr[i]=arr[index]; arr[index]=temp; &#125; return arr;&#125; 归并排序归并排序最大的意义就是化大为小，当你的资源（内存）不能够满足你一次性将所有的数据都排序完的时候，你就需要采用归并排序。 算法描述： 1.把 n 个记录看成 n 个长度为 1 的有序子表 2.进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 3.重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 老规矩，再以上面的数组来进行示例，7,3,1,2,9,6,8。 123456789101112137,3,1,2,9,6,8,5 // 第一步，把数组看成n个长度为1的有序子表 [7,3],[1,2],[9,6],[8,5] // 第二步，两两归并。[3,7],[1,2],[6,9],[5,8] // 第三步，小数组中进行排序。[3,7,1,2],[6,9,5,8] // 第四步，将小数组两两合并，长度变为4。[1,2,3,7],[5,6,8,9] // 第五步，继续小数组中排序。[1,2,3,7],[5,6,8,9] // 第六步，再合并小数组。1,2,3,5,6,7,8,9 // 第七步，再排序。 这个算法的时间复杂度为O(nlogn)，具体代码实现如下： 123456789101112131415161718function merge(left,right)&#123; var tmp=[]; while(left.length &amp;&amp; right.length)&#123; if(left[0]&lt;right[0])&#123; tmp.push(left.shift()); &#125;else&#123; tmp.push(right.shift()); &#125; &#125; return tmp&#125;function mergeSort(arr)&#123; if(arr.length==1) return arr; var mid=Math.floor(a.length/2), left=arr.slice(0,mid); right=arr.slice(mid); return merge(mergeSort(left),mergeSort(right))&#125; 冒泡排序这个属于最基本的一个排序方法，我现在还记得教科书上是怎么写的它的概念，它的核心理念就是两两相互比较，满足条件就不断向前比，直到比完所有的数，然后再进行下一次比较。 由于这个太简单，时间复杂度为O(n^2)，我就不写示例，直接上代码吧： 12345678910111213function bubbleSort(arr)&#123; var len=arr.length; for(var i=0;i&lt;len-1;i++)&#123; for(var j=i+1;j&lt;len;j++)&#123; if(arr[i]&lt;arr[j])&#123; var tmp = arr[j]; arr[j]=arr[i]; arr[i]=tmp &#125; &#125; &#125; return arr;&#125; 快速排序这算是排序算法中，效率最高，最经典，最有名，最广泛的一个排序方法了，所以我准备好好来讲讲快排。 算法描述： 在所需的排序数组之中，选择一个元素作为”基准”（pivot），可以随机选择，也可以选第一个或最后一个。 选中了基准值后，将剩下的值分别与这个选中的基准值做比较，将剩下的值按照大于或小于等于基准值分为两部分。 比如可以将所有小于基准的元素，都移到基准的左边；所有大于基准的元素，都移到基准的右边。这个操作称为分区 (partition)操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。 对基准左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 快排的时间复杂度是O(nlogn)，老样子，我用之前的数组来作为示例，7,3,1,2,9,6,8,5。 1234567891011121314151617181920212223242526277,3,1,2,9,6,8,5 [7],3,1,2,9,6,8,5 // 第一步，选中第一个元素为基准（也可以选择最后一个或者随机选择一个）[7],3,1,2,9,6,8,5 // 第二步，将剩下的值与基准值进行比较，比基准值大的放右边，小的放左边3,[7],1,2,9,6,8,5 3,1,[7],2,9,6,8,53,1,2,[7],9,6,8,53,1,2,[7],9,6,8,53,1,2,6,[7],9,8,53,1,2,6,[7],9,8,53,1,2,6,5,[7],9,8 // 此时，第一次循环就完了，这个时候基准数将数组变成了三部分，小的在左边，大的在右边，而它自己在中间，并且此时基准数的位置就是它在最终结果中的位置，所以我们可以暂时不管基准数了，然后将基准数左边和右边的数组再分别重复第一第二步，知道全部排序完成。[3],1,2,6,5,[7],[9],81,2,[3],6,5,[7],8,[9][1],2,[3],[6],5,[7],[8],[9][1],[2],[3],[5],[6],[7],[8],[9] // 此时就最终排序完成了。 具体的代码实现如下： 123456789101112131415function quickSort(arr)&#123; if(arr.length&lt;=1) return arr; var partitionIndex=Math.floor(arr.length/2); var tmp=arr[partitionIndex]; var left=[]; var right=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;tmp)&#123; left.push(arr[i]) &#125;else&#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat([tmp],quickSort(right))&#125;","tags":[]},{"title":"redux 店铺装修","date":"2017-05-04T06:29:18.000Z","path":"2017/05/04/react demo/","text":"最近在到处乱看一些项目相关的文档，发现了很很很麻烦的一个项目，刚好里面用到了redux，我发现简化一下的话，简直是redux的十分好的一个示例啊，比官网上简单的示例要难，又比难的简单，而且条理结构什么的又很清楚，挺不错的啊。 我先上图吧。图1图2图3图4图5图6图7图8 好吧，这图截的也是够大的，将就看看吧。。。由图1可以看到，页面一共分为四部分：左，中上，中下，右，也就是氛围四个组件：Left，Top，Center，Right。接下来我说一下交互，如图2所示；我在左边的输入框中输入东西，然后点击增加，可以看到，刚刚新增的数据立马在右边下面部分显示了出来，展示的是刚才新增的数据和一个删除按钮，如图3所示；若你点击展示的数据，那么在右边，也就是编辑组件中会出现一个输入框和编辑按钮，你可以在这里对刚刚点击的数据进行修改然后保存，如图4，图5所示；保存过后就可以看到中间的显示模块对数据进行了更新，如图6所示；接下来是中间上方的保存模块，你点击保存按钮，这个模块同样也能取到当前的数据，这里就用一个弹窗代替好了，如图7所示；最后就是删除按钮，点击后删掉当前这一行的数据，如图8所示。 好累，说了这么多，口都干了。其实吧，一两句话就可以说完的：在这四个组件中，每个组件都可以取到state，并且可以对state进行操作。说完了，是不是很简单啊。。。 我们先来看看index.js吧，也就是入口文件。 12345678910111213141516var App = React.createClass(&#123; render: function()&#123; return ( &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; &lt;LeftComponent /&gt; &lt;/div&gt; &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; borderRight: &apos;1px solid #999&apos;, minHeight: &apos;600px&apos;, textAlign: &apos;center&apos; &#125;&#125;&gt; &lt;TopComponent/&gt; &lt;CenterComponent/&gt; &lt;/div&gt; &lt;div className=&quot;col-sm-4&quot; style=&#123;&#123; textAlign: &apos;center&apos; &#125;&#125;&gt; &lt;RightComponent /&gt; &lt;/div&gt; &lt;/div&gt; ); 很简单吧，就是分别放了四个Component组件而已，我们也不用管这些组件是父子关系还是兄弟关系，因为redux不用考虑这些。然后我们去看看action吧。 12345678910111213141516171819202122232425262728// action module.exports = &#123; addModelAction: function(name)&#123; return &#123; type: &apos;ADD_MODEL&apos;, name: name &#125; &#125;, editModelAction: function(index, name) &#123; return &#123; type: &apos;EDIT_MODEL&apos;, index: index, name: name &#125; &#125;, deleteModelAction: function(index) &#123; return &#123; type: &apos;DELETE_MODEL&apos;, index: index &#125; &#125;, activeModelAction: function(index) &#123; return &#123; type: &apos;ACTIVE_MODEL&apos;, index: index &#125; &#125;&#125;; 在action.js这个文件里，我们写了四个action函数，每个函数都返回一个对象作为action，是不是很简单，每个action函数中返回的对象里type都是定义好了的，然后根据传入的参数来配置其他返回参数；然后再来看看reducer。 123456789101112131415161718192021222324252627// reducersvar modelReducer = function(state, action)&#123; switch(action.type)&#123; case &apos;ADD_MODEL&apos;: state.items.push(&#123; name: action.name &#125;); return state; break; case &apos;DELETE_MODEL&apos;: state.items.splice(action.index, 1); return state; break; case &apos;EDIT_MODEL&apos;: state.items[action.index].name = action.name; return state; break; case &apos;ACTIVE_MODEL&apos;: state.activeIndex = action.index; return state; break; default: return state; &#125;&#125;;module.exports = modelReducer; 这个也不难，我们都知道reducer需要传入两个参数：state和action，通过action里的type来对state进行相应的操作，最后return state。 好了，reducer和action都看了，redux三要素现在来看看store。 1234import &#123; createStore &#125; from &apos;redux&apos;import modelReducer from &apos;./reducer&apos;var store = createStore(modelReducer, &#123;items: [], activeIndex: -1 &#125;);module.exports = store; 对的，一共就这几行，store=createStore(modelReducer, {items: [], activeIndex: -1 })，第一个参数是reducer，必需的，另一个是state初始化的值，非必需，若不传则默认为undefined。 其实到这里，这个示例就已经到了尾声了；剩下的就是这四个组件的内部布局，还有就是给按钮绑定事件，当点击的时候用dispatch分发一个对应的action函数给reducer，这些我在之前也已经写过了，所以这里就不再赘述了。","tags":[]},{"title":"震惊！大多数前端都不知道的知识","date":"2017-04-11T12:56:08.000Z","path":"2017/04/11/震惊，大多数前端都还不知道这道题的答案/","text":"写在前面最近看了两篇不错的文章，都是和定时器（setTimeout）有关，所以我想写一篇博客，把那两篇文章能够融合、整理一下。至于标题，参照UC震惊部取的，笑一笑就好了。 正文话不多说，直接进入正题吧，看下面一段代码，结果会输出什么： 1234for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i) 当然是输出0，1，2，3，4，5呀，这么简单的东西也敢问人？ 好吧，我们再看看下面这段代码会输出什么： 123456for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 );&#125;console.log(i); 其实如果你对定时器（setTimeout）有个基本的了解的话，你就会清楚的知道，会输出5，5，5，5，5，5，OK？ 那我想问下，这六个5输出的状态是怎样的，比如在输出时中间的时间间隔关系是怎样的？ 这里有三个选项： A.5-&gt;5-&gt;5-&gt;5-&gt;5-&gt;5，每个5之间都会间隔1秒。 B.555555，所有5一起输出。 C.5-&gt;55555，第一个5输出，等待1秒后后面5个5一起输出。 好的，不卖关子，答案是C，这里面实际上就设计了比较多的知识点，比如同步和异步代码的区别，变量的作用域，闭包等概念，所以实际输出的时候，会先输出for循环外面的那个i，由于i经过了上面的for循环，所以此时i已经是5了，所以会先输出5，然后就是由于定时器的原因，for循环中定时器里有5个一样的console函数，它们都会等待一秒，然后会输出i，而这个时候的i，已经是循环之后的i了，所以会输出5，所以才会5个函数同时等待一秒后，5个5同时输出，这就是选C的原因。这就要求度js的定时器工作机制有基本的了解。 进阶上面的代码，输出方式为5-&gt;55555，那么，如果我想上面代码的输出变为：5-&gt;01234，那么会怎样，这里就考验了同学对于闭包的熟悉程度，其代码如下： 12345678for(var i=0;i&lt;4;i++)&#123; function(j)&#123; setTimeout(function()&#123; console.log(j) &#125;,1000); &#125;(i);&#125;console.log(i); 这里就是运用了IIFE来解决闭包造成的问题，其实我们可以把代码解藕一下，将IIFE函数提出来，就变成了下面这样： 123456789let func = function(j)&#123; setTimeout(function()&#123; console.log(j) &#125;,1000); &#125;for(var i=0;i&lt;5;i++)&#123; func(i);&#125;console.log(i); 既然都到了这里，那么如果我想输出结果变成这样，5-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4,代码应该怎么写？ 123456789let func = function(i)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i);&#125;for(var i=0;i&lt;5;i++)&#123; func(i)&#125;console.log(i); 这里其实已经考察了闭包的灵活运用了，假设把func函数中的形参去掉，变成这样，结果会是怎样的？ 12345678let func = function(/*去掉这里的形参*/)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i);&#125;for(var i=0;i&lt;5;i++)&#123; func(i);&#125; 这样的话，定时器函数的内部就没有保持对外部i的引用，就会变成5-&gt;5-&gt;5-&gt;5-&gt;5。 好吧前面都是小大小闹，看看这里，假设定时器里面传入的不是函数，而是一个IIFE函数的话，结果会怎样？ 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; 这就变成了传入一个IIFE函数进去，setTimeout可以接受一个函数或者字符串作为参数，可是这里的IIFE函数，会怎样呢？所以这里的定时器此时就没有任何的作用了，所以会直接一下子输出01234，不会有定时器功能。 ES6 Promise完了吗？还早呢，这全是回调函数，ES6中的Promise现在已经用得比较广泛了，好吧，现在将上面的代码采用Promise来改写一下，应该怎么写？ 12345678910111213141516const arr = []; // 这里存放异步操作的Promisevar func = function(i)&#123; new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i); &#125;);&#125;for(var i=0;i&lt;5;i++)&#123; arr.push(func(i));&#125;Promise.all(arr).then(()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000);&#125;) 上面就是采用Promise来改写后的代码，这里考察了Promise的熟练运用和新技术的学习，虽然Promise不算什么新技术呢。。。 ES7 async/await好吧，既然Promise不算什么新的技术，那我们来看看新的技术——acync/await函数。老规矩，将上面的异步代码用ES7中的async/await函数重写一下。 123456789101112const sleep = (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, time); &#125;);&#125;(async () =&gt; &#123; for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(i); &#125;&#125;)(); 注意：await后面可以是一个异步函数也可以不是，我之前在sleep中的Promise忘了加上return，结果定时器就没有发生作用。。。无语。 好了ES6的Promise和ES7的async/await函数都讲到了，下面来看下最后一道题： 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 这道题其实初看，还是挺难的，异步就有promise和setTimeout，还有for循环来分散你的注意力，也是危机四伏啊。 其实没必要这么麻烦，我们可以先基本看一遍，知道其主要意思，就是让你去分一下异步与同步，同时还有两种异步来让你去分先后顺序；所以首先，我们需要来去分一下这段代码中的同步和异步先将同步与异步分开，首先来看，哪些是同步哪些是异步：按先后顺序来说，同步的有2，3，5；异步的是1和4。而且结果中，肯定是同步在前异步在后，所以结果应该是（2，3，5）（1，4），括号中的顺序可能会有改动，然后在来每个仔细分析一下，首先是同步，同步其实很简单，就是简单的按先后顺序输出，所以前面的2，3，5，顺序不用改变，这里有一些小陷阱，比如setTimeout的定时为0，其实这还是一个定时器，接下来就是有一个9999的循环，其实这个并不会影响什么，也不需要太在意这个；最后，再来看看异步，先是一个setTimeout的console.log(1)，然后是Promise的回调console.log(4)，假设是两个相同的异步，比如都是setTimeout或者都是Promise，那么也很简单，也将会是按先后顺序输出，现在问题来了，那么setTimeout和Promise这两种回调方法，有什么差异呢？如果在回调上没有差异，那么就是按先后顺序了，结果呢？Promise和setTimeout回调最大的区别在于，Promise的回调，会放在当前事件队列的末尾，但是setTimeout不是，它会放在下一个事件队列的头部，所以Promise比setTimeout会更快执行回调，所以是Promise的回调先输出，所以最终结果也就是2，3，5，4，1。","tags":[]},{"title":"promise 详解","date":"2017-04-06T06:41:48.000Z","path":"2017/04/06/promise/","text":"虽然之前写了javascript异步编程，不过我发现周围的部分小伙伴，当然也包括我，对promise的认识还是只停留在基础是使用，类似于ajax这种的使用，或者会用promise.then()，对于原生的Promise对象只了解一点甚至不了解，我也是模模糊糊地了解，所以准备写一篇关于promise的博客，顺便也借此机会一举击破promise，不想再搞得模模糊糊的了，彻底得解决掉这个东西。 在去年，准确的说是在2015年6月（我专门查了的，肯定没有错），ECMAScript6的正式版发布了。ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ES6 的目标，是使得 JavaScript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 ES6的改变还是算不小的，其中就包含了提供Promise对象。 Promise是什么？首先，它是一个对象，它的作用是用来进行异步操作，代表着某个异步进行的事件的结果。 Promise对象有以下两个特点： （1），对象的状态不受外界的影线。Promise对象代表一个异步的操作，它包含了三种状态，分别是：Pending（进行中），Resolve（已完成），Reject（已失败）。而异步操作的结果，决定了它将会输出哪一种状态，任何其它操作都无法改变这个状态。这也是Promise名字的由来，也就是承诺的意思，代表一定会去做。 （2），一旦状态改变，就不会再变。虽然Promise不受外界影响状态，不过状态是会在内部进行改变的，它有两种改变状态的可能，一种是从进行中变为已完成（Pending to Resolve），另一种是从进行中变为已失败（Pending to Reject）。除此之外，状态不会再发生其它的变化。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 CODE“talk is cheap,show me the code”. 这是程序员界比较常见的一句话，上面很多概念啊这些死知识讲解完了，下面才开始进入正题，开始代码演示。 由于Promise已经是JS原生对象了，所以直接打开浏览器的控制台，输入Promise，就可以看到一个function Promise，如果报错的话，说明你的浏览器该升级了。 1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 如上面的基本代码所示，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject方法，如果异步操作成功了，则调用resolve方法，将Promise对象的状态从Pending改为Resolve，如果异步操作失败，则调用reject方法，将Promise对象的状态从Pending改为Reject。这是promise最基本的使用方法。 promise的神奇之处在于给了我们return和throw，每个promise都会提供一个then函数和一个catch函数，实际上是then(null,…)函数。基本代码如下： 1234promiseOne.then(function(value)&#123; alert(value); // 这个value是promiseOne中resolve传递出来的值。 // do something&#125;); 在这个then函数里面，我们可以做三件事，1，return 另一个promise；2，return 一个同步的值；3，throw 一个同步异常，‘ throw new Error(‘’) ’。 下面是一些Promise的基本API。 1234561,Promise.resolve()2,Promise.reject()3,Promise.prototype.then()4,Promise.prototype.catch()5,Promise.all([functionOne,functionTwo,...]) // 所有的完成6,Promise.race([functionOne,functionTwo,...]) // 竞速，完成一个即可 Promise.resolve和Promise.reject是Promise的静态方法，使用方法如下： 1234567891011121314Promise.resolve(&quot;value&quot;).then(function(v) &#123; console.log(v,1); &#125;, function(v) &#123; // 不会被调用console.log(v,2);&#125;);// 这时控制台会输出 value,1Promise.resolve(&quot;value&quot;).then(function(v) &#123; console.log(v,1); &#125;, function(v) &#123; console.log(v,2);&#125;);// 这时控制台会输出 value,2 也就是说，Promise.resolve里传入的参数或者promise对象，会被then方法接收，Promise.reject里传入的参数或者promise对象，会被catch方法接收，这一点在上面的new Promise((resolve,reject)=&gt;{if(…){resolve(v)}else{reject(v)}})已经讲过了，意思是一样的，不同之处在于使用的方式不同，下面的方法是直接调用的promise里的静态方法，而没有用到promise这个构造函数。 除了返回基本数据外，一个promise里面也可以返回另一个promise对象。 123456var original = Promise.resolve(true);var cast = Promise.resolve(original);cast.then(function(v) &#123; console.log(v); &#125;);// 控制台会输出 true 我们也可以在promise中抛出异常，这里有同步代码异常和异步代码异常两种。 这是同步代码异常，直接调用promise的reject方法，传入一个error就好了： 1Promise.reject(new Error(&quot;什么鬼&quot;)); 下面是异步代码异常： 12345new Promise(function (resolve, reject) &#123; throw new Error(&apos;悲剧了，又出 bug 了&apos;); &#125;).catch(function(err)&#123; console.log(err); &#125;); 如果有多个callback函数连续回调，可以分别写成promise的状态，然后在每一个promise对象中return下一个promise，for example: 123456789101112131415161718192021222324252627282930313233343536373839var p1 = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;);var p2 = new Promise((resolve,reject)=&gt;&#123; resolve(p1);&#125;);var p3 = new Promise((resolve,reject)=&gt;&#123; resolve(p2);&#125;);p3.then(function(v) &#123; console.log(v); // true&#125;);// 上面是promise链式调用的一种情况，下面是另一种情况，其核心原因都是差不多的。var p1 = (resolve,reject)=&gt;&#123; resolve(1);&#125;var p2 = (resolve,reject)=&gt;&#123; resolve(2);&#125;var p3 = (resolve,reject)=&gt;&#123; resolve(3);&#125;new Promise(p3).then(function(v) &#123; console.log(v); return new Promise(p2).then((v)=&gt;&#123; console.log(v) return new Promise(p1).then((v)=&gt;&#123; console.log(v) &#125;) &#125;)&#125;)","tags":[]},{"title":"http cache","date":"2017-04-05T09:15:07.000Z","path":"2017/04/05/http cache/","text":"翻译：https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#_2","tags":[]},{"title":"javascript事件机制","date":"2017-03-31T10:18:12.000Z","path":"2017/03/31/js事件机制/","text":"js事件基础先简单介绍一下js的事件吧，其就是你通过一些工具（鼠标，键盘，触摸板，手指等）在网站进行的一系列操作，滚动，点击，触摸，移动等，我们在代码中先定义了这些事件，然后当对应的事件发生的时候，我们所定义的事件就会被自动触发，执行；这就是js的事件，可是这内部的核心机制是什么呢，占个坑，以后有心情了再来补上。","tags":[]},{"title":"fastClick 基本解读","date":"2017-03-23T06:57:59.000Z","path":"2017/03/23/fastClick/","text":"fast click诞生背景与使用做过移动端前端的同学，应该都知道“点击延迟”，意思就是原生js的click事件在移动浏览器上会有300毫秒的延迟，这样就会让用户觉得卡顿，影响用户体验。为什么会有延迟呢？因为移动浏览器都是支持双击的，比如双击缩放或双击滚动，所以当用户第一次点击屏幕后，浏览器并不知道你是单击还是双击，因此所有的浏览器都效仿了Safari的做法，那就是等待300毫秒。 现在移动端大行其道，已经占据了主流。最显著的一个例子就是，天猫双十一的时候，超过百分之八十的订单都来自于移动端，这也就说明了移动端现在的火热程度。在这个前提下，你移动端的每个点击事件都有300毫秒的延迟，那是绝对不允许的。 后面也出现了很多的解决办法，比如Zepto的tab事件(会引发击穿tab的bug)，fastClick.js等等，所以现在我就准备来好好讲解一下fastClick。 解析引入fastClick源码的第829行：选择引入fastClick的方式，具体代码如下： 1234567891011121314if (typeof define === &apos;function&apos; &amp;&amp; typeof define.amd === &apos;object&apos; &amp;&amp; define.amd) &#123; // 优先兼容AMD的方式 define(function() &#123; return FastClick; &#125;);&#125; else if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; // 其次是commonJs module.exports = FastClick.attach; module.exports.FastClick = FastClick;&#125; else &#123; // 最后兼容原生js window.FastClick = FastClick;&#125; 入口源码第824行：fastClick入口方法 attach 123456// 这里是通过return一个newFastClick函数来进行继承的// 其中layer参数是指的要监听的dom对象// option是用来覆盖自定义参数FastClick.attach = function(layer, options) &#123; return new FastClick(layer, options);&#125;; FastClick 主函数第23行到103行，这里主要是设置一些参数的默认值，这些参数就是FastClick的精华所在，也就是上面option参数中的默认参数值，其代码大致如下。 12345678910this.trackingClick = false;this.trackingClickStart = 0;this.targetElement = null;this.touchStartX = 0;this.touchStartY = 0;this.lastTouchIdentifier = 0;this.touchBoundary = options.touchBoundary || 10;this.layer = layer;this.tapDelay = options.tapDelay || 200;this.tapTimeout = options.tapTimeout || 700; 判断是否需要fastClick第105到107行，判断是否需要引入fastClick，如果不需要则return。 123if (FastClick.notNeeded(layer)) &#123; return;&#125; 话说回来，并不是任何时候都需要引入fastClick的，其官网上面就说得很清楚，下面几种情况，是不需要引入fastClick的。 1，所有pc浏览器。 2，浏览器不支持ontouchstart。 3，安卓中chrome meta中有禁止缩放（user-scalable=”no”）。 4，安卓中chrome meta中有width=”device-width”。 5，黑莓 10.3+。 6，firefox 27+。 7，有-ms-touch-action: manipulation属性的IE10。 8，有touch-action: manipulation属性的IE11。 将自定义的函数绑定在传入的dom节点上第110行到132行。 1234layer.addEventListener(&apos;touchstart&apos;, this.onTouchStart, false);layer.addEventListener(&apos;touchmove&apos;, this.onTouchMove, false);layer.addEventListener(&apos;touchend&apos;, this.onTouchEnd, false);layer.addEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false); 对旧版本android不支持 stopImmediatePropagation 事件的兼容第137行到159行。 这里可以简单说一下 stopImmediatePropagation 和 stopPropagation 的区别吧。stopPropagation是阻止事件冒泡到父级元素，这是最基本的，而stopImmediatePropagation除了能够达到这个要求外，还额外执行了一件事，就是阻止绑定在事件元素的其它同类事件的回调函数的运行，比如下面的示例： 1234567$(&quot;p&quot;).click(function(event) &#123; event.stopImmediatePropagation();&#125;);$(&quot;p&quot;).click(function(event) &#123; // 不会执行以下代码 $(this).css(&quot;background-color&quot;, &quot;#f00&quot;);&#125;); 兼容直接绑定在dom元素上的onclick事件第164行到173行。 1234567if (typeof layer.onclick === &apos;function&apos;) &#123; oldOnClick = layer.onclick; layer.addEventListener(&apos;click&apos;, function(event) &#123; oldOnClick(event); &#125;, false); layer.onclick = null;&#125; 先判定html元素的元素内部是否直接写了onclick事件，类似于这样：，如果有的话，将其使用js绑定在dom上，然后将html元素内的事件清空。 这是为了之后的模拟点击事件。 判断用户终端178-221 通过navigator.userAgent来判断用户的终端类型，其中有个问题是“Windows Phone 8.1 fakes user agent string to look like Android and iPhone.”，所以在判断安卓和iOS的时候需要有一个判断前提，就是非window phone的时候。 needsClick函数，needsFocus函数227-254 判断哪些元素需要原生的click事件，哪些需要原生的focus事件。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051FastClick.prototype.needsClick = function(target) &#123; switch (target.nodeName.toLowerCase()) &#123; // Don&apos;t send a synthetic click to disabled inputs (issue #62) case &apos;button&apos;: case &apos;select&apos;: case &apos;textarea&apos;: if (target.disabled) &#123; return true; &#125; break; case &apos;input&apos;: // File inputs need real clicks on iOS 6 due to a browser bug (issue #68) if ((deviceIsIOS &amp;&amp; target.type === &apos;file&apos;) || target.disabled) &#123; return true; &#125; break; case &apos;label&apos;: case &apos;iframe&apos;: // iOS8 homescreen apps can prevent events bubbling into frames case &apos;video&apos;: return true; &#125; return (/\\bneedsclick\\b/).test(target.className);&#125;;FastClick.prototype.needsFocus = function(target) &#123; switch (target.nodeName.toLowerCase()) &#123; case &apos;textarea&apos;: return true; case &apos;select&apos;: return !deviceIsAndroid; case &apos;input&apos;: switch (target.type) &#123; case &apos;button&apos;: case &apos;checkbox&apos;: case &apos;file&apos;: case &apos;image&apos;: case &apos;radio&apos;: case &apos;submit&apos;: return false; &#125; // No point in attempting to focus disabled inputs return !target.disabled &amp;&amp; !target.readOnly; default: return (/\\bneedsfocus\\b/).test(target.className); &#125;&#125;; 上面这些就是哪些要原生click，原生focus的元素。如果需要，只需要在dom元素的class中加上“needsClick”或者“needsFocus”。像这样： 1&lt;div class=&quot;needsclick&quot;&gt;aaaa&lt;/div&gt; 各种判断311-319行：determineEventType 兼容安卓chrome中的select框事件从click改为mousedown 12345678FastClick.prototype.determineEventType = function(targetElement) &#123; //Issue #159: Android Chrome Select Box does not open with a synthetic click event if (deviceIsAndroid &amp;&amp; targetElement.tagName.toLowerCase() === &apos;select&apos;) &#123; return &apos;mousedown&apos;; &#125; return &apos;click&apos;;&#125;; 327-337行：focus函数 兼容苹果手机(iOS7)setSelectionRange不能正确获取焦点的bug 123456789101112FastClick.prototype.focus = function(targetElement) &#123; var length; // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don&apos;t have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can&apos;t be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724. if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123; length = targetElement.value.length; targetElement.setSelectionRange(length, length); &#125; else &#123; targetElement.focus(); &#125;&#125;; 376-384行：getTargetElementFromEventTarget函数，兼容获取点击元素，iOS 4.1中会获取文字作为焦点，取它的父元素dom 1234567FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) &#123; // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node. if (eventTarget.nodeType === Node.TEXT_NODE) &#123; return eventTarget.parentNode; &#125; return eventTarget;&#125;; 497-512行：findControl函数，为了点击label元素的时候能改找到其所对应的表单元素的焦点 123456789101112131415FastClick.prototype.findControl = function(labelElement) &#123; // Fast path for newer browsers supporting the HTML5 control attribute if (labelElement.control !== undefined) &#123; return labelElement.control; &#125; // All browsers under test that support touch events also support the HTML5 htmlFor attribute if (labelElement.htmlFor) &#123; return document.getElementById(labelElement.htmlFor); &#125; // If no for attribute exists, attempt to retrieve the first labellable descendant element // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label return labelElement.querySelector(&apos;button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea&apos;);&#125;; 461-469：touchHasMoved 手指点击时移动间距大于10px，返回true 123456789FastClick.prototype.touchHasMoved = function(event) &#123; var touch = event.changedTouches[0], boundary = this.touchBoundary; if (Math.abs(touch.pageX - this.touchStartX) &gt; boundary || Math.abs(touch.pageY - this.touchStartY) &gt; boundary) &#123; return true; &#125; return false;&#125;; 478-490：onTouchMove 手指点击时移动间距大于10px，即视为touchmove，不触发模拟click事件 12345678910111213FastClick.prototype.onTouchMove = function(event) &#123; if (!this.trackingClick) &#123; return true; &#125; // If the touch has moved, cancel the click tracking if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) &#123; this.trackingClick = false; this.targetElement = null; &#125; return true;&#125;; 核心方法393-452：onTouchStart函数，tapDelay默认300毫秒，点击时间差小于300毫秒，则阻止事件再次触发，阻止短时间内双击的问题 123456789101112131415161718192021222324252627282930313233343536373839FastClick.prototype.onTouchStart = function(event) &#123; var targetElement, touch, selection; if (event.targetTouches.length &gt; 1) &#123; return true; &#125; targetElement = this.getTargetElementFromEventTarget(event.target); touch = event.targetTouches[0]; if (deviceIsIOS) &#123; selection = window.getSelection(); if (selection.rangeCount &amp;&amp; !selection.isCollapsed) &#123; return true; &#125; if (!deviceIsIOS4) &#123; if (touch.identifier &amp;&amp; touch.identifier === this.lastTouchIdentifier) &#123; event.preventDefault(); return false; &#125; this.lastTouchIdentifier = touch.identifier; this.updateScrollParent(targetElement); &#125; &#125; this.trackingClick = true; this.trackingClickStart = event.timeStamp; this.targetElement = targetElement; this.touchStartX = touch.pageX; this.touchStartY = touch.pageY; if ((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123; event.preventDefault(); &#125; return true;&#125;; 523-612：onTouchEnd函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576FastClick.prototype.onTouchEnd = function(event) &#123; var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement; if (!this.trackingClick) &#123; return true; &#125; if ((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123; this.cancelNextClick = true; return true; &#125; if ((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123; return true; &#125; this.cancelNextClick = false; this.lastClickTime = event.timeStamp; trackingClickStart = this.trackingClickStart; this.trackingClick = false; this.trackingClickStart = 0; if (deviceIsIOSWithBadTarget) &#123; touch = event.changedTouches[0]; targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement; targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent; &#125; targetTagName = targetElement.tagName.toLowerCase(); if (targetTagName === &apos;label&apos;) &#123; forElement = this.findControl(targetElement); if (forElement) &#123; this.focus(targetElement); if (deviceIsAndroid) &#123; return false; &#125; targetElement = forElement; &#125; &#125; else if (this.needsFocus(targetElement)) &#123; if ((event.timeStamp - trackingClickStart) &gt; 100 || (deviceIsIOS &amp;&amp; window.top !== window &amp;&amp; targetTagName === &apos;input&apos;)) &#123; this.targetElement = null; return false; &#125; this.focus(targetElement); this.sendClick(targetElement, event); // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others) if (!deviceIsIOS || targetTagName !== &apos;select&apos;) &#123; this.targetElement = null; event.preventDefault(); &#125; return false; &#125; if (deviceIsIOS &amp;&amp; !deviceIsIOS4) &#123; if (scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123; return true; &#125; &#125; if (!this.needsClick(targetElement)) &#123; // 如果这不是一个需要使用原生click的元素，则屏蔽原生事件，避免触发两次click // 触发一次模拟的click event.preventDefault(); this.sendClick(targetElement, event); &#125; return false;&#125;; 296-311 sendClick（核心方法）12345678910111213141516FastClick.prototype.sendClick = function(targetElement, event) &#123; var clickEvent, touch; if (document.activeElement &amp;&amp; document.activeElement !== targetElement) &#123; document.activeElement.blur(); &#125; touch = event.changedTouches[0]; // 合并成一个点击事件，通过一个额外的属性，确保事件能够被跟踪 // 最后再通过模拟一个点击事件来执行，事件触发器dispatchEvent参考这篇文章 http://blog.csdn.net/magic__man/article/details/51831227 clickEvent = document.createEvent(&apos;MouseEvents&apos;); clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null); clickEvent.forwardedTouchEvent = true; targetElement.dispatchEvent(clickEvent);&#125;; Zepto 点击穿透与 FastClick移动端点击事件中，Zepto中也解决了移动浏览器中300毫秒的事情，但是就出现了各种击穿现象。 1，同页面tap点击弹出弹层，弹层中也有一个button，正好重叠的时候，会出现击穿。 2，tap事件点击，页面跳转，新页面中同位置也有一个按钮，会出现击穿。 解释击穿zepto中的 tap 通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，是通过事件冒泡实现的。在点击完成时（touchstart / touchend）的 tap 事件需要冒泡到 document 上才会触发。而在冒泡到 document 之前，手指接触和离开屏幕（touchstart / touchend）是会触发 click 事件的。 因为 click 事件有延迟（大概是300ms，为了实现safari的双击事件的设计），所以在执行完 tap 事件之后，弹出层立马就隐藏了，此时 click 事件还在延迟的 300ms 之中。当 300ms 到来的时候，click 到的其实是隐藏元素下方的元素。 如果正下方的元素有绑定 click 事件，此时便会触发，如果没有绑定 click 事件的话就当没发生。如果正下方的是 input 输入框（或是 select / radio / checkbox），点击默认 focus 而弹出输入键盘，也就出现了上面的“点透”现象。 击穿的解决办法遮挡由于移动端点击click事件的延后性，导致原本想点击的元素消失了，直接点击到了下面的元素，于是便有了穿透。于是最简单的办法就是在你点击的下方增加一层遮挡的元素，让其300毫秒后自动消失就行了；或者不用延时动画，改为增加一个透明的元素来隔离，也是可以的；这样就从dom方面对其进行了隔离，解决了穿透的问题。 pointer-eventspointer-events是CSS3中的属性，它有很多取值，有用的主要是auto和none，其他属性值为SVG服务。 如果pointer-events的属性值为none，元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。具体实现代码如下： 12345678910$(&apos;#closePopup&apos;).on(&apos;tap&apos;, function(e)&#123; $(&apos;#popupLayer&apos;).hide(); $(&apos;#bgMask&apos;).hide(); $(&apos;#underLayer&apos;).css(&apos;pointer-events&apos;, &apos;none&apos;); setTimeout(function()&#123; $(&apos;#underLayer&apos;).css(&apos;pointer-events&apos;, &apos;auto&apos;); &#125;, 400);&#125;); fastClick使用fastclick库，其实现思路是，取消 click 事件，用 touchend 模拟快速点击行为。只需要一句FastClick.attach(document.body); 从此所有的点击事件，都是用click且不会出现穿透问题，并且没有300毫秒的延迟。 下一篇博客，我会对js的事件机制做一个详细的分析，包括移动端的。","tags":[]},{"title":"ES6中的暂时性死区（TDZ）","date":"2017-03-20T11:55:30.000Z","path":"2017/03/20/ES6 TDZ/","text":"起因故事要从阮一峰老师的一条微博开始说起。。。 这条微博下面有很多的评论，有的厉害的人一眼就指出了这是由于TDZ的原因，并不是什么V8的bug，TDZ是什么？下面我们就来慢慢揭开这层面纱。 变量提升先从最简单的变量提升说起。 12345678console.log(a);var a = 123;// 这里会输出undefined，原因是上面这段代码和下面的这段代码是等价的var a;console.log(a);a = 123; 在ES6中，除了var关键字意外，还多了let和const关键字，有什么差异呢？ 先说const吧，const的意思是定义静态常量，是不可变的，所以我们可以先来开脑洞想想，当const遇上变量提升，会发生什么？ 12345678console.log(a);const a = 123;// 如果const的变量提升存在，则上面代码应该和下面代码等价const a;console.log(a);a = 123; 想必大家都发现问题了吧，很明显，前面说了const是定义的静态常量，是不可变的，假设上面的代码是对的，那么最开始a应该是undefined，可是后面却被再次赋值成了123，和const定义的静态常量不可改变相违背，所以这里就有问题，所以const没有变量提升？至少现在看起来，const是不应该有变量提升的。 然后再来看看let关键字，和上面一样，当let遇见变量提升，又会怎样呢？老规矩，上代码吧。 12345678console.log(a);let a = 123;// 如果let的变量提升存在，则上面代码应该和下面代码等价let a;console.log(a);a = 123; 这段代码，至少看起来是没有问题的，不是吗？可是实际有问题没有，还是要放进浏览器中运行一下才知道，所以我们把这段代码放进chrome里看看。 可惜，似乎很不幸。。。 所以照现在看来，const和let都是没有变量提升的，对吧。 然后我们来看下面一段代码。 123456let e = 12;(function()&#123;console.log(e);let e = 123;&#125;)()// 如果说let真的没有变量提升的话，那么这里应该打印出12，OK？实际上如何呢，还是把代码放进浏览器中运行看看吧。 怎么会是这样呢，不是说好的没有变量提升吗，怎么会报错啊？下面我们来细细分析。 let const 详解在ES6中，最常见的TDZ就是在let/const的使用上，根据ES6中对let/const声明的章节，原文是这样说的： 1The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. 这段话的意思是说，由let/const声明的变量，当它们包含的词法环境实例化时，才会被创建；且只有在变量的词法绑定已经被赋值后，才能被访问（使用）。 这段话详细地说，就是在程序在其词法环境（也就是其对应的作用域，比如模块，函数，块级作用域等）就行实例化的时候，（let/const声明的）变量就已经被创建了，但是这个时候还不能被访问（此时访问会出现not defined），只有当这个变量的词法绑定被赋值后，才能进行访问这个变量，也就是说当这个变量被赋值后，才能正常访问。所以在变量创建到变量赋值这一段时间内，访问时会报错，这段时间就叫做TDZ（暂时死区）。 因此，从上面看来，似乎let/const声明的变量，还是有变量提升（hoist）的作用的，所以这里也是会让很多人误解的地方，实际上，JS中的变量都有变量提升，这是JS语言中，变量的基本特性，but，因为TDZ的作用，所以let/const的变量提升并没有像var那样明显地得到undefined，而是会直接报错：not defined；而且这很明显是一个运行期间才会出现的问题。 所以上面提到的那个例子就已经说明了let也有变量提升，我们再来分析一下这个例子。 123456let e = 12;(function()&#123;// TDZ startconsole.log(e);let e = 123; // TDZ end&#125;)() 在这个IIFE函数中，本来console.log的时候，应该现在函数内部找，找不到的话再往外面找；可是由于下面，e又被在这个函数内重新定义赋值了，虽然是在console.log下面，但是由于是有变量提升的，所以在对应的作用域顶端（也就是这个IIFE函数的顶端），是TDZ start，然后直到这个变量被赋值，才是TDZ end，这中间的区域就叫做TDZ；因此，在console的时候由于内部又声明了变量e，所以在内部找到了变量e于是就不用继续往外面找了，因此不会输出12，又因为console的区域刚好处在TDZ的区域内，所以就算变量e被声明了，可是由于TDZ的存在，在变量被赋值之前暂时还不能访问，所以此时访问会出现报错“not defined”。 在ES6中的let与const声明章节的后面几句，说明了有关变量是如何进行初始化的： 1A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated. 这几句是关于变量初始化的过程的。以let/const所声明的变量（const声明的变量叫做固定的变量），必须是经过声明的赋值语句的求值后，才算初始化完成，而不是创建后就初始化完成。let/var声明过后如果没有赋予初始值，那么会赋值为undefined，但是const不行，const声明了变量后一定需要赋初始值的。初始化完成后才代表TDZ的真正结束，这些在作用域中被声明的变量才能被正常的访问。 下面的示例是一个未初始化完成的结果，它还在TDZ中，所以会发生错误，“x is not defined”。 1let x = x; 因为等号右边的x，它在此时还是一个未被初始化完成的变量，实际上我们就在这同一个表达式中要初始化它。 函数传参预设值TDZ作用在ES6中，很明确的就是与区块作用域(block scope)，以及变量/常量的要如何被初始化有关。实际上在许多ES6新特性中都有出现TDZ作用，而另一个常会被提及的是函数的传参预设值中的TDZ作用。 直接上示例把，看下面的代码。 123456789function foo(x=y,y=1)&#123; console.log(y)&#125;foo(1) // 这不会有错误foo(undefined, 1) // 错误 ReferenceError: y is not definedfoo() // 错误 ReferenceError: y is not defined 上面这些报错的主要原因是在函数声明时传入的形参初始化的这里，x=y,y=1可以看成let x=y,let y=1，这样应该就会清晰很多。 当然，对于传参预设值的作用域，也是作用域话题里一个常被讨论的话题，讨论这到底是属于“全局作用域”还是“函数中的作用域”，抑或是处于这两者之间的“中介区域”？现在看到比较常见的一种说法就是，它是处于“中介的作用域”，夹在这两者之间，仍然会与其它作用域相互影响。一个比较明显的示例就是，使用其它函数作为作为传参的预设值，这通常会是一个回调函数，一般情况下本没什么，但是涉及到作用域相互影响的时候，就会比较难以理解，比如这个示例，我将它大致的整理了一下。 123456789101112let x = 1;function foo(a = 1, b=function()&#123;x = 2;&#125; )&#123; let x = 3; b(); console.log(x);&#125;foo();console.log(x); 上面这个例子，最后会输出什么呢？ 这里有两个console，里面外面各一个，所以会输出两个值，里面的x的值是多少，要看作用域之间相互的影响，而外面的x的值，要看最外围的作用域最后会不会被改变，这也是一个问题。 下面来详细分解一下，函数foo中的x，值可能是2，也可能是3，肯定不是1，这个可以理解吧；而函数外面的那个x，值可能是1，也可能是2，绝不可能是3，这个也可以理解吧。 具体答案是多少？我不知道，或者说没有具体答案，我们可以分别用浏览器和编译器来运行一下代码试试：chrome下面会分别输出3和2，firefox下面会分别输出2和1，然后我就感到奇怪，再使用Edge来试试，结果发现会输出3与2，最后再使用著名的babel编译器，得出的结果是2与1，暂时看来，结果应该有2个，3与2或者2与1，我们分别来分析一下这两个答案吧，看看是什么问题让浏览器都没有统一的答案。 当结果是3与2的时候，说明b函数中的x=2运行了出来，但是由于中介作用域的影响，所以干扰不到函数中原本的区块作用域，但是直接改变了全局x的值。也就是几本认为了函数预设值中的那个函数中的作用域与全局（或者说是函数外层）有影响。 当结果是2与1的时候，就倒过来，中介作用域影响了函数内层的作用域，而没有影响外层的作用域。 因此，只有当中介作用域有自己独立的作用域的时候，完全与函数区块中的作用域以及函数外层中的作用域毫不相干的时候，那这个时候就会输出3与1，很遗憾，现在都是3与2或者2与1，看来中介作用域还是和函数外层（或者内层相关的），至于具体是外层韩还是内层，这个问题现在还没有一个明确的结果吧，否则各种浏览器的输出也就不会有差异了，不只这一个问题，chrome和firefox的差异还有其它，这里就不细讲了。 不管如何，这个作用域的影响仍然是有争议的，目前并没有统一的答案。这代表ES6虽然标准定好了，但里面的一些新特性仍然有实作细节的差异，未来有可能这些差异才会慢慢一致。但对一般的开发者来说，因为知道了有这些情况，所以要尽量避免，以免产生不必要的麻烦。 TDZ的其它陷阱typeof语句1234567// 一般来说，typeof 一个未定义的数据，都是undefined，因此typeof也可以作为判断变量是否存在（被赋值）的一种方法，那是因为之前没有let和const。typeof a; // undefinedtypeof b; // b is not definedlet b=1; 现在typeof也变得不安全了，你不能随意的对变量使用typeof操作，因为现在会有报错的风险，会变成一个陷阱，由于TDZ的设计，使得变量本就不该在声明前被访问。 TDZ期间抛出的错误是运行阶段的错误TDZ期间的错误，全部是运行阶段才会发生的错误，因为它需要变量／常量初始化的过程，在这个过程中，才会创建出TDZ，且真正运行到那里，调用到函数运行里面的代码时，才会TDZ相关的错误才会被抛出。 不用let/const ？其实没错，只要你声明变量的时候，不管局部还是全部，全部使用var，那么你就根本不用关心TDZ。 可是，在浏览器上的运行效能来看，大多数情况下，let效能比var强，且会有块级作用域的概念，这会减少因为局部变量／全局变量所引起的问题，而且let对变量有了更高的要求与标准，比如不允许未定义就使用；不允许重复定义等。。。 最后，附上一篇我做分享时做的展示文稿吧，https://pan.baidu.com/s/1hsl1SVi。。。","tags":[]},{"title":"react生命周期解读","date":"2017-02-14T12:54:04.000Z","path":"2017/02/14/react生命周期/","text":"前几天在工作中出现了一个比较怪异的bug，不过还好由于react的单向数据流，从最外层父组件一层一层地往里面找，在每一层都检查一下state和props的值是否正确，总会找到问题，只不过那个组件被前人嵌套了四五层，所以在定位问题的时候比较蛋疼，所以还是最好养成良好的习惯，组件嵌套层级不要太多，而且在开发的时候每一层就别忘了检测props和state，否则后来人会很累的。。。 经过了long long time，才在某一层组件中找到了问题，具体问题是父组件传入的props改变后子组件通过props来渲染的页面没有发生改变，有疑问吗？父组件传入的props改变，子组件的props不是会自动接收变化并且render吗？嗯，是的，为什么这里没有呢。。。原来有人在开发的时候在getInitialState函数中加了这么一句：this.state.xxx = this.props.xxx，通过这样，他就把props和state关联了起来，心中顿时有无数草泥马狂奔。。。怎么改呢？难道要我把和state关联了的props都取消关联？这个工作量不小。。。还好，react里有个监测props变化的函数：componentWillReceiveProps，然后我再在里面把更新后的props和state关联起来，让state等于新的props就好了，大功告成，这个怪异的问题就解决了。 有人会觉得奇怪吗？为什么在getInitialState函数中使用了this.state.xxx = this.props.xxx，而在当props更新后传进来时，state依然等于原来的props，这就说到了本片文章的主要，就是react的生命周期。 react组件的详细说明和生命周期先来说一下react场见的函数吧。 1，render 重要的事情说三遍：render()方法是必须的！render()方法是必须的！！render()方法是必须的！！！ 当使用render方法的时候，它最终return一个单子级组件，这个意思就是说返回一个dom 组件，比如一个 div 节点，也可以是其他自定义的组件，有个要点就是一定只能 return 一个 dom 组件，当你有多个单独的dom节点或者单独的自定义组件要 return 的时候，必须要在外面包裹一层 div 才行。当然，你也可以返回 null 或者 false 来表明不需要渲染任何东西。在 return 前会干什么呢？return 的作用是渲染页面的，而渲染页面需要数据react 里的数据主要就是 props 和 state，所以在 render 方法中，它先会自动监测 props 和 state，render 方法有几个需要注意的点：1，render 函数中不能修改 state，所以 setState 方法是不能用的；2，render 并不是渲染真是的 dom ，而是 Virtual DOM，所以在这个方法中，你并不能对 dom 进行操作，this.getDOMNode()也去不到任何节点，只能得到 null。3，不和浏览器交互，例如通过使用 setTimeout。 2，getInitialState 这是初始化state的方法，仅仅在组件挂载之前调用一次！ 3，getDefaultProps 在组件创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 this.props，（可以使用 in 来检测属性）。该方法在实例创建之前调用，因此不能依赖于 this.props。 4，componentWillMount 这个方法会在初始化渲染完毕之前立即调用，仅执行一次。可以使用 setState 方法。 5，componentDidMount 这个方法会在初始化渲染完毕之后立即调用，仅执行一次。这个时候已经渲染完毕了，所以 Virtual DOM 已经成为了真实的 DOM，你可以使用 this.getDOMNode()方法，发送 ajax 请求，或者 setTimeout 等方法。 6，componentWillReceiveProps 该方法仅仅在组件接收到新的 props 的时候调用。所以初始化的时候不会调用这个方法，传入的参数将是即将接收到的新的 props，一般会通过新老 props 比较，然后再决定需不需要更新页面。 7，shouldComponentUpdate 当组件接收到了新的 props 或者 state 的时候，即将要渲染页面之前调用这个方法。按常规来说，组件 state 或 props 更新后，往往都是需要重新渲染一下页面的，当然，这不是百分之百，所以这个时候就需要在渲染之前，在判断一下，是否真的需要渲染，在这个方法中可以获得 nextProps 和 nextState，然后我们可以比较，看是不是真的需要渲染，如果需要渲染，就return true，不需要渲染就 return false，这个方法默认是会返回 true 的。这个方法存在的意义就是不该渲染的时候不渲染，节约时间优化性能，当然，组件少了也没什么实际意义，可是当组件数量成百上千的时候，或许就会很明显地感觉到优化的性能了。 8，componentWillUpdate 这个方法主要是在接收到新的 props 或者 state 之前立刻调用，使用该方法做一些更新之前的准备工作，此时不能更改 state。 9，componentDidUpdate 个人觉得和componentDidMount类似，只是一个在初始化渲染后调用，一个在更新渲染后调用。 10，componentWillUnmount 在组件从 DOM 中移除的时候立刻被调用，在该方法中执行任何清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。 唉，好累，终于把这一大堆函数科普完了，我稍微归纳一下吧，方法大致有以下几类：初始化的时候执行的，初始化渲染前执行的，初始化渲染后执行的，接收更新时执行的，接收更新后渲染之前执行的，接收更新后渲染之后执行的，即将移除前执行的。这么多方法，都是和执行时间有关，并且一个方法后往往会执行另一系列的方法，这就是它的生命周期。 所以回到上面的问题，当父组件的 props 更新后，子组件的 props 也会更新没错，但是这时并不会重新去执行一次 getInitialState 方法，因为这个方法仅仅在初始化的时候调用一次，所以最后 render 时还是用的之前的 state 来进行渲染，所以我做的就是加上 componentWillReceiveProps 来进行人为更新 state。 这篇文章到这里应该就可以结束了，不过我还有点意犹未尽，所以稍微多说一点吧。 上面两张图分别是各个不同的变化会产生的不同的一系列的方法调用，，以及每个方法是否能够对 state 进行更新都做了说明，可以看到，初始化的时候，props 变化的时候，state 变化的时候，都会触发不同方法来进行处理，有的函数是可以不写的，因为它默认会执行，经过上次改bug的事情后，我觉得吧，层级多了的时候还是最好在每个层级里面对 props 和 state 进行控制监测一下，以免发生不必要的错误。","tags":[]},{"title":"hexo博客增加搜索功能","date":"2017-01-24T09:10:24.000Z","path":"2017/01/24/hexo-search/","text":"最近在用在某个项目上增加一个搜索框，后端用node＋mongodb实现，本来以为挺简单的，就用node爬一下页面title和href，然后放进mongodb中，再通过前端发请求传数据过来查找，然后node再在mongodb中查找，将数据返回前端。 这是理想情况下的做法，可是现实往往充满了曲折,下面我来简单介绍下这个项目，然后说一下问题吧。 这是个内网项目，所以爬虫爬不进去，好在有一个目录页，将所有页面的title和href整理了起来，不过读取这个文件也不是简单的事，因为这个是类似于json格式的文件，但是却没有任何的符号，全是汉字，而我们存储的时候是需要分层次的，这样利于查找，采用node的FS模块可以很容易地读取到文件的内容，但是仅仅是读取，直接存储的话会导致没有层次感，所以我就把这个文件复制了一份出来，通过人工维护的方式将其变为json格式，然后就很好操作了，不过需要人工维护与更新，不算是最好的办法，但是那个文件之前也是人工维护的（虽然我不知道是谁维护，否则可以叫他一起维护下）。 这是个hexo博客系统，纯静态展示的，所有页面均是通过通过hexo的框架，执行hexo g命令的时候，会自动将md文件解析成html（css），然后再通过执行hexo server命令，开一个hexo的服务器，把所有的页面通过服务端渲染到浏览器；因此，我增加的这个搜索框的功能，除了需要自己写服务器和数据库外，还必须把这个项目单独部署，因为hexo的源码上并没有针对服务器的扩展方法（这一点是@南烛帮我一起看的，毕竟我之前对hexo的了解只是会用而已，并没有在它的源码上进行深入研究），因此，这就成为了两个项目，然后把这两个项目部署在同一台服务器上，再通过配置nginx服务，将搜索框从前端发来的请求映射到node服务器监听的那个端口，这样就形成了前后端数据的交互，这里出现了一个比较奇怪的问题，我在我自己电脑上发送请求时，请求能够成功发出去，可就是接收不到返回的内容，然后我从另一台电脑通过花瓶代理请求到我本地来测试接口，却发现是正常的，最后发现是两个项目之间的请求跨域了。 解决跨域，可以选择将项目部署在服务器，然后再测试，不过这就比较麻烦了，修改bug比较蛋疼，或者使用代理，将请求代理到另一个域来，这样修改bug也比较简单，现在开始发请求了，发现查找结果是没有数据，没关系，我刚刚只是随便输入的一个词，现在我输入一个数据库里存在的词重新发送请求，不过问题就出来了，还是没有数据，怎么可能啊，数据库里确实有这个数据啊，怎么会查不到，于是我换了几个数据库里存在的词，再反复查找，结果大多都是不存在，唯一存在的一个是一个英文单词，然后我就查看请求，发现地址没错，参数呢？参数怎么自动给我转码了，我就好奇了，然后我再去后台将这个获取到的请求参数，对比了一下接收到各种参数的情况，发现汉字会自动转码，数字和英文单词会保持不变，但是当查询的字符串中间出现空格的时候，会自动变为加号来填充空格，所以，只有无空格的数字或英语字母才可以直接查找到结果，否则的话都需要人工再进行一次转码，将其转过来，唉，毕竟第一次写服务器，这些都需要靠自己独自摸索。 接下来是mongodb的事情。之前使用百度搜索还是谷歌搜索，我都没发现什么大的问题（可能是我搜索的问题太傻了），这次查询mongodb和mongoose的相关资料，发现百度搜索出来的都是以一些博客，百度知道的回答为主，且各个博客之间相互抄袭也是够无聊的，仅仅只是做到了制造而不是创造。然后我就去谷歌采用英文搜索，stackoverflow，官方网站等都是排在很前面的（不知道百度为什么把人家官网排在很后面），算了，不吐槽了。mongodb这种非关系型轻量级数据库，使用起来是很方便的，增删查改的api都是比较简单的，根据所示范的例子动手稍微写一下就会用了，不过对于第一次使用的我来说，还是遇到了一些问题：存储的时候，mongodb会自动给你加上下划线id，我估计是为了区分存储空间，可是这就会存在一个问题，当我存储了一条数据过后，再储存一条相同的数据进去，是可以存储进去的，因为它们的下划线id不同，这显然不对啊，我否则我一查找，却找到很多条数据，仔细一看却发现这么多条数据都是一样的，不是很搞笑吗，所以我选择了给每条数据加上一个index作为唯一标志符，然后再在每次启动的时候，去读取文件存储进数据库里，存进去之前会先去数据库里通过这个index唯一标志符查找一遍，如果查询结果为空，我才会把这条数据存进去，否则就不存。其实吧，每次存储的时候会人为的自动查找，相当于遍历了一遍数据库，如果是在正常的稍微大一点的项目来说，这是十分十分十分影响性能的，由于我这里是个很小的项目，所以才可以进行这种方式查询；其次是mongo查找的时候，默认的方式是精确匹配，不支持模糊查询，这怎么办呢，难道需要我在查询的时候再遍历一遍数据库，使用indexOf来查询？我感到很可笑，因为你这么傻的方法在实际中是肯定行不通的，再说了，就算可以，那么大小写的模糊查询怎么办？难道要我判断下有没有英文字母然后分别用用大写和小写都来遍历一下？这个时候就可以使用正则了，将查询的字符串改变为正则表达式，这样的话在数据库里它会自动的去匹配所有适合的结果。","tags":[]},{"title":"javascript异步编程（续）","date":"2017-01-24T09:10:12.000Z","path":"2017/01/24/javascript异步编程（续）/","text":"之前那篇文章讲解了javascript异步式编程的几个方法，比如有回调函数，promise，发布／订阅模式，generator函数等，每一种方式，在其广泛使用的时期，都是很完善的一种方式，不过由于时代的进步，技术的发展，缺点总会暴露出来，更好更完善的方法也会被创造出来。 这篇文章，我就想来说说async函数。 ES7意见征集稿中提供了async函数，这是什么？其实可以用一句话来概括，async函数就是Generator函数的语法糖。 我们从Generator函数开始，代码如下。 123456789101112131415161718192021222324252627// 这是采用fs模块来异步读取文件var fs = require(&apos;fs&apos;);var readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;// 这是使用generator函数的方法，依次读取两个文件var gen = function* ()&#123; var f1 = yield readFile(&apos;/etc/fstab&apos;); var f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;;// 下面是async函数的写法var asyncReadFile = async function ()&#123; var f1 = await readFile(&apos;/etc/fstab&apos;); var f2 = await readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;; 其实一比较，差异很明显，async函数就是将generator函数的星号替换成了async，将yield替换成了await。 仅此而已！仅此而已？ 虽然加入了比较好看的语法糖，不过一个新的方法如果只是比老的方法命名好听，有什么意义呢？下面我来说一下async函数和generator函数的主要区别吧。 更好的语义。既然都看出来了，那最明显的当然是标志符换了，也就是更加语义化了，await和async比星号跟yield更加让人好理解。 更好的适用性。generator函数的执行必须依靠执行器，或者人为的多次调用next方法才能继续执行下去，而async是自带执行器的，这是什么意思呢？意思就是你再也不用管什么next了，也不用管怎么异步执行了，你完完全全就可以把async函数就当做普通的函数来看来，当你想执行的时候，只需要一句var result = async();就可以了，她会自动调用async函数并且自动执行，输出最后结果，你现在可以将什么next方法啊，co模块这些全部放一边了。 返回值是promise。async函数的返回值是promise对象，这比generator函数的返回一个Iterator对象方便多了，你可以使用promise里的then方法来进行下一步的操作。而async函数完全可以看作是多个异步的操作，包装成了一个promise对象，而await就是then方法的语法糖。 下面是一些async函数的具体使用示例。 1，下面代码中，函数f中return的数据，会被promise的then方法的回调函数获取到，所以then方法回调函数里的参数v就是指代的f函数的return的数据，所以控制台才会打印出hello world 123456async function f() &#123; return &apos;hello world&apos;;&#125;f().then(v =&gt; console.log(v))// 打开控制台，你就会看见有一句hello world（前提是你的浏览器支持async） 2，async函数内部抛出错误，会导致返回的promise对象变为reject状态，抛出的错误对象，会被catch方法的回调函数捕捉到。 123456789async function f() &#123; throw new Error(&apos;出错了&apos;);&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 3，async函数返回的promise对象，必须要等到内部await命令的promise对象执行完，才会发生状态的改变，换句话说，也就是async函数内部的await命令执行完了，才会执行then方法的回调函数。如下面的例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log)// &quot;ECMAScript 2017 Language Specification&quot; 4，在正常情况下，await后面应该是一个promise对象，如果不是，那么会被转变为一个立即resolve的promise对象。 123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123，这里await后面的123虽然不是promise对象，不过它会转变为promise对象并立即被resolve，所以在后面的then方法的回调函数里，依然可以正常的运行。 5，async函数返回的promise对象，如果变为了reject状态，则reject的参数会被catch方法的回调函数接收到，示例如下： 12345678async function f() &#123; await Promise.reject(&apos;出错了&apos;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了。上面的await前面没有return语句，但是reject状态的参数依然传入了catch方法的回调函数里，所以说这里有没有return都是不影响的，不过为了统一与规范，还是建议加上。 6，只有程序发现了一个promise函数的状态变为了reject，那么后面的代码将不会执行。 123456789101112131415161718192021222324252627282930313233async function f() &#123; await Promise.reject(&apos;出错了&apos;); await Promise.resolve(&apos;hello world&apos;); // 这句将不会执行&#125;// 所以为了避免这种情况发生，可以将第一个await放在try...catch...语句中，这样代码的执行就不会被中断。async function f() &#123; try &#123; await Promise.reject(&apos;出错了&apos;); &#125; catch(e) &#123; &#125; return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// hello world// 另一种解决办法就是在await后面的promise对象加上一个catch方法，来处理前面可能会出现的错误，代码如下。async function f() &#123; await Promise.reject(&apos;出错了&apos;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world// 当然，我们也可以将多个await命令放进catch方法里，这段代码就省略了。。。 7，如果await后面的异步操作出错，那么就等同于promise对象状态变为reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&apos;出错了&apos;); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面说了那么多的示例，都是比较片面的讲解使用中的注意事项，完整的示例来讲解async函数的使用方法，所以我下面会主要讲async函数的使用。 1，上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 12345678910async function getStockPriceByName(name) &#123; var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; console.log(result);&#125;);// 最后打印出的这个result就是getStockPriceByName函数中return的stockPrice。 2，下面代码指定50毫秒以后，输出”hello world”。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value)&#125;asyncPrint(&apos;hello world&apos;, 50); 十一国庆节来公司基本没人，后背也感到一阵阵凉风，这篇博客就先讲到这里吧，有什么完善的地方后面我会再继续补充的。","tags":[]},{"title":"javascript异步编程","date":"2017-01-24T09:10:05.000Z","path":"2017/01/24/javascript异步编程/","text":"最近nodejs看得有点多，感觉满脑子都是文件处理，异步编程，buffer等，发现学node学多了，前端用到的javascript也会更加豁然开朗，特别是廖雪峰和阮一峰老师的博客，给了我不小的帮助。我想从nodejs开始说起，毕竟这才是编程的核心，现在发现前端用的js只是熟练运用onclick事件等，自己以前还是只接触到了皮毛啊。 回到主题，据传当初Ryan Dahl选择js来作为后台语言时，主要就是看重了js的单线程，同步运行，适合一些高并发的场景，这就从侧面说明了js这门语言的特性：同步，单线程。那么可以多线程异步编程吗？答案当然是肯定，那么，js异步编程有哪几种方法，这几种方法各自的优缺点又如何呢？ 说到这里，我又想解释一下同步与异步，第一次听到这两个词语，就要得追溯到大学的操作系统课堂了，OS的运行机制（运行模式）分为同步（Synchronous）和异步（Asynchronous）。 “同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。”异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。 所以针对js的异步编程方法，我准备讲解如下几个方法： 一，回调函数这是异步编程最最最基本的方法，几乎所有能异步编程的语言都可以用到这个方法。回调函数的具体意思是，假设有两个函数，a和b，函数a在前b在后，正常情况的话，程序运行到了函数a，会等待其执行完毕，然后拿到函数a的运行结果，才会继续执行函数b；那么这时，问题就来了，如果函数a运行一秒，我可以等，运行十秒，就难以忍受了，万一函数a卡住了，永远成功不了，你会等到海枯石烂吗？哈哈哈，那怎么办，我下面还有千千万万行的代码啊，辛辛苦苦写了那么久，还没运行到这里，就结束了，逗我啊。。。这个时候，就该回调函数上场了，把函数b写成函数a的回调函数，像这样： 1234567891011121314// 原来的代码a();b();// 采用回调函数function a(b)&#123; setTimeout(function()&#123; // a的代码 b() &#125;,1000);&#125; 采用这种方式，我们把同步操作变成了异步操作，a不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 那么问题就来了，学。。。不对，这会产生什么问题？如果回调函数比较多会怎样？ 123456789101112// 在前一个动画执行完成后，紧接着执行下一个动画$(&apos;xx&apos;).animate(&#123;xxxx&#125;, function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; $(&apos;xx&apos;).animate(&#123;xx&#125;,function()&#123; ... &#125;,1000) &#125;,1000) &#125;,1000) &#125;,1000)&#125;,1000) 是不是觉得很傻，代码毫无可读性而言，不过，这是最基本的js异步编程的方法。 二、promise有了最基本的方法，就会有很多人不满足，想做出优化，写个第三方库啊或者发各种包，各种模块什么的。 最有名的，莫过于promise了，做为前端，大名鼎鼎的jQuery肯定不会不知道吧，说起jQuery，要说的就太多了，赶紧收住。jQuery里的ajax方法，就是典型的参照了promise设计出来的产物，其使用方法是： 12345$.ajax(&#123;// 配置参数&#125;).done(function(retData) &#123;...&#125;); 这是一套典型的jQuery版的ajax应用方法，后面的done，就是指的前面做完了，返回一个结果retData来，然后再执行其它操作。 在es6中，已经正式出台了promise对象，其基本用法如下： 123a().then(b).then(c)... 是不是一下子就简洁了很多？当然，这个也不能说是完美的异步编程解决方案，只能说是完善罢了，其优点确实是简化了不少代码，不过也有不足的地方，那就是维护比较麻烦，因为这样的话，异步多了，你一眼看过去，将会看到一堆的then。。。是不是很尴尬啊，代码的可读性一下子就降低了，你满脑子的then。 三、观察者模式说起这个，又要回到大学的操作系统课堂了，算了，不浪费时间了，直接进入正题。 观察者模式，你可以理解为，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。 这个方式的实现有很多的插件，就拿我们最熟的jQuery来说好了。 1234567891011// 函数b订阅done信号jQuery.subscribe(&quot;done&quot;, b);function a()&#123; setTimeout(function () &#123; // a的任务代码 // a执行完毕后，发布done信号，然后b接收到了done信号，就开始执行b函数 jQuery.publish(&quot;done&quot;); &#125;, 1000); &#125; // 当然，你也可以取消订阅信号的事件，这样的话，以后done信号发布，b函数就不会执行了。 // jQuery.unsubscribe(&quot;done&quot;, f2); 这个也有一点可以优化的地方，就是发布和订阅的消息太多时，不好管理，事件会太杂乱，有一个整体管理事件的中心就更好了。 四、generatorGenerator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。其核心意思就是，一段代码执行到某个节点时，暂停执行，然后执行另一段代码，有等了会，再回过头来执行第一段代码剩下的部分，总的来说就是几个代码片段交替执行。 说到这里我觉得现现在generator函数并没有被广泛的大面积的运用，所以先花点时间来介绍下generator函数吧。talk is cheap，show u the code. 1234567function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; 上面的代码中，调用generator函数，会返回一个内部指针（也叫遍历器），就是这里的g，所以说当你直接调用generator函数的时候，它并不会直接返回结果，而里面的yield字段，就表示异步操作需要暂停的地方，通过g指针调用next方法，指针就会开始异动到下一个yield（或者return）的地方去，并且返回当时暂停时所得到的结果value,以及遍历状态done。 下面来看看如何使用generator函数来执行一个真实的异步任务。 123456var fetch = require(&apos;node-fetch&apos;);function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result.bio);&#125; 这里我们通过发送请求，然后输出请求返回的结果，去掉yield命令，就完完全全是同步的了，所以这也是yield的一个比较大的特点，对代码改动小，保持代码可读性。。。话说回来，现在声明了这个函数，如何使用呢？使用方法如下： 1234567var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 发现已经写了好多了，看来一次性写完确实太累啊，留下一个acync函数下次再写吧。","tags":[]},{"title":"express实现","date":"2017-01-24T09:09:53.000Z","path":"2017/01/24/node express实现/","text":"express是node里面一个十分常用的库，用它来搭建服务器，事半功倍，且小巧灵活，有足够多的特性，用来进行各种网页开发。 我们先来看下express的使用的，毕竟知己知彼，百战不殆。 123456789101112131415161718192021//引入express，确保你的项目依赖了express库，否则的话先npm install一下var express = require(&apos;express&apos;);//执行express函数，var app = express();// 使用get方法，当请求的路由是hello时，返回helloapp.get(&apos;/hello&apos;, function (req, res) &#123; res.send(&apos;hello&apos;);&#125;);// 当请求的路由是world时，返回worldapp.get(&apos;/world&apos;, function (req, res) &#123; res.send(&apos;world&apos;);&#125;);// 当请求的路由是其它时，返回“没有找到匹配的路径”app.get(&apos;*&apos;, function (req, res) &#123; res.setHeader(&apos;content-type&apos;,&apos;text/plain;charset=utf8&apos;); res.end(&apos;没有找到匹配的路径&apos;);&#125;);// 最后监听端口var server = app.listen(3000, function () &#123; console.log(&apos;正在监听3000端口&apos;);&#125;); 上面或许就是express最常见，也是最基本的使用吧，启动了一个服务器并且监听3000端口，对/hello的路由返回“hello”，对/world的路由返回“world”，对其他的路由返回“没有找到匹配的路径”。 示例看完了，下面我们来看看具体的实现吧，在这之前，我想说一下http这个模块，毕竟express就是对http进行了一下封装，既然想看看express的内部，当然就离不开http了。 123456var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.end(&apos;Hello World\\n&apos;);&#125;).listen(3000, &apos;127.0.0.1&apos;);console.log(&apos;正在监听3000端口。&apos;); 就上面这几行，就已经成功地实现了一个简单的服务器了，我们可以分拆一下。1http.createServer(function(...)&#123;...&#125;).listen(3000); 现在，我们再回过头来看看express。 1234567891011121314151617181920// 首先，声明express函数var express = function () &#123;&#125;;// 它的内部应该有一个app函数，用来作为实例。var express = function () &#123; var app = function(...)&#123;...&#125;&#125;;// 这个实例还应该有很多的方法，比如get，listen等。（本来我是想用es5的方式写的，后来发现好久没用那种方法，写function写得太累了。。。）var express = ()=&gt; &#123; var app = (req,res)=&gt;&#123;...&#125;; app.listen = (...)=&gt;&#123;...&#125;; app.get = (...)=&gt;&#123;...&#125;;&#125;;// 最后，为了能够完成链式调用，所以我们返回这个实例app，然后exports一下，就完成了。var express = ()=&gt; &#123; var app = (...)=&gt;&#123;...&#125;; app.listen = (...)=&gt;&#123;...&#125;; app.get = (...)=&gt;&#123;...&#125;; return app;&#125;;module.exports = exports = express; 这就是express基本的框架，如果后续有什么扩展的，也可以直接在里面增加一个函数就好了，= (...)=>&#123;...&#125; ```，接下来，我们来慢慢分析里面的构造。12先看一个最简单的吧，listen方法。 app.listen = function (port) { require(‘http’).createServer(app).listen(port);};12是不是发现了什么？再上去看一眼http，是不是很相似啊。。。没错，就是这样的。 http.createServer(function(…){…}).listen(3000);``` 而中间的app函数，对应的就是http.createServer的参数了。感觉这个listen函数应该不需要多讲。","tags":[]},{"title":"react——无状态组件和高阶组件","date":"2017-01-24T09:09:29.000Z","path":"2017/01/24/react无状态组件和高阶组件/","text":"无状态组件先来说说无状态组件吧，顾名思义，无状态组件就是指的没有状态的组件，众所周知在react中，状态指的就是state，而没有state，会有什么好处和坏处呢？ react中所有的数据，都是通过state和props来保存的，state主要是组件内部的数据交流，可以进行各种读写操作，而props主要是组件间的数据交流，一般针对props仅仅执行只读，不会做额外的操作。所以话说回来，无状态组件，没有state，那么内部的逻辑必将大大减少，编写react组件的方便性也将大大提高。 下面是一个简单的无状态组件： 1234567function Hello(props&#123; return &lt;div&gt;Hello&#123;props.name&#125;&lt;/div&gt;&#125;ReactDOM.render(&lt;Hello name=&quot;world&quot; /&gt;, mountNode)// 最后一句也可以这么写ReactDOM.render(Hello(&#123;&quot;name&quot;:&quot;world&quot;&#125;), mountNode) 通过这个简单的示例可以看到，原本需要写的react类定义（React.createClass或者class Component extends React.Component）来创建自己组件的定义，但是由于这仅仅是一个无状态组件（无状态函数），react在渲染的时候也省掉了奖react组件类实例化的过程。 所以对于一些纯静态展示的功能模块，可以考虑作为无状态组件，而无状态组件用来实现服务端渲染也是比较方便的，只要避免去获取dom节点就可以了。 无状态组件的生命周期方法我们可以看到，无状态组件就剩了一个render方法，因此也就没有实现组件的生命周期方法，例如componentDidMount, componentWillUnmount等。那应该怎么办呢？这个时候就用到了高阶组件。 高阶组件高阶组件是什么？通过函数，向现有的组件类添加逻辑，就叫做高阶组件。 之前上面已经说了，无状态组件是没有state的，所以里面基本也就没有什么逻辑，可是如果我现在需要添加逻辑了，且又想继续使用这个无状态组件，怎么办呢？那就可以使用高阶组件。 先来看看这个示例： 1234567891011121314function noId() &#123; return function(Comp) &#123; return class NoID extends Component &#123; render() &#123; const &#123;id, ...others&#125; = this.props; return ( &lt;Comp &#123;...others&#125;/&gt; ) &#125; &#125; &#125;&#125;const WithoutID = noId()(Comp); 这个例子向我们展示了高阶组件的工作方式，通过函数和闭包等方法，改变已有组件的行为，示例里面改变了id属性。 之所以称之为高阶组件，是因为在react中，这种嵌套的逻辑关系会反映到组件树上，层层嵌套就像高阶函数的function in function一样，如下图所示： 从上图可以看出组件树虽然嵌套了许多层，但是实际渲染的无状态组件中的dom结构并没有发生改变，所以我们可以放心地使用高阶组件，哪怕重复使用，也不必担心影响输出的dom结构。而借助函数的表现能力，高阶组件的用途几乎是无穷尽的。 适配器有时候你需要替换一些已有的组件，而新组件接受的参数和原组件并不完全一样. 你可以考虑修改所有原组件的代码来保证传入正确的参数——so bad。 你也可以通过使用高阶组件，把新组件做一层封装： 12345678class ListAdapter extends Component &#123; mapProps(props) &#123; return &#123;/* new props */&#125; &#125; render() &#123; return &lt;NewList &#123;...mapProps(this.props)&#125; /&gt; &#125;&#125; 如果有十个组件需要适配呢？当然，每个组件写十遍也不是不行，不过，高阶组件或许会给你一个更好的答案： 1234567891011function mapProps(mapFn) &#123; return function(Comp) &#123; return class extends Component &#123; render() &#123; return &lt;Comp &#123;...mapFn(this.props)&#125;/&gt; &#125; &#125; &#125; &#125;const ListAdapter = mapProps(mapPropsForNewList)(NewList); 借助高阶组件，关注点被分离得足够彻底，你不需要考虑组件的渲染，你只需要考虑属性的map就够了。 处理副作用在组件中，往往有很多的状态和副作用要处理，最常见的情况就是异步了。 假设我们需要异步加载一个用户列表，通常的代码会是这样的： 1234567891011121314151617181920class UserList extends Component &#123; constructor(props) &#123; super(); this.state = &#123; list: [] &#125; &#125; componentDidMount() &#123; loadUsers() .then(data=&gt; this.setState(&#123;list: data.userList&#125;) ) &#125; render() &#123; return ( &lt;List list=&#123;this.state.list&#125; /&gt; ) &#125; /* other bussiness logics */&#125; 在实际情况中，以上代码往往还会和其他一些业务函数混杂在一起，如果再来一个或多个其他的列表呢，不仅代码会重复，大量有状态和副作用的组件也使得组件难以测试。或许你会考虑使用一些数据管理工具，比如flux或redux，是的，当然可以，可是这就像大炮打蚊子，杀鸡用牛刀。所以回到这个问题上来，我们只是想做一个异步的列表，仅此而已。 使用高阶函数试试： 123456789101112131415161718192021222324252627function connectPromise(&#123;promiseLoader, mapResultToProps&#125;) &#123; return Comp=&gt; &#123; return class AsyncComponent extends Component &#123; constructor(props) &#123; super(); this.state = &#123; result: undefined &#125; &#125; componentDidMount() &#123; promiseLoader() .then(result=&gt; this.setState(&#123;result&#125;)) &#125; render() &#123; return ( &lt;Comp &#123;...mapResultToProps(props)&#125; &#123;...this.props&#125;/&gt; ) &#125; &#125; &#125;&#125;const UserList = connectPromise(&#123; promiseLoader: loadUsers, mapResultToProps: result=&gt; (&#123;list: result.userList&#125;)&#125;)(List); //List can be a pure component 可以看到，这样不仅大量减少了重复的代码，还把散落在各处的异步逻辑封装进了可以单独管理和测试的函数中，在实际业务场景中，只需要按照“纯组件＋配置”就可以实现相同的功能，而无论是纯组件还是配置，都是对单元测试友好的，至少比异步组件友好多了吧。","tags":[]},{"title":"从源码看react生命周期","date":"2017-01-24T09:09:19.000Z","path":"2017/01/24/react生命周期源码解读/","text":"React的主要思想，就是通过构建可复用的组件来构建页面，而每一个组件，就是一个有限的状态机，通过状态控制组件不同的渲染，从而得到不同的界面效果。每个组件都有生命周期，它规定了组件的一些自带方法需要在哪个阶段进行执行以及输出对应的结果。 有限状态机，表示有限个状态，以及在这些状态之间的数据转移和动作方法的执行的行为模型，一般通过状态、事件、转换和动作来描述有限状态机。例如页面上的都个东西有显示和隐藏两种情况，那么一般情况下我们会设计两个方法：show()和hide()来实现显示与隐藏的切换，而react只需要设置某一个状态为true或false，就可以实现这个组件的隐藏和显示转换了。同时，react还引入了组件的生命周期这个概念，通过它就可以实现组件的状态机控制，从而达到“生命周期－状态－组件”的和谐画面。 生命周期之前一篇博客就已经说到了一下生命周期，我在这里再赘述一下吧，react组件自带的一些函数方法，比如getDefaultProps、getInitialState等，会在什么时候执行。 当首次装载组件时，按顺序执行 getDefaultProps、getInitialState、componentWillMount、render 和 componentDidMount； 当卸载组件时，执行 componentWillUnmount； 当重新装载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps； 当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate. 然后具体的状态、属性改变，会触发什么方法，可以参考如下两张图，由于这篇博客重点不在于此，所以就不细细讲解了。 疑问： 为什么react会按照这样的方式来，这样的顺序来执行生命周期？ 为什么react多次render时，会执行生命周期的不同阶段。 为什么getDefaultProps只执行了一次？ react生命周期详解react组件的生命周期，主要通过三种状态来管理，分别是MOUNTING、RECEIVE_PROPS、UNMOUNTING，而其他的方法，例如getDefaultProps、getInitialState，还包括自己定义的一些方法等，都是通过这三个状态来管理的，这三个状态会负责通知对应的组件当前所处的状态，应该执行生命周期中的哪个步骤，比如是否可以更新state，是否能调用自定义函数等。在这三种状态中，MOUNTING指的是加载组件，RECEIVE_PROPS指的是更新组件，UNMOUNTING指的是卸载组件，而每种情况，比如说加载组件（mountComponent），都会有两种方法，will和did，will指的是之前，比如说加载之前，更新之前，而did指的是之后，表示加载之后，更新之后。 creatClass创建组件这是最react组件中的入口方法，负责管理生命周期中的getDefaultProps。getDefaultProps方法在react生命周期中只执行一次，那就是在首次加载组件初始化的时候执行。通过creatClass创建组件，利用原型继承ReactCompositeBase父类，然后按顺序合并mixins，设置初始化defaultProps，创建ReactElement元素，具体信息看看下面的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ReactCompositeComponent 的基类var ReactCompositeComponentBase = function() &#123;&#125;; // 将 Mixin 合并到 ReactCompositeComponentBase 的原型上 assign( ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin );var ReactCompositeComponent = &#123; LifeCycle: CompositeLifeCycle, Base: ReactCompositeComponentBase, // 创建组件 createClass: function(spec) &#123; // 构造函数 var Constructor = function(props, context) &#123; this.props = props; this.context = context; this.state = null; var initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; &#125;; // 原型继承父类 Constructor.prototype = new ReactCompositeComponentBase(); Constructor.prototype.constructor = Constructor; // 合并 mixins injectedMixins.forEach( mixSpecIntoComponent.bind(null, Constructor) ); mixSpecIntoComponent(Constructor, spec); // mixins 合并后装载 defaultProps (React整个生命周期中 getDefaultProps 只执行一次) if (Constructor.getDefaultProps) &#123; Constructor.defaultProps = Constructor.getDefaultProps(); &#125; for (var methodName in ReactCompositeComponentInterface) &#123; if (!Constructor.prototype[methodName]) &#123; Constructor.prototype[methodName] = null; &#125; &#125; return ReactElement.createFactory(Constructor); &#125;&#125; 所以这就解释了，为什么getDefaultProps会在react组件中很早的就被调用，且只被调用一次，因为getDefaultProps是通过Constructor来进行管理的，所以是在整个生命周期中最先开始执行。 状态一：MOUNTINGmountComponent负责管理生命周期中的getInitialState、componentWillMount、render、componentDidMount方法。 mountComponent主要做了以下一些事。 首先通过mountComponent装载组件，此时将状态改为MOUNTING，通过geiInitalState获取初始化的state，初始化更新队列为null。 然后会判断componentWillMount是否存在，如果存在，则执行componentWillMount，若此时使用了setState方法，则不会出发re-render，而是会合并更新队列，和初始化的render一起执行。 到此时，已经完成了MOUNTING的工作，将更新状态改为NULL，如果后面再使用setState方法，则会更改更新状态，然后出发render函数重新渲染。 mountComponent本质上是通过递归的方法来渲染的内容，所以如果一个组件中包含了另外的子组件的话，怎会发现，父组件中的componentWillMount总是会在子组件中的componentWillMount之前调用，而父组件的componentDidMount总是会在子组件的componentDidMount后面调用。 最后当初始化渲染完成后，若存在componentDidMount，则出触发。 这段流程的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 装载组件mountComponent: function(rootID, transaction, mountDepth) &#123; // 当前状态为 MOUNTING this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING; // 当前元素对应的上下文 this.context = this._processContext(this._currentElement._context); // 当前元素对应的 props this.props = this._processProps(this.props); // 获取初始化 state this.state = this.getInitialState(); // 初始化更新队列 this._pendingState = null; this._pendingForceUpdate = false; // componentWillMount 调用setstate，不会触发rerender而是自动提前合并 if (this.componentWillMount) &#123; this.componentWillMount(); if (this._pendingState) &#123; this.state = this._pendingState; this._pendingState = null; &#125; &#125; // 得到 _currentElement 对应的 component 类实例 this._renderedComponent = instantiateReactComponent( this._renderValidatedComponent(), this._currentElement.type ); // 完成 MOUNTING，更新 state this._compositeLifeCycleState = null; // render 递归渲染 var markup = this._renderedComponent.mountComponent( rootID, transaction, mountDepth + 1 ); // 如果存在 this.componentDidMount，则渲染完成后触发 if (this.componentDidMount) &#123; transaction.getReactMountReady().enqueue(this.componentDidMount, this); &#125; return markup;&#125; 详细流程图如下： 状态二：RECEIVE_PROPSupdateComponent负责管理react生命周期中的componentWillReceiveProps、shouldComponentUpdate、componentWillUpadte、render、compoentDidUpdate等方法。 在有组件更新时，react会通过updateComponent来更新组件，如果前后的元素不一致，则说明需要进行组件更新，此时会将状态改为RECEIVE_PROPS。 在进行组件更新的时候，react首先会检查有没有componentWillReceiveProps，如果有，则执行此函数，且componentWillReceiveProps函数中调用setState是不会重复触发render函数的，而是会进行render合并，到这个时刻，RECEIVE_PROPS的工作就已经做完了，然后将状态改为NULL，同时state也将进行更新操作，此时调用this.state，可以获得更新后的state。 然后会调用shouldComponentUpdate来作为最后的判断，判断组件是否更新，return true则会更新，否则不更新；之前已经说过了，react里的组件是通过递归来更新渲染的，而由于递归的特性，所以父组件的componentWillUpdate会在子组件componentWillUpdate之前执行，父组件的componentDidUpdate会在子组件componentDidUpdate之后执行。注意：禁止在shouldComponentUpdate和componentWillUpdate中调用setState，会造成循环调用，直至耗光浏览器内存后崩溃。 updateComponent的具体流程图如下： 下面是具体源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 更新组件updateComponent: function(transaction, prevParentElement, nextParentElement) &#123; var prevContext = this.context; var prevProps = this.props; var nextContext = prevContext; var nextProps = prevProps; if (prevParentElement !== nextParentElement) &#123; nextContext = this._processContext(nextParentElement._context); nextProps = this._processProps(nextParentElement.props); // 当前状态为 RECEIVING_PROPS this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS; // 如果存在 componentWillReceiveProps，则执行 if (this.componentWillReceiveProps) &#123; this.componentWillReceiveProps(nextProps, nextContext); &#125; &#125; // 设置状态为 null，更新 state this._compositeLifeCycleState = null; var nextState = this._pendingState || this.state; this._pendingState = null; var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext); if (!shouldUpdate) &#123; // 如果确定组件不更新，仍然要设置 props 和 state this._currentElement = nextParentElement; this.props = nextProps; this.state = nextState; this.context = nextContext; this._owner = nextParentElement._owner; return; &#125; this._pendingForceUpdate = false; ...... // 如果存在 componentWillUpdate，则触发 if (this.componentWillUpdate) &#123; this.componentWillUpdate(nextProps, nextState, nextContext); &#125; // render 递归渲染 var nextMarkup = this._renderedComponent.mountComponent( thisID, transaction, this._mountDepth + 1 ); // 如果存在 componentDidUpdate，则触发 if (this.componentDidUpdate) &#123; transaction.getReactMountReady().enqueue( this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this ); &#125;&#125;, 状态三：UNMOUNTINGunmountComponent 负责管理生命周期中的 componentWillUnmount。 首先将状态设置为 UNMOUNTING，若存在 componentWillUnmount，则执行；如果此时在 componentWillUnmount 中调用 setState，是不会触发 reRender。更新状态为 NULL，完成组件卸载操作。 具体代码如下所示： 1234567891011121314151617// 卸载组件unmountComponent: function() &#123; // 设置状态为 UNMOUNTING this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING; // 如果存在 componentWillUnmount，则触发 if (this.componentWillUnmount) &#123; this.componentWillUnmount(); &#125; // 更新状态为 null this._compositeLifeCycleState = null; this._renderedComponent.unmountComponent(); this._renderedComponent = null; ReactComponent.Mixin.unmountComponent.call(this);&#125; setState更新机制说起setState，想必用过react的都会知道吧，不过setState的更新机制，你真的知道吗？ 当你调用setState的时候，会对state以及_pendingState更新队列进行合并操作，但是，真正更新state的幕后黑手其实是replaceState。replaceState会先判断当前状态是否是MOUNTING，如果不是，则会立即调用ReactUpdates.enqueueUpdate来执行更新。 当状态不为MOUNTING和RECEIVEPROPS的时候，performUpdateIfNecessary 会获取 _pendingElement、_pendingState、_pendingForceUpdate，并调用 updateComponent 进行组件更新。 如果在 shouldComponentUpdate 或 componentWillUpdate 中调用 setState，此时的状态已经从 RECEIVING_PROPS -&gt; NULL，则 performUpdateIfNecessary 就会调用 updateComponent 进行组件更新，但 updateComponent 又会调用 shouldComponentUpdate 和 componentWillUpdate，因此造成循环调用，使得浏览器内存占满后崩溃。产生如下图的这种死循环： setState具体源码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 更新 statesetState: function(partialState, callback) &#123; // 合并 _pendingState this.replaceState( assign(&#123;&#125;, this._pendingState || this.state, partialState), callback );&#125;,// 更新 statereplaceState: function(completeState, callback) &#123; validateLifeCycleOnReplaceState(this); // 更新队列 this._pendingState = completeState; // 判断状态是否为 MOUNTING，如果不是，即可执行更新 if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) &#123; ReactUpdates.enqueueUpdate(this, callback); &#125;&#125;,// 如果存在 _pendingElement、_pendingState、_pendingForceUpdate，则更新组件performUpdateIfNecessary: function(transaction) &#123; var compositeLifeCycleState = this._compositeLifeCycleState; // 当状态为 MOUNTING 或 RECEIVING_PROPS时，则不更新 if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) &#123; return; &#125; var prevElement = this._currentElement; var nextElement = prevElement; if (this._pendingElement != null) &#123; nextElement = this._pendingElement; this._pendingElement = null; &#125; // 调用 updateComponent this.updateComponent( transaction, prevElement, nextElement );&#125; 总结： React 通过三种状态：MOUNTING、RECEIVE_PROPS、UNMOUNTING，管理整个生命周期的执行顺序； setState 会先进行 _pendingState 更新队列的合并操作，不会立刻 reRender，因此是异步操作，且通过判断状态（MOUNTING、RECEIVE_PROPS）来控制 reRender 的时机； 不建议在 getDefaultProps、getInitialState、shouldComponentUpdate、componentWillUpdate、render 和 componentWillUnmount 中调用 setState，特别注意：不能在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState，会导致循环调用。","tags":[]},{"title":"react, es5 or es6 ?","date":"2017-01-24T09:07:35.000Z","path":"2017/01/24/react es5还是es6 ？/","text":"随着es6的逐渐普及，新的语法糖，对我们以前写js的习惯也有着不小的冲击，比如说我好久都没写过function这个词语了，取而代之的是“=&gt;”箭头函数，var也基本不用了，现在用let，以及其他等等。 但是对于写react，es5和es6的变化，还是稍微有一些不同的，“talk is cheap,show the code”。 这是es5的写法： 12345678910111213141516171819202122232425262728var InputControlES5 = React.createClass(&#123; defaultProps：&#123; initialValue：&apos;&apos; &#125;, propTypes：&#123; initialValue：React.PropTypes.string &#125;, // Set up initial state getInitialState：function() &#123; return &#123; text：this.props.initialValue || &apos;placeholder&apos; &#125;; &#125;, handleChange：function(event) &#123; this.setState(&#123; text：event.target.value &#125;); &#125;, render：function() &#123; return ( &lt;div&gt; Type something： &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 下面是es6的写法： 1234567891011121314151617181920212223242526272829303132class InputControlES6 extends React.Component &#123; constructor(props) &#123; super(props); // Set up initial state this.state = &#123; text：props.initialValue || &apos;placeholder&apos; &#125;; // Functions must be bound manually with ES6 classes this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123; text：event.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; Type something： &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;InputControlES6.propTypes = &#123; initialValue：React.PropTypes.string&#125;;InputControlES6.defaultProps = &#123; initialValue：&apos;&apos;&#125;; 一下是一些关键的不同点： 创建方式不同es5是通过creatClass来创建的react组件，而es6是通过class extends来创建的，或许这是最直接的嫩个发现的差异吧，毕竟这在第一行。 函数的绑定话说以前，我修改过别人用es6写的react代码，我习惯在每个函数后面加上一个逗号，然后我在render函数中增加了一个事件，对应执行的函数是this.xxx，结果呢？报了一堆的错（包括之前的逗号），“this.xxx is undefined.”，当时我还不知道es6与es5的差异，当时就一脸无辜的表情，然后没办法，我把别人的代码全部用es5重写了一遍，并且当时表示以后都会一直使用es5的方式来写react。唉，人的一生，自身的努力很重要，但是也要考虑到历史的进程。。。于是我也就做了一点微小的工作，也开始采用es6的方式来写react了。 好了，说回正题，es5使用的是creatClass的方式来创建react组件，每一个函数都会自动被react绑定，所以就不会有“this.xxx is undefined.”这样的报错了。但是es6的class就不同了，你在render函数里使用到的this.xxx函数，都需要自己手动去构造函数中绑定它们，当然，你也可以通过插件来自动绑定，还有一种方式就是你可以在调用这个函数的地方，直接增加bind(this)来进行绑定，比如这样来绑定this。 上面的几种方式都可以绑定this，不过在性能上来说，却还是有一定差距的。首先是引入第三方库来自动绑定，如果是一个比较大型的项目，引入一个比较小的库，来解决比较多比较繁琐的bind的问题，还是可以的，不过前提是项目比较大，需要在引入第三方库和人为绑定之间权衡利弊。剩下的方法就是在构造函数里绑定this还是在render函数里绑定this，工作量其实是差不多的，但是这里涉及到一个生命周期的问题，构造函数，在整个react声明周期里，只会调用一次，但是render就不一样了，任何组件的任何属性改变或者状态改变，都可能处罚render函数来重新渲染，所以render函数一般是会执行多次的，既然执行多次，那么里面的bind(this)自然也是会执行多次，这与在构造函数里只执行一次来比，当然就会慢一些。有没有更好的办法呢？我在文章开始就说过了，es6有一个比较明显的特性就是箭头函数，它是会自动绑定this的，你可以在定义函数的地方直接使用箭头函数，代码如下： 12345handleChange = (event) =&gt; &#123; this.setState(&#123; text: event.target.value &#125;);&#125; 这样的话，也就不用考虑绑定this的事情了，是不是很方便啊。 构造函数中的superes6的constructor需要接收props，并且调用super(props)，这是相对于es5所改变的一点，这个记住就行了。 初始化state在es5中，react组件初始化的时候会执行一个getinitialState函数，而es6中却不是这样，在调用super之后，会直接设置一个this.state的对象来初始化，this.state = {…}。 getdefaultProps和propTypes和初始化state一样，在es5中，也有一个函数来单独初始化props，就是getdefaultProps，而es6就是用上面的那个super方法，es5中可以直接在这个函数下面接着写propTypes来限定接收的参数的类型，而es6就不一样了，它将propTypes直接放在了react组件之外，因为这些将会是类本身的属性，所以需要放在类的外部来单独定义。es7易经又将定义属性改回了类的内部，不过这个还没普及。 1234567891011class Person extends React.Component &#123; static propTypes = &#123; name: React.PropTypes.string, age: React.PropTypes.string &#125;; static defaultProps = &#123; name: &apos;&apos;, age: -1 &#125;; ...&#125; 用哪个方法才好？Facebook已经声明了React.createClass将最终会被ES6的classes替代，但是他们也说“在我们找到当前mixin所使用的例子的替代者以及在语言上支持类属性的初始化器前，我们不打算废弃React.createClass”。 在任何可以使用无状态函数式组件的地方使用它。简单而且会强制性地简化你的组件。 对于一些需要state，生命周期方法或是通过ref来操作潜在的DOM节点的复杂组件来讲，请使用class。 尽管知道这三种写法风格很棒，但在StackOverflow或者其他地方查找解决方案时可能仍会看到一些混杂着ES5和ES6写法的答案。ES6风格已经非常流行了，但这不会是你看到的唯一一种写法。","tags":[]},{"title":"redux源码解读","date":"2017-01-24T09:06:35.000Z","path":"2017/01/24/redux源码解读/","text":"这是2017年的第一篇博客，上周参加完各种年会聚会，本来准备周末写的，可是周末又突然有事，所以一直拖到现在，而且这是2017的第一篇技术博客，所谓好的开始是成功的一半，希望新的一年，自己可以继续坚持，变得更好。 redux其实我工作项目中接触的redux并不多，应该说只有一两个项目用到了redux，要求也是基本的redux的使用，dispatch一个action这种程度，react-redux也还没有涉及到，可能是项目的复杂程度不够大吧，所以涉及到redux的相关技术现在都是靠自学（唉，现在公司PHP迁移到JAVA，业务压力这么重，哪有时间自学啊，连示例都没看完，囧2333～）。 吐槽完毕，回到正题上来吧，学习一个库和框架最好的方法就是直接看源码，看源码好处有很多，不仅仅是学习API，还可以学习别人编写这个库（框架）的思想，这才是最为重要的，所以这次来写一篇redux源码相关的博客。 redux源码解读先把redux下载下来，发现很小，且没有依赖其他第三方库，简直是短小精悍啊，下面就让我好好见识下里面的思想。 我们直接看到src文件夹下，发现下面一共有七个文件或文件夹，分别是utils，applyMiddleware.js，bindActionCreators.js，combineReducers.js，compose.js，createStore.js，index.js。我们分别来看看。 utils这个是公用的工具方法，里面就warning.js一个文件，打开文件可以看到，里面就一个warning函数。 12345678export default function warning(message) &#123; if (typeof console !== &apos;undefined&apos; &amp;&amp; typeof console.error === &apos;function&apos;) &#123; console.error(message) &#125; try &#123; throw new Error(message) &#125; catch (e) &#123; &#125;&#125; 这个函数的主要目的就是抛出异常（错误），这个应该没什么好说的。 index.js接下来看看index.js文件，这种文件的主要目的一般是作为入口文件，里面代码也不多。 1234567891011121314151617181920212223function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; typeof isCrushed.name === &apos;string&apos; &amp;&amp; isCrushed.name !== &apos;isCrushed&apos;) &#123; warning( &apos;You are currently using minified code outside of NODE_ENV === \\&apos;production\\&apos;. &apos; + &apos;This means that you are running a slower development build of Redux. &apos; + &apos;You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify &apos; + &apos;or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) &apos; + &apos;to ensure you have the correct code for your production build.&apos; )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125; 首先看到一个空函数isCrushed，后面跟了一个if判断，第一个判断条件是process.env.NODE_ENV !== ‘production’，我记得process是node里的一个核心模块，然后我去node环境找了下process.env.NODE_ENV，发现undefined，说明本身是没有这个参数的，谷歌了一下，发现这是node的环境变量，如果process.env.NODE_ENV == ‘production’，则表示生产环境，具体参考地址在这里。这是第一个判断条件，而后面两个判断条件都是判断文件代码是否被压缩，因为如果被压缩了，那么isCrushed函数就不叫isCrushed函数了，同时浏览器发出警告。最后export一堆接口，分别是createStore,combineReducers,bindActionCreators,applyMiddleware,compose这五个。 createStore这应该是redux主要的一个函数，不对，应该是最主要的，顾名思义，createStore的意思就是创建store，而一个应用中只有唯一的一个store，你说这能不重要吗？ 废话不多说，先看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// 首先就定义了一个 ActionTypes 对象，它是一个action，是一个Redux的私有action，不允许外界触发，你可以在这段代码的最后面发现这个action就是初始化时，dispatch的action，也就是初始化Store的状态树和改变reducers后初始化Store的状态树。export var ActionTypes = &#123; INIT: &apos;@@redux/INIT&apos;&#125;// 这是主函数，createStore，它能够接收三个参数，reducer是必须的，preloadedState和enhancer是不必须，先来讲讲参数吧，reducer就是redux里的全局reducer，相当于一个全局的回调函数，返回下一个状态，接受两个参数：当前状态和触发的action（我自己编的，2333～）；preloadedState表示的是初始时的state，比如服务端渲染得到的初始状态，但是如果使用combineReducers来生成reducer，那必须保持状态对象的key和combineReducers中的key相对应；而enhancer是store的增强器函数，可以指定为第三方的中间件，时间旅行，持久化等等，但是这个函数只能用redux提供的applyMiddleware函数来生成。（这个我不怎么清楚，也没怎么用过。。。）export default function createStore(reducer, preloadedState, enhancer) &#123; // 这是判断是否有人传入参数顺序不对，如果是的话调整一下参数位置。 if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) &#123; enhancer = preloadedState preloadedState = undefined &#125; // enhancer只允许传入函数 if (typeof enhancer !== &apos;undefined&apos;) &#123; if (typeof enhancer !== &apos;function&apos;) &#123; throw new Error(&apos;Expected the enhancer to be a function.&apos;) &#125; return enhancer(createStore)(reducer, preloadedState) &#125; // reducer是必填的 if (typeof reducer !== &apos;function&apos;) &#123; throw new Error(&apos;Expected the reducer to be a function.&apos;) &#125; // 初始化参数，将当前状态currentState设置为初始状态preloadedState，初始化时间监听器数组等。 var currentReducer = reducer var currentState = preloadedState var currentListeners = [] var nextListeners = currentListeners var isDispatching = false function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // getState方法，返回当前的状态树currentState。 function getState() &#123; return currentState &#125; // subscribe函数，是给状态树添加监听函数，每当调用dispatch的时候，所有的监听函数就会执行。 function subscribe(listener) &#123; // 判断传入参数是否为函数 if (typeof listener !== &apos;function&apos;) &#123; throw new Error(&apos;Expected listener to be a function.&apos;) &#125; var isSubscribed = true // nextListeners是当前监听的事件列表，每次调用subscribe的时候，就会向nextListeners中push一个被监听的函数，并且将isSubscribed赋值为true。 ensureCanMutateNextListeners() nextListeners.push(listener) // 调用subscribe函数的时候，就会返回一个unsubscribe函数，用来取消监听函数，unsubscribe函数会先将isSubscribed的值改为false，同时将这个函数从当前监听的事件列表，也就是nextListeners中去除掉。 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() var index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; // dispatch函数，作用是分发action function dispatch(action) &#123; // 首先判断action格式 if (!isPlainObject(action)) &#123; throw new Error( &apos;Actions must be plain objects. &apos; + &apos;Use custom middleware for async actions.&apos; ) &#125; // action中type参数是必需的 if (typeof action.type === &apos;undefined&apos;) &#123; throw new Error( &apos;Actions may not have an undefined &quot;type&quot; property. &apos; + &apos;Have you misspelled a constant?&apos; ) &#125; // 判断是否正在dispatch if (isDispatching) &#123; throw new Error(&apos;Reducers may not dispatch actions.&apos;) &#125; // 开始dispatch，将isDispatching赋值为true，然后将currentState和action传给reducer，完成后再将isDispatching的值改为false。 try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; // dispatch完了后执行被监听了的函数，遍历函数列表nextListeners，分别执行里面的每个函数，最后会返回这个action。 var listeners = currentListeners = nextListeners for (var i = 0; i &lt; listeners.length; i++) &#123; listeners[i]() &#125; return action &#125; // 更改reducer，传入一个新的reducer，并且通过分发初始action，来初始化替换后reducer生成的初始化状态并且赋予store的状态。 function replaceReducer(nextReducer) &#123; // 容错判断，reducer必须是函数，是的话就用nextReducer替换掉currentReducer，再重新dispatch一下初始action，初始store。 if (typeof nextReducer !== &apos;function&apos;) &#123; throw new Error(&apos;Expected the nextReducer to be a function.&apos;) &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;) &#125; function observable() &#123; var outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== &apos;object&apos;) &#123; throw new TypeError(&apos;Expected the observer to be an object.&apos;) &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() var unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) // 最后就是返回这些所有的函数，作为暴露的接口使用。 return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 终于把createStore文件解读完了，下面来看看combineReducers函数。 combineReducers.jsreducer函数的作用是得到action后生成新的state，而由于一个app只拥有一个state，所以这个state肯定是比较复杂，数据比较多的，因此这个对应的处理生成state的reducer肯定也会是很复杂的，所以为了降低复杂度，也为了逻辑的解耦，我们会把这个大的reducer拆分成多个小的reducer，而这个combineReducers函数是为了整合所有的小的reducer，重新变为一个大的reducer，这就是combineReducers存在的原因，本来我想直接就把combineReducers的源码放上来的，不过我觉得可以先不忙，先具体的说一说combineReducers做的事情，下面这段讲解借鉴于阮一峰的博客。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187// 可以看到，这个方法有一个前提，就是state的属性名必须与子reducer同名const reducer = combineReducers(&#123; doSomethingWithA, processB, c&#125;)// 如果不同名，则如下const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125;// 然后下面是一个ombineReducers函数的简单的实现，看完了这个再看源码吧。const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;;// 其实这个简洁版的combineReducers还是比较容易理解的，主要就是先拿到reducers的key，然后通过reduce函数将原reducer的各个函数遍历一下返回一个新的reducers函数，很简单吧，至少看到这里，combineReducers函数的大概作用都是已经明白了吧，下面我门来看看其源码。// 前面这三个函数是对各个参数的合法性进行校验，比如reducer，state等。function getUndefinedStateErrorMessage(key, action) &#123; var actionType = action &amp;&amp; action.type var actionName = actionType &amp;&amp; `&quot;$&#123;actionType.toString()&#125;&quot;` || &apos;an action&apos; return ( `Given action $&#123;actionName&#125;, reducer &quot;$&#123;key&#125;&quot; returned undefined. ` + `To ignore an action, you must explicitly return the previous state.` )&#125;function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) &#123; var reducerKeys = Object.keys(reducers) var argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? &apos;preloadedState argument passed to createStore&apos; : &apos;previous state received by the reducer&apos; if (reducerKeys.length === 0) &#123; return ( &apos;Store does not have a valid reducer. Make sure the argument passed &apos; + &apos;to combineReducers is an object whose values are reducers.&apos; ) &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of &quot;` + (&#123;&#125;).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `&quot;. Expected argument to be an object with the following ` + `keys: &quot;$&#123;reducerKeys.join(&apos;&quot;, &quot;&apos;)&#125;&quot;` ) &#125; var unexpectedKeys = Object.keys(inputState).filter(key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key =&gt; &#123; unexpectedKeyCache[key] = true &#125;) if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &apos;keys&apos; : &apos;key&apos;&#125; ` + `&quot;$&#123;unexpectedKeys.join(&apos;&quot;, &quot;&apos;)&#125;&quot; found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `&quot;$&#123;reducerKeys.join(&apos;&quot;, &quot;&apos;)&#125;&quot;. Unexpected keys will be ignored.` ) &#125;&#125;function assertReducerSanity(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; var reducer = reducers[key] var initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === &apos;undefined&apos;) &#123; throw new Error( `Reducer &quot;$&#123;key&#125;&quot; returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined.` ) &#125; var type = &apos;@@redux/PROBE_UNKNOWN_ACTION_&apos; + Math.random().toString(36).substring(7).split(&apos;&apos;).join(&apos;.&apos;) if (typeof reducer(undefined, &#123; type &#125;) === &apos;undefined&apos;) &#123; throw new Error( `Reducer &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. ` + `Don&apos;t try to handle $&#123;ActionTypes.INIT&#125; or other actions in &quot;redux/*&quot; ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined.` ) &#125; &#125;)&#125;// 下面正式进入combineReducers.js文件的主函数，combineReducers（这句话怎么这么怪）export default function combineReducers(reducers) &#123; // 可以看到，首先是获取老的reducers的key数组 var reducerKeys = Object.keys(reducers) var finalReducers = &#123;&#125; for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i] // 判断老的reducer传入的key所对应的value是否是function，如果是，将老的reducer中的对象放入新的finalReducers对象中。 if (typeof reducers[key] === &apos;function&apos;) &#123; finalReducers[key] = reducers[key] &#125; &#125; var finalReducerKeys = Object.keys(finalReducers) // 判断node环境是否为生产环境，之前已经说过了，后面就不再赘述了。 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; var unexpectedKeyCache = &#123;&#125; &#125; // 验证finalReducers是否合法。 var sanityError try &#123; assertReducerSanity(finalReducers) &#125; catch (e) &#123; sanityError = e &#125; // 返回最终生成的reducer。 return function combination(state = &#123;&#125;, action) &#123; if (sanityError) &#123; throw sanityError &#125; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; var hasChanged = false var nextState = &#123;&#125; for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === &apos;undefined&apos;) &#123; var errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; // 遍历一遍看是否改变，然后返回原有状态值或者新的状态值 return hasChanged ? nextState : state &#125;&#125; compose.js123456789101112131415// compose可以接受一组函数参数，从右到左来组合多个函数，然后返回一个组合函数，reduceRight和reduce的差异就是reduceRight是从右边开始遍历的，至于后面的逗号简写方式，可以参考[这个问题](https://segmentfault.com/q/1010000007320321)。export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; 总结？这一次的redux源码解读先讲到这里吧，感觉这个信息量已经很大了，这些代码都是比较精简且耦合度低，没依赖其他的第三方库，仅仅读一遍还是远远不够的，除了代码的优秀，作者的设计思想也是十分优秀的，我还需要不断的学习才能达到这个高度，而至于bindActionCreators和applyMiddleware两个文件没有讲，我准备之后再来讲，外面天都黑了，非工作日一个人在办公室坐了一天，感觉周围都是寒冷😓。。。 2017年的第一篇博客over。","tags":[]},{"title":"redux example(1)","date":"2017-01-24T09:06:24.000Z","path":"2017/01/24/redux example(1)/","text":"最近在学习redux，看了不少相关的资料，发现这个官方教程的一些例子还是很不错的，由浅入深各个档次都有，所以我稍微看了下，准备有时间的话将示例都自己弄懂，然后分别写篇详细的解读出来，由于是临时起意，所以今天先写第一篇吧。 counter-vanilla这是redux中的第一个示例，也就是说是最简单的一个例子，不多说了，先看看代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Redux basic example&lt;/title&gt; &lt;script src=&quot;https://npmcdn.com/redux@latest/dist/redux.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; Clicked: &lt;span id=&quot;value&quot;&gt;0&lt;/span&gt; times &lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button id=&quot;incrementIfOdd&quot;&gt;Increment if odd&lt;/button&gt; &lt;button id=&quot;incrementAsync&quot;&gt;Increment async&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; function counter(state, action) &#123; if (typeof state === &apos;undefined&apos;) &#123; return 0 &#125; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1 case &apos;DECREMENT&apos;: return state - 1 default: return state &#125; &#125; var store = Redux.createStore(counter) var valueEl = document.getElementById(&apos;value&apos;) function render() &#123; valueEl.innerHTML = store.getState().toString() &#125; render() store.subscribe(render) document.getElementById(&apos;increment&apos;) .addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;) document.getElementById(&apos;decrement&apos;) .addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;) &#125;) document.getElementById(&apos;incrementIfOdd&apos;) .addEventListener(&apos;click&apos;, function () &#123; if (store.getState() % 2 !== 0) &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125; &#125;) document.getElementById(&apos;incrementAsync&apos;) .addEventListener(&apos;click&apos;, function () &#123; setTimeout(function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;, 1000) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如上面代码所示，一共也就几十行，而且就这一个文件，毕竟是最基础最简单的一个示例，所以也没有什么文件结构和包依赖，以及到node服务器等，，唯一的一个依赖也通过了script标签引入。不废话了，下面开始讲解一下代码吧。 dom结构就很简单吧，主要就是一个span标签包裹一个数字，然后就是几个button按钮，点击按钮的时候会让span标签里的数字增一、减一、奇数加一变为偶数、异步加一（也就是加个定时器延迟）。 下面来看script标签里的代码，也就是实现逻辑和功能的主要代码。 12345678910111213function counter(state, action) &#123; if (typeof state === &apos;undefined&apos;) &#123; return 0 &#125; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1 case &apos;DECREMENT&apos;: return state - 1 default: return state &#125;&#125; 这段代码主要实现的是reducer，它主要接收两个参数，一个是state，另一个是action，state指代的是react中的state（状态），也就是这里span标签中的数字，action是一个对象，通过action，reducer就知道该做什么，比如这段代码就是通过判断action.type，来对state进行操作。 这里有一个值得注意的点，那就是给state设置一个return的默认值，一般来说就写成function counter(state = initialState, action)，es6的写法，意思在忘了传state的时候给state传入一个默认值。 var store = Redux.createStore(counter) 上面这句代码，主要实现的是用createStore方法，创建store，而传入的参数counter我上面已经说过了，是一个reducer，所以store的创建实际上是这样的：var store = createStore(reducer)。 整个应用，只能有一个store！可是，reducer却可以有多个，这样问题就来了，由于创建store的时候需要传入reducer，而store只能有一个，但是reducer却可以有多个，那怎么办？]react-redux中又一个管理reducer的方法，叫做combineReducers，它能把所有的reducer集中整合为一个reducers，其使用方法是： 1234var reducers = combineReducers(&#123; reducers1, reducers2...&#125;) 关于react-redux的具体细节后面再说。 123456var valueEl = document.getElementById(&apos;value&apos;)function render() &#123; valueEl.innerHTML = store.getState().toString()&#125;render()store.subscribe(render) 这段代码就主要就是执行render函数了，store.getState() 函数，它将会返回state。如果是常规react的render函数的话，是将一个dom节点挂载到root element下面去，而在这个示例中，只要将状态挂载到对应的节点上去就可以了。最后一行代码是注册状态监听器，在这里指当store里面的state发生改变时，触发render回调函数 12345678910111213141516document.getElementById(&apos;increment&apos;).addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;)document.getElementById(&apos;decrement&apos;).addEventListener(&apos;click&apos;, function () &#123; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;) &#125;)document.getElementById(&apos;incrementIfOdd&apos;).addEventListener(&apos;click&apos;, function () &#123; if (store.getState() % 2 !== 0) &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125; &#125;)document.getElementById(&apos;incrementAsync&apos;).addEventListener(&apos;click&apos;, function () &#123; setTimeout(function () &#123; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;) &#125;, 1000) &#125;) 这段代码主要是给下面的各个按钮绑定事件，这里需要做的是分发action，通过store.dispatch(action)这个方法，把action传递给reducer，而reducer中已经定义好了具体的函数，会根据接收到的action来判断对state进行什么操作。 好了，第一个示例到此就基本结束了，下面我再好好地整理一下redux的具体流程： 1，通过createStore方法创建store，传入reducer参数，且一个应用只能有一个store。store常用的方法有：getState方法，用来获取state；dispatch方法用来分发action，subscribe方法用来注册监听器执行回调函数。 2，创建好store后，通过dispatch方法来分发action给reducer，action是一个对象。 3，reducer接收到了state（state可传可不传，但是要在reducer中写上没有传state时的情况判断），action后，会根据action里的type属性来对state进行对应的操作。 我描绘一下redux的流程图，大致这样的：const store = createStore(reducer) –&gt; store.dispatch(action) –&gt; reducer(state, action) –&gt; 根据state渲染页面","tags":[]},{"title":"vue todo示例","date":"2017-01-24T09:06:12.000Z","path":"2017/01/24/vue todo/","text":"最近抽空看了下vue，一个轻量级的前端框架（类库），它采用的mvvm模式，且数据双向绑定，刚好官方网站上有一个todo实例，我感觉和redux的todo实例很类似，所以准备将这两个框架的todo实例分别解读一下，来比较一下个中异同。 这个代码就两部分，先是html：123456789&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &lt;span&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt; &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 接下来是js代码： 123456789101112131415161718192021new Vue(&#123; el: &apos;#app&apos;, data: &#123; newTodo: &apos;&apos;, todos: [ &#123; text: &apos;Add some todos&apos; &#125; ] &#125;, methods: &#123; addTodo: function () &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125; &#125;, removeTodo: function (index) &#123; this.todos.splice(index, 1) &#125; &#125;&#125;) 我第一次看到这段代码的时候觉得有点诧异，就这么点代码就实现了一个todo list，比react少了好多，如果是redux的todo list，别说代码，文件夹数量就可以让你一双手数不过来，而这vue两个文件夹一共才这么点代码，下面来仔细看看这个代码吧。先看下html代码吧，除了原生的html代码外，这里有几个vue特有的属性，显而易见，所有以v开头的属性，都是vue特有的属性，比如这里的v-model=”newTodo”，v-on:keyup.enter=”addTodo”，v-for=”todo in todos”，v-on:click=”removeTodo($index)”，一共就这四个吧，而就是字符串模版了，从js文件的某个对象中获取数据来填充到页面上。js代码也很少，估计一共才十多行，抛去中间的内容不看，就成了new Vue({})了，很显然这就是new了一个Vue实例，算是初始化，然后我们再来对内容一行一行地解读。 1el: &apos;#app&apos; 先看一下app在html文件里指代的是什么，一看便知，app在这里指代的是最外层div的id，而这里的＃应该类似于jQuery选择器中的符号吧（所以我猜测这里也可以用“.app”来选择class为app的元素来作为Vue的容器），前面的el应该指的是element吧。再看下面： 123456data: &#123; newTodo: &apos;&apos;, todos: [ &#123; text: &apos;Add some todos&apos; &#125; ] &#125; 这个data很明显说明了这里面装的是数据，我们可以看到这里一共有两条数据，一条是newTodo的数据，类型是字符串，另一条是todos数据，类型是数组对象，然后我们现在再返回html中，查看那里用到了这两条数据的，可以看到v-model=”newTodo”，所以我们暂时可以知道具有v-model属性的这个input输入框和newTodo这条数据绑定了起来，至于是单向绑定还是双向绑定还是仅仅是初始化的时候绑定一次，我们现在还不知道，接着看下面的todos，v-for=”todo in todos”，可以明白的知道，这是个for遍历，类似于for(i in object)一样，而这里的意思就类似于在todos这个数组中遍历一下，然后在li标签内对遍历到的数据进行操作，下面就用到了字符串模版，将需要的数据提取出来就好了。继续往下面看： 123456789101112methods: &#123; addTodo: function () &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125; &#125;, removeTodo: function (index) &#123; this.todos.splice(index, 1) &#125;&#125; 这部分是methods，按照字面意思来看，叫做方法，也就是js中的函数（function），可以看到里面一共包含了两个function，一个是addTodo，另一个是removeTodo，回顾html文件，可以知道调用这两个函数方法的地方分别是v-on:keyup.enter和v-on:click，前一个就是类似于原生的onKeyup方法，而第二个就是onClick了，不过keyup后面跟了enter，说明这个keyup方法是和enter健绑定的，现在我们可以进入这两个函数内部看看，看它具体的实现方法。 1234567addTodo: function () &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125;&#125; 这个函数中主要是在针对this.newTodo进行操作，我们不难发现，newTodo这条数据是和v-model这个属性绑在一起的，然后这个属性又是和input输入框绑定在一起的，所以可以表明这里的this.newTodo指的就是input输入框里的值，然后再将其去除首尾空格，push进todos列表，最后再清空输入框。而我们再来看下另一个函数： 123removeTodo: function (index) &#123; this.todos.splice(index, 1)&#125; 这个函数更简单，就一句话，执行一个数组操作，删除数组的某一项，而这个函数的调用在这里：v-on:click=”removeTodo($index)”，可以看到在调用的时候传入了一个参数$index，这指的是对应的li标签的index，然后当点击的时候，就可以通过index来删除这个li标签了。 说了这么多，我知道，理工科的东西讲再多的道理都是十分抽象的，所以最后我还是上几张图吧，为了能够更好的理解。 图1这是初始化的时候，一切都为空。 图2然后我在输入框里输入数据，按下enter键。 图3可以看到，下面列表中多了一条数据，是我刚才输入的数据。 图4然后我又输入了几条数据，一共三条。 图5最后我删除其中一条，就删除第二条吧，点击右边的那个小叉就可以了，可以看到这条就被删了，其他的数据不变。","tags":[]},{"title":"vue.js 组件快速入门（一）","date":"2017-01-24T09:06:00.000Z","path":"2017/01/24/vue.js 组件入门（一）/","text":"前几天读了一篇好文章，vue组件化，这篇算是我自己提炼出来的的归纳与总结吧。 在前端开发中，以前我们会把常用的公共的方法（函数）提取出来，整合为一个库，最有名的当属jQ了吧，然后到了react出现，这些类库主要都是针对view层进行的操作与封装，我们又可以把view层面上的一些东西抽出来进行封装和整理，比如一个table，一个button，一个div等，也可以像曾经提取函数一样抽出来，写成公用的，在需要使用的地方直接引入就可以了，当然，也可以根据你实际运用的需要进行适当的自定义配置，而这些被抽出来共用的table，button，div这些，就叫做组件。 上面是我自己瞎扯的，原文作者讲得比较繁琐，所以我就用自己的语言来概述了一下，虽然这篇文章是我转载的，不过我也参考了其它的文章／博客，知识点的相似度接近80%，但是语言基本上都是我自己重新组织的，所以加了很多自己的想法和思考，下面我们开始进入正题。 ###vue组件，创建与注册的基本步骤。 vue组件的使用，有三个步骤，分别是创建组件，注册组件和使用组件，如下图所示。 我们可以用一段代码来演示这三个步骤： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.创建一个组件构造器 var myComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos; &#125;) // 2.注册组件，并指定组件的标签，组件的HTML标签为&lt;my-component&gt; Vue.component(&apos;my-component&apos;, myComponent) new Vue(&#123; el: &apos;#app&apos; &#125;); &lt;/script&gt;&lt;/html&gt; 运行结果很简单，就是一句“This is my first component!”，可以看到，使用组件和使用普通的HTML元素没什么区别，你可以就把组件当做一个HTML元素来使用。 要理解组件的创建和注册，我们可以用一下几个步骤来详细解释： Vue.extend()是Vue构造器的扩展，调用Vue.extend()创建的是一个组件构造器，而不是一个具体的组件实例。 Vue.extend()构造器有一个选项对象，选项对象的template属性用于定义组件要渲染的HTML。 使用Vue.component()注册组件时，需要提供2个参数，第1个参数时组件的标签，第2个参数是组件构造器。 Vue.component()方法内部会调用组件构造器，创建一个组件实例。 组件应该挂载到某个Vue实例下，否则它不会生效。 我们一句一句来分析，先是创建一个组件，代码是 123myComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos;&#125;) 创建组件很简单，直接调用vue构造器的扩展方法就行了，里面会传入一个对象，对象里面有个template属性，它指代的是这个组件的view的内容，是不是像react里面的render函数啊，它也是return的view内容，它们有哪些不同呢？毕竟学习知识要针对各种不同的但是有类似的知识点来进行归纳，整理和综合，才能进行融会贯通的运用。毕竟古人云：学而时习之，不亦悦乎！ 好了，这是创建，下面是注册了，注册也很简单，一句代码就搞定了：Vue.component(‘my-component’, myComponent);，使用Vue.component方法，传入两个参数，第一个参数是你想注册的组件名，第二个参数是你创建的组件名，是不是有点混淆？先是你通过Vue.extend创建了一个组件，名字叫myComponent，然后为了在HTML中能够当做标签来使用，你需要给你创建的这个组件注册一个组件名，名字叫做my-component，所以你在HTML就可以直接把你注册的组件名当做HTML标签来使用，像这样就可以了。现在组件创建好了，也注册好了，可是还不能直接使用，因为还需要new一个Vue实例，才能使用，像这样 123Vue(&#123; el: &apos;#app&apos;&#125;); 一个Vue实例接收一个对象，里面的el属性是你组件的挂载节点，于是我又情不自禁地联想到了react，ReactDOM.render( dom , root)，就像这样，react也是将一个view界面的虚拟dom挂载到一个root节点上，而这里的Vue同样，需要将刚才的组件也挂载到某个节点下，这两者之间的异同后面再说吧，先说一点主要的，vue里的节点指的是vue组件的作用域，这点是和react差异比较大的一点，你将vue组件挂载在了某个节点下，意思是这个组件只有在这个节点范围内才可以使用，至于是使用多次，使用一次，还是一次都不使用，都没问题。而我们这个实例上，就是挂载在了id为app的节点上，所以在这个节点的范围内都可以使用的形式，来调用vue组件myComponent。同理，如果你想在多个节点的作用域内使用某个vue组件的话，那你就得多new几次，把组件的挂载到多个节点下面就好了，而如果在没有实例化的组件中非法调用某个vue组件，它将不起任何作用。详细情况可以看以下代码： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app1&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;div id=&quot;app2&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;div id=&quot;app3&quot;&gt; &lt;!--该组件不会被渲染--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var myComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;This is a component!&lt;/div&gt;&apos; &#125;) Vue.component(&apos;my-component&apos;, myComponent) var app1 = new Vue(&#123; el: &apos;#app1&apos; &#125;); var app2 = new Vue(&#123; el: &apos;#app2&apos; &#125;) &lt;/script&gt;&lt;/html&gt; 在上面代码中，我们创建了一个名叫myComponent的vue组件，然后注册了一个名叫my-component的组件来当做HTML标签使用，最后我们实例化时，只在id=”app1”和id=”app2”中挂载了这个vue组件，而在实际使用的时候，我们在id=”app3”中也使用了这个组件，所以最后，只有id=”app1”和id=”app2”的div中组件成功地被替换成了“This is a component!”，而id=”app3”中的标签将不会被渲染。具体效果如下图所示： 好了，一个基本的vue组件的一整套流程基本就完全是这样了，any problems else？我知道，现在还有很多的问题没有解决，比如创建组件，注册组件和实例化挂载到某个节点下，整体步骤比较繁琐；注册组件的时候可以局部注册吗；组件可以嵌套吗？如果可以，如何嵌套；vue组件怎么怎么做成可扩展的？又怎样变为自定义配置呢？ 我下一篇博客再细细道来。","tags":[]},{"title":"D2总结（Fusion Design）","date":"2017-01-24T09:05:23.000Z","path":"2017/01/24/D2总结（1）/","text":"这周末去参加了D2前端技术论坛，听了这么多分享，发现有不少东西可以总结的，可是由于当天确实太累，所以没能及时整理出总结来，只好现在来慢慢回想，还好听分享时记了笔记的。 Fusion简介－－Work Smarter, Not Harder上面那句话是Fusion的代表。在页面开发中，一个前端工程师最讨厌听到的话就是，“产品或者UI说，你的按钮颜色不好看，换一下；你的这个宽度高了，改一下；你的那个边距宅了，调整一下。。。。。。” 不管别的前端怎样想的，反正我最讨厌听到类似的话，每次开发完了，产品和UI验收时都会说很多这种话（因为我做的是后台系统，没有UI稿），导致修改这些小细节也要浪费不少时间，虽然没什么难度，不过真的不想做这些东西啊。。。 这其实就是前端与UI协作中的沟通成本，UI说的一种样式，和我们前端所理解的一种样式在沟通交流中产生了偏差，导致我们开发出来的东西和最初设定的不一样。 说到这里，我想先举几个小示例。 nodejs现在为什么能那么火？就是因为它打通了前端工程师和后端工程师开发协作中的隔阂，直接让前端来写前端和后端，没有了协作问题，也没有了沟通问题；reactNative为什么现在也那么火？是因为它打通了移动端（H5，IOS，android）各个岗位的开发协作与沟通。nodejs真的特别好吗？我不知道，我只知道现在后端的主流还是java；rn是不是特别好，我不知道，因为我没用过，就算不好，但是这一点也不影响他们的伟大，他们的厉害。就因为他们解决了一些开发中普遍的痛点，打通了各个岗位之间的限制与隔阂，将协作与沟通成本直接变为了0，能不伟大？ 回到正题上来，Fusion解决的痛点是什么呢？就是前端工程师和UI设计师直接的沟通与协作问题。 这是Fusion官方的一个简介：Fusion 为设计者，前端开发者提供了一套轻松构建 DPL 的解决方案，将一套新品牌 DPL 的构建过程缩短到几不可见的程度。 并基于此建立了从设计师到前端，覆盖 DPL 从设计，开发，构建，稿件分发，代码发布的一整套完整产品链，目前已趋于成熟。通过Fusion，设计师可以直接更改页面上相对组件的样式，比如更改一个按钮的颜色，没有编程基础的设计师分分钟就可以解决，而不需要前端工程师来找到那个按钮，然后更改一下style里的color。。。 Fusion就是一套品牌可配置的中台 DPL 设计理论，它通过中台DPL可配置功能，完完全全做到了不用写一行代码，就开发出了一套新的组件。 通过一个拖拽平台和部分可配置的样式属性，就解决了这个问题，是不是很厉害呀。 （关于更加详细的介绍，可以参考现场分享出来的ppt） 续：Fusion的相关ppt已经拿到，一波三折啊～～～ https://pan.baidu.com/s/1nuIPw2d","tags":[]}]